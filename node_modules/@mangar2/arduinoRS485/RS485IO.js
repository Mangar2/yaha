/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      RS485IO.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * Version:     1.0
 * ---------------------------------------------------------------------------------------------------
 */

'use strict'

const SWITCH_ON = 0x4000
const SWITCH_OFF = 0x2000
const SUPPORTED_MESSAGE_VERSION = 1

const errorLog = require('errorLog')
const Message = require('message')
var SerialPort = require('serialport')
var Trace = require('./Trace')
var State = require('./RS485State')
var NetState = require('./RS485State')
var RS484Message = require('./RS485BinaryMessage')
var MessageProxy = require('./MessageProxy')
var state = new State()
const RS485DNS = require('./RS485DNS')

class RS485IO {
    constructor (broker, addresses, interfaces) {
        this.messageQueue = []
        this.messageProxy = new MessageProxy(broker)
        this.rs485DNS = new RS485DNS(addresses, interfaces)
        this.trace = new Trace()
        this.sendAmount = 0
        // Serial port
        this.serialPort = 0
        this.retryCount = 0
        this.state = undefined
        this.address = undefined
        this.maxMessageVersion = SUPPORTED_MESSAGE_VERSION
        this.curMessageVersion = SUPPORTED_MESSAGE_VERSION
        this.enableChangeMessageVersion = false
    }

    /**
     * Gets address and key of a command
     * @param {object} message message to find address, key and value for
     * @returns {object} object with address and key property
     */
    getAddressKeyAndValue (message) {
        var addressKeyValueMask = this.rs485DNS.getAddressKeyAndValueMask(message.topic)
        var valueMask = addressKeyValueMask.valueMask
        var value = message.value
        var result = {
            address: addressKeyValueMask.address,
            key: addressKeyValueMask.key
        }
        if (valueMask === undefined) {
            result.value = value
            if (result.key === 'V') {
                if (result.value === 'on') {
                    result.value = 3600
                }
                if (result.value === 'off') {
                    result.value = 0
                }
            }
        } else {
            result.value = (value == 'on' || value == 1) ? valueMask + SWITCH_ON : valueMask + SWITCH_OFF
        }

        return result
    }

    /**
     * processes submessages of a message
     * @param {RS484BinaryMessage} message to process
     */
    processSubMessages (message, callback) {
        var subtopics = this.rs485DNS.getSubtopics(message.topic)
        var value = message.value
        var isSwitchOnMessage = (value & SWITCH_ON) != 0
        var isSwitchOffMessage = (value & SWITCH_OFF) != 0
        var isSwitchMessage = isSwitchOnMessage || isSwitchOffMessage
        var hasSubmessages = false
        for (var sub in subtopics) {
            hasSubmessages = true
            var property = subtopics[sub]
            if (property.value !== undefined) {
                message.topic = sub
                var bitIsSet = (value & property.value) != 0
                if (!isSwitchMessage) {
                    message.value = bitIsSet ? 'on' : 'off'
                    callback(message)
                } else if (bitIsSet) {
                    message.value = isSwitchOffMessage ? 'off' : 'on'
                    callback(message)
                }
            }
        }
        return hasSubmessages
    }

    /**
     * Sends a message to the broker
     * @param {RS484BinaryMessage} message to add
     */
    sendMessageToBroker (message) {
        const publishMessage = new Message(
            this.rs485DNS.getTopic(message),
            message.value,
            message.reason
        )

        if (!message.hasError()) {
            if (!this.processSubMessages(publishMessage, (subMessage) => {
                this.messageProxy.sendMessage(subMessage)
            })) {
                this.messageProxy.sendMessage(publishMessage)
            }
        }
    }

    /**
     * Sets the address
     * @param {number} address
     * @returns undefined
     */
    setAddress (address) {
        this.address = address
        this.state = new NetState(this.address)
    }

    /**
     * Call to close the serial port
     */
    close () {
        this.serialPort.close(function (err) { console.log(err) })
    }

    /**
     * Handler called each tick to check if any message must or may be sent
     * @returns true, if any message has been sent.
     */
    processTick () {
        var messageSent = false
        var queueMessage
        var message = this.state.updateStateNoMessage()

        messageSent = this.sendMessage(message)
        if (messageSent) {
            this.messageProxy.updateMessageStatistic(message)
            if (message.value === state.ENABLE_SEND) {
                this.enableChangeMessageVersion = true
            }
        }
        if (this.state.maySend) {
            queueMessage = this.sendMessageFromQueue()

            // Prevent to send a message twice in the same tick.
            this.state.setMaySend(false)

            if (queueMessage !== undefined) {
                this.messageProxy.updateMessageStatistic(queueMessage)
                messageSent = true
            }
        }
        return messageSent
    }

    /**
     * Sends the time of day in minutes as broadcast
     */
    sendTimeOfDayInMinutes () {
        const BROADCAST_ADDRESS = 0
        const REPLY = 0
        var date = new Date()

        var timeOfDayInMinutes = date.getHours() * 60 + date.getMinutes()
        var message = new RS484Message()
        message.setVersionAndLength(this.curMessageVersion)
        message.setAddresses(1, BROADCAST_ADDRESS, REPLY)
        message.setKeyValue('C', timeOfDayInMinutes)
        this.addMessageToSendQueue(message)
    }

    /**
     * Opens the serial port to attach the arduino devices
     * @param {string} serialPortName name of the serial port
     * @param {number} baudrate baudrate of the serial connection
     * @param {function} openedFunction function to call if serial port is open
     */
    openArduinoPort (serialPortName, baudrate, openedFunction) {
        this.openSerialPort(serialPortName, baudrate, () => {
            setInterval(() => {
                try {
                    this.processTick(this.messageProxy)
                } catch (err) {
                    console.log(err)
                }
            }, 100)

            setInterval(() => {
                this.sendTimeOfDayInMinutes()
            }, 1000 * 60)

            this.serialPort.on('error', function (err) {
                errorLog(err)
            })

            openedFunction()
        })
    }

    /**
     * Sets the version of messages to send
     * @param {number} version of the messages to send
     */
    setCurMessageVersion (version, isRegistered) {
        if (this.enableChangeMessageVersion && version <= this.maxMessageVersion) {
            this.curMessageVersion = version
        }
    }

    /**
     * processes a message handing over the token to the server
     * @param {RS485BinaryMessage} receivedMessage received token message
     */
    processTokenMessage (receivedMessage) {
        var registered = this.state.isRegistered()
        var responseMessage = this.state.processIncomingStateMessage(receivedMessage)
        if (responseMessage !== undefined) {
            responseMessage = this.state.setFriendlyName(responseMessage)
            this.sendMessage(responseMessage)
        }
        if (!receivedMessage.hasError() && receivedMessage.value === state.ENABLE_SEND) {
            this.setCurMessageVersion(receivedMessage.version, registered)
        }
    }

    /**
     * Processes a message received:
     * 1. Trace the message
     * 2. Remove last message from messagequeue if this is the corresponding acklowledge message
     * @param {RS485BinaryMessage} receivedMessage received message
     * @returns undefined
     */
    processMessageRead (receivedMessage) {
        this.traceRead(receivedMessage)
        this.messageProxy.updateMessageStatistic(receivedMessage)
        if (!receivedMessage.hasError()) {
            if (receivedMessage.isTokenMessage()) {
                this.processTokenMessage(receivedMessage)
            } else {
                if (receivedMessage.isResponseMessage(this.messageQueue[0])) {
                    receivedMessage.reason = this.messageQueue[0].reason
                    receivedMessage.reason.push({
                        message: 'Acknowledge from arduino',
                        timestamp: receivedMessage.timestamp
                    })
                    this.dequeue()
                } else {
                    receivedMessage.reason = [{
                        message: 'Info from arduino',
                        timestamp: receivedMessage.timestamp
                    }]
                }
                this.sendMessageToBroker(receivedMessage)
            }
        } else {
            errorLog(receivedMessage.error)
        }
    }

    /**
     * Reads messages from a serial stream and stores it to a message tree
     * @param that pointer to the class object
     * @param {array} stream array of received bytes
     */
    readAndStoreMessages (stream, callback) {
        var startIndex = 0
        var message = new RS484Message()
        // console.log(stream.toString());
        startIndex = message.setFromByteStream(stream, startIndex)
        while (message.isComplete() && !message.hasError()) {
            message = this.state.setFriendlyName(message)
            this.processMessageRead(message)

            if (!message.isTokenMessage()) {
                console.log(message.hexString)
                if (!message.hasError()) {
                    message.topic = this.rs485DNS.getTopic(message)
                    if (callback !== undefined) {
                        callback(message)
                    }
                }
            }
            message = new RS484Message()
            startIndex = message.setFromByteStream(stream, startIndex)
        }
    }

    /**
     * Adds a message to the send queue. If there is already a message with the same command in the queue,
     * the message is replaced
     * @param {RS484BinaryMessage} message message to add to the queue.
     * @returns undefined
     */
    addMessageToSendQueue (message) {
        var queueLength = this.messageQueue.length
        var sameCommand = false
        for (var queueIndex = 0; queueIndex < queueLength; queueIndex++) {
            sameCommand = message.isSameCommand(this.messageQueue[queueIndex])
            if (sameCommand) {
                this.messageQueue[queueIndex] = message
                break
            }
        }
        if (!sameCommand) {
            this.messageQueue.push(message)
        }
    }

    /**
     * Removes the latest message from the message queue
     * @returns undefined
     */
    dequeue () {
        this.messageQueue.shift()
    }

    /**
     * Sends a message from queue and removes it, if no reply expected
     * @returns undefined
     */
    sendMessageFromQueue () {
        var messageSend
        if (this.sendMessage(this.messageQueue[0])) {
            this.retryCount++
            messageSend = this.messageQueue[0]
            if (this.retryCount > 10 || messageSend.reply === 0) {
                this.dequeue()
                this.retryCount = 0
            }
        }
        return messageSend
    }

    /**
     * called, once the serial port is open
     * @param {string} serialPortName name of the serial port (example "COM1")
     */
    isOpenHandler (serialPortName, isOpenCallback) {
        console.log('Serial Port ' + serialPortName + ' Opend')

        this.serialPort.on('close', function () {
            console.log('Serial port closed')
        })

        this.serialPort.on('error', function (err) {
            errorLog('Serial port error ' + err)
        })

        isOpenCallback()
    }

    /**
     * Opens the serial port
     * @param {string} serialPortName name of the serial port (example "COM1")
     * @param {number} baudrate baud rate (example 9600)
     * @param {function} receiveDataCallback callback function to be called, if the com port receives data
     * @returns undefined
     */
    openSerialPort (serialPortName, baudrate, receiveDataCallback) {
        this.serialPort = new SerialPort(serialPortName, { baudRate: baudrate }, function (err) {
            if (err) {
                errorLog(err.message)
                console.log('Available ports: ')
                // list serial ports:
                SerialPort.list((err, ports) => {
                    ports.forEach((port) => {
                        console.log(port.comName)
                    })
                })
            }
        })

        this.serialPort.on('open', () => {
            this.isOpenHandler(serialPortName, receiveDataCallback)
        })
    }

    /**
     * Traces a message when reading it
     * @param {RS485BinaryMessage} message message to trace
     */
    traceRead (message) {
        var traceLevel = this.trace.MAX_LEVEL
        var traceMessage = {
            sender: message.sender,
            receiver: message.receiver,
            key: message.key,
            value: message.getValueFriendlyName(),
            hexcode: message.getHexString(),
            timestamp: message.timestamp
        }
        if (!message.isTokenMessage()) {
            traceLevel = 1
        } else if (message.value !== state.ENABLE_SEND && message.value !== state.REGISTRATION_REQUEST) {
            traceLevel = 3
        }
        if (message.hasError()) {
            traceLevel = 0
            traceMessage.error = message.error
        }

        this.trace.addTrace(traceLevel, traceMessage)
    }

    /**
     * Traces a message when sending it
     * @param {RS485BinaryMessage} message message to trace
     */
    traceSend (message) {
        var traceLevel = this.trace.MAX_LEVEL
        var traceMessage = {
            sender: message.sender,
            receiver: message.receiver,
            key: message.key,
            value: message.getValueFriendlyName(),
            hexcode: message.getHexString(),
            timestamp: message.timestamp
        }
        if (!message.isTokenMessage()) {
            traceLevel = 0
        } else if (message.value !== state.ENABLE_SEND) {
            traceLevel = 3
        }
        this.trace.addTrace(traceLevel, traceMessage)
    }

    /**
     * Sends a message to a serial port
     * @param {RS485BinaryMessage} message message to send
     * @param {serialport} serialPort serial port to send to
     * @returns true, if sending was successful
     */
    sendMessage (message) {
        'use strict'
        var result = false

        if (message !== undefined && message.key !== undefined) {
            if (message.version === undefined) {
                message.setVersionAndLength(this.curMessageVersion)
            }
            message.timestamp = new RS484Message().getLocalTimeAsISOString()
            this.traceSend(message)
            if (!message.isTokenMessage()) {
                console.log(message.getLogString())
            }
            var byteArray = message.getByteArray()
            this.serialPort.write(byteArray, function (err) {
                if (err) {
                    errorLog('Error while sending message : ' + err)
                }
            })
            this.sendAmount++
            result = true
        }
        return result
    }
}

module.exports = RS485IO
