/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * Provides a standard client to communicate with the mqtt broker
 */

'use strict'

const BROADCAST_ADDRESS = 0

const STATE_UNKNOWN = 0
const NEIGHBOUR_UNKNOWN = 255
const STATE_REBOOT = 1
const STATE_SINGLE = 2
const STATE_UNREGISTERED = 3
const STATE_REGISTERED = 4

const MAX_WAIT_TIMER = 100
const TIMER_SMALL_PERIOD = 3
const TIMER_LARGE_PERIOD = 7
const TIMER_LOOP = TIMER_SMALL_PERIOD + TIMER_LARGE_PERIOD
const TIMEOUT_NO_ENABLE_SEND = 4 * TIMER_LOOP

const STATE_UNCHANGED = 0
const ENABLE_SEND = 1
const REGISTRATION_INFO = 2
const REGISTRATION_REQUEST = 3
const STATE_CHANGED = 4
const LOOP_TIMEOUT = 10
const LOOP_START = 11
const LOOP_SHORT_BREAK = 12
const LOOP_LONG_BREAK = 13

class RS485State {
    constructor () {
        this.state = STATE_UNKNOWN
        this.timer = 0
        this.lastEnableSend = 0
        this.neighbour = NEIGHBOUR_UNKNOWN
        this.leftmostCeibling = 0
        this.maySend = false
    }

    /**
     * True, if the system may send data
     * @Type {boolean}
     */
    set maySend (maySend) { this._maySend = maySend }
    get maySend () { return this._maySend }

    /**
     * Adress of the next neighbour in the token chain
     * @Type {number}
     */
    get neighbour () { return this._neighbour }
    set neighbour (neighbour) { this._neighbour = neighbour }

    /**
     * Adress of the leftmost child in the token chain
     * @Type {number}
     */
    get leftmostCeibling () { return this._leftmostCeibling }
    set leftmostCeibling (leftmostCeibling) { this._leftmostCeibling = leftmostCeibling }

    /**
     * Gets the address of the next receiver in the node chain
     * @returns {number} address of the next receiver in the node chain
     */
    getReceiverAddress () {
        if (this.neighbour === NEIGHBOUR_UNKNOWN) {
            if (this.leftmostCeibling === NEIGHBOUR_UNKNOWN) {
                return BROADCAST_ADDRESS
            }
            return this.leftmostCeibling
        } else {
            return this.neighbour
        }
    }

    /**
     * Calculates an enable send request
     * It is either "enable send", if it is directly addressed to myself or a registration request, if it is boradcasted
     * @returns {number} enable send request
     * @private
     */
    calculateEnableSend () {
        var res = 0
        if (this.getReceiverAddress() === this.BROADCAST_ADDRESS) {
            res = REGISTRATION_REQUEST
        } else {
            res = ENABLE_SEND
        }
        return res
    }

    /**
     * Checks, if the current state is "Registered"
     * @returns {boolean} true, if the current state is "Registered"
     */
    isRegistered () {
        return this.state === STATE_REGISTERED
    }

    /**
     * returns a string representing the current state
     * @returns {string} current state
     */
    getStateString () {
        let result
        switch (this.state) {
        case STATE_UNKNOWN: result = 'Unknown'; break
        case STATE_REBOOT: result = 'Reboot'; break
        case STATE_SINGLE: result = 'Single'; break
        case STATE_UNREGISTERED: result = 'Unregistered'; break
        case STATE_REGISTERED: result = 'Registered'; break
        default: result = 'Undefined'
        }
        return result
    }

    /**
     * Updates the current state
     * @param {number} request state request value
     * @param {boolean} notForMe true, if the request is not addressed to myself
     * @returns {number} new state value
     */
    updateState (request, notForMe) {
        var res = STATE_UNCHANGED
        switch (this.state) {
        case STATE_UNKNOWN: res = this.processUnknown(request, notForMe); break
        case STATE_REBOOT: res = this.processReboot(request, notForMe); break
        case STATE_SINGLE: res = this.processSingle(request, notForMe); break
        case STATE_UNREGISTERED: res = this.processUnregistered(request, notForMe); break
        case STATE_REGISTERED: res = this.processRegistered(request, notForMe); break
        }
        return res
    }

    /**
     * Calculates a new state and updates when no message has been received
     * @returns {number} new state value
     */
    updateStateNoMessage () {
        var loopState
        var res = STATE_UNCHANGED
        if (this.timer >= MAX_WAIT_TIMER) {
            res = this.updateState(LOOP_TIMEOUT)
        } else {
            loopState = this.timer % TIMER_LOOP
            if (loopState === 0) {
                res = this.updateState(LOOP_START)
            } else if (loopState === TIMER_SMALL_PERIOD) {
                res = this.updateState(LOOP_SHORT_BREAK)
            } else if (loopState === TIMER_LARGE_PERIOD) {
                res = this.updateState(LOOP_LONG_BREAK)
            }
        }
        if (res !== STATE_CHANGED) {
            this.timer += 1
        }
        return res
    }

    /**
     * Sets a new state
     */
    setState (newState) {
        this.timer = 0
        this.state = newState
    }

    /**
     * processes an enable send command (token) while in any other state than registered.
     * If the command is not for myself, we set the state to unregistered as we know now that there are other devices on the bus
     * If the command is for myself we set the state to registered, as we know that at least one device added us to this
     * device chain and will continue to send us tokens
     */
    processEnableSendWhenNotRegistered (notForMe) {
        if (notForMe) {
            this.setState(STATE_UNREGISTERED)
        } else {
            this.setState(STATE_REGISTERED)
            this.maySend = true
        }
        return STATE_CHANGED
    }

    /**
     * Processes a request while in "unknown" state
     * @param {number} request request number
     * @param {boolean} notForMe true, if the request is not addressed to myself
     * @returns {number} state change information
     * @private
     */
    processUnknown (request, notForMe) {
        var res = STATE_UNCHANGED
        this.maySend = false
        switch (request) {
        case ENABLE_SEND:
            res = this.processEnableSendWhenNotRegistered(notForMe)
            break
        case REGISTRATION_INFO:
            // Only registration request will lead to a registration
            break
        case REGISTRATION_REQUEST:
            this.setState(STATE_UNREGISTERED)
            res = REGISTRATION_INFO
            break
        case LOOP_START:
            if (this.timer === 0) {
                this.neighbour = NEIGHBOUR_UNKNOWN
                this.leftmostCeibling = NEIGHBOUR_UNKNOWN
            }
            break
        case LOOP_TIMEOUT:
            this.setState(STATE_REBOOT)
            res = STATE_CHANGED
            break
        }
        return res
    }

    /**
     * Processes a request while in "reboot" state. In the reboot state everything is unknown.
     * We are only listen for registration requests.
     * @param {number} request request number
     * @param {boolean} notForMe true, if the request is not addressed to myself
     * @returns {number} state change information
     * @private
     */
    processReboot (request, notForMe) {
        var res = STATE_UNCHANGED
        this.maySend = false
        switch (request) {
        case ENABLE_SEND:
            res = this.processEnableSendWhenNotRegistered(notForMe)
            break
        case REGISTRATION_INFO:
            // Only a registration request will lead to a registration
            break
        case REGISTRATION_REQUEST:
            this.setState(STATE_UNREGISTERED)
            res = REGISTRATION_INFO
            break
        case LOOP_START:
            res = this.calculateEnableSend()
            break
        case LOOP_TIMEOUT:
            this.setState(STATE_SINGLE)
            res = STATE_CHANGED
            break
        }
        return res
    }

    /**
     * Processes a request while in "single" state.
     * In single state, we did not detect any other sending device on the RS485 bus. We are waiting for new
     * devices joining the bus and are sending data.
     * @param {number} request request number
     * @param {boolean} notForMe true, if the request is not addressed to myself
     * @returns {number} state change information
     * @private
     */
    processSingle (request, notForMe) {
        var res = STATE_UNCHANGED

        switch (request) {
        case ENABLE_SEND:
            res = this.processEnableSendWhenNotRegistered(notForMe)
            break
        case REGISTRATION_INFO:
            this.maySend = false
            this.setState(STATE_UNKNOWN)
            res = STATE_CHANGED
            break
        case REGISTRATION_REQUEST:
            this.maySend = false
            this.setState(STATE_UNREGISTERED)
            res = REGISTRATION_INFO
            break
        case LOOP_START:
            this.maySend = false
            res = REGISTRATION_REQUEST
            break
        case LOOP_SHORT_BREAK:
            this.maySend = true
            break
        case LOOP_TIMEOUT:
            this.timer = 0
            break
        }
        return res
    }

    /**
     * Processes a request while in "unregistered" state.
     * In unregistered state, we already detectd other devices on the bus, but we did not yet register to the bus.
     * We are sending registration informations and requests for other devices to register.
     * @param {number} request request number
     * @param {boolean} notForMe true, if the request is not addressed to myself
     * @returns {number} state change information
     * @private
     */
    processUnregistered (request, notForMe) {
        var res = STATE_UNCHANGED
        this.maySend = false
        switch (request) {
        case ENABLE_SEND:
            if (!notForMe) {
                this.setState(STATE_REGISTERED)
                this.maySend = true
            }
            res = STATE_CHANGED
            break
        case REGISTRATION_INFO:
            break
        case REGISTRATION_REQUEST:
            res = REGISTRATION_INFO
            break
        case LOOP_TIMEOUT:
            this.setState(STATE_UNKNOWN)
            res = STATE_CHANGED
            break
        }
        return res
    }

    /**
     * Sub function to process a registered state. Things we do, in the first part of a standard loop:
     * Checking for lost tokens, deactivating may send, requesting registrations of devices ...
     * @param {number} request request number
     * @param {boolean} notForMe true, if the request is not addressed to myself
     * @returns {number} state change information
     * @private
     */
    registeredShortLoopBreak () {
        var res = STATE_UNCHANGED
        this.tokenLost = (this.lastEnableSend + TIMEOUT_NO_ENABLE_SEND <= this.timer)
        if (this.timer === TIMER_SMALL_PERIOD || this.tokenLost) {
            this.lastEnableSend = this.timer
            this.maySend = false
            if (this.neighbour === NEIGHBOUR_UNKNOWN && !this.tokenLost) {
                res = REGISTRATION_REQUEST
            } else {
                res = ENABLE_SEND
            }
        }
        return res
    }

    /**
     * Processes a request while in "registered" state. This is the normal state after the device registered to the bus.
     * In registered state we send messages, listen for messages, requests for new devices to register and are checking
     * for timeout situations
     * @param {number} request request number
     * @param {boolean} notForMe true, if the request is not addressed to myself
     * @returns {number} state change information
     * @private
     */
    processRegistered (request, notForMe) {
        var res = STATE_UNCHANGED
        switch (request) {
        case ENABLE_SEND:
            if (!notForMe) {
                this.maySend = true
                this.timer = 0
            } else {
                this.maySend = false
                this.lastEnableSend = this.timer
            }
            break
        case REGISTRATION_INFO: break
        case REGISTRATION_REQUEST: break
        case LOOP_SHORT_BREAK:
            res = this.registeredShortLoopBreak()
            break
        case LOOP_LONG_BREAK:
            if (this.timer === TIMER_LARGE_PERIOD && this.neighbour === NEIGHBOUR_UNKNOWN && this.leftmostCeibling !== NEIGHBOUR_UNKNOWN) {
                res = ENABLE_SEND
            }
            break
        case LOOP_TIMEOUT:
            this.setState(STATE_UNREGISTERED)
            res = STATE_CHANGED
            break
        }
        return res
    }
}

module.exports = RS485State
