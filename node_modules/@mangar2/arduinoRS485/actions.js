/**
 * 8MHz 6mA
 * 4MHz 3,4mA
 * 2MHz 2mA
 * 1MHz 1mA
 * DIV 256 0,053 mA
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const { Retry, types, errorLog } = require('@mangar2/utils')
const ONE_SECOND = 1000

/**
 * Creates a class supporting message actions:
 * - blink (lets a lamp blink)
 * - temporary (switches on temporarily and automatically switches off)
 * - set set the value
 * @param {Object} options
 */
class Actions {
    constructor (options) {
        this._retry = new Retry()
        this._topics = {}
        this._options = options
    }

    /**
     * blinks an amount of times
     * Blinks reverse, if the device is currently on (off/on instead of on/off)
     * The device will be at the inital state after blinking
     * @param {string} topic topic of the message
     * @param {number} amount amount of blink cycles (if < 1 it will blink exactly once)
     * @param {string} state current state of the element to blink ("on" or "off")
     * @param {function} switchFunction function(newState) switching the device
     * @private
     */
    _blink (topic, amount, state, switchFunction) {
        const retryCnt = amount > 0 ? amount * 2 : 2
        let newState = state

        if (types.isFunction(switchFunction)) {
            this._retry.topicRetry(topic, retryCnt, 3 * ONE_SECOND, cnt => {
                newState = newState === 'on' ? 'off' : 'on'
                switchFunction(newState)
            })
        }
    }

    /**
     * Sets switches on temporarily
     * Enables a switch for some time and switch it of automatically
     * @param {string} topic topic of the message
     * @param {string} state current state of the element ("on" or "off")
     * @param {function} switchFunction function(newState) switching the device
     * @private
     */
    _temporary (topic, state, switchFunction) {
        const STANDARD_DELAY_IN_SECONDS = 20 * 60
        const retryCnt = state !== 'off' ? 2 : 1
        let newState = state === 'on' || state === 'off' ? state : 'on'
        const delayTimeInSeconds = isNaN(state) ? STANDARD_DELAY_IN_SECONDS : state

        if (types.isFunction(switchFunction)) {
            this._retry.topicRetry(topic, retryCnt, delayTimeInSeconds * ONE_SECOND, cnt => {
                switchFunction(newState)
                newState = newState === 'on' ? 'off' : 'on'
            })
        }
    }

    /**
     * Switches on directly. Terminates all other loops like blink or temporarly.
     * Example: A switch is set ot on temporarly for 10 minutes. After 5 minutes the switch is
     * "set" to on. Then the automatic switch off of the temporary call is disabled
     * @param {string} topic topic of the message
     * @param {function} switchFunction function(newState) switching the device
     */
    _set (topic, switchFunction) {
        const retryCnt = 1
        if (types.isFunction(switchFunction)) {
            this._retry.topicRetry(topic, retryCnt, 3 * ONE_SECOND, cnt => {
                switchFunction()
            })
        }
    }

    /**
     * Processes a mqtt message
     * @param {Message} message message to process
     * @param {SendCallback} switchFunction function processing the message
     */
    processMessage (message, sendMessage) {
        try {
            message.topic = message.topic.toLowerCase()
            const { topic, value } = message
            const curState = this._topics[topic]
            if (topic.endsWith('/set')) {
                message.topic = topic.replace('/set', '')
                this._set(topic, () => {
                    sendMessage(message)
                })
            } else if (topic.endsWith('/temporary')) {
                message.topic = topic.replace('/temporary', '')
                this._temporary(topic, curState, newValue => {
                    message.value = newValue
                    sendMessage(message)
                })
            } else if (topic.endsWith('blink')) {
                message.topic = topic.replace('/blink', '')
                this._blink(topic, value, curState, newValue => {
                    message.value = newValue
                    sendMessage(message)
                })
            }
        } catch (err) {
            errorLog(err)
        }
    }

    /**
     * Stores the current state of a topic
     * @param {string} topic topic to store
     * @param {any} value value to store
     */
    storeState (topic, value) {
        this._topics[topic] = value
    }
}

module.exports = Actions
