/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * Interface service to communicate with several arduino or similar microcontroller based on a RS485 bus
 * The underlying protocol is token based. Tokens are send from one arduino to the other. The arduino having
 * the token may send. Data is send in an internal message format. The message contains:
 * - Byte: Sender address
 * - Byte: Receiver address
 * - Byte: Reply (bit 1) and message format version (bit 2..8)
 * - Byte: Message length
 * - Byte: Command to handle
 * - Word: (2 bytes) value, usual positive integer
 * - Word: CRC16 for error handling
 */

'use strict'

const { Callbacks, errorLog } = require('@mangar2/utils')
const SerialConnection = require('./serialconnection')
const ReadMessages = require('./readmessages')
const ArduinoDNS = require('./arduinodns')
const RS485Schedule = require('./rs485schedule')
const sanitizeConfiguration = require('./configuration')

/**
 * Callback to publish messages to the mqtt broker
 * @callback Publish
 * @param {Message} message message to publish
 */

/**
 * Creates a service class to communicate with several arduino over a RS485 bus
 * Most options are preset (see "configuration.js" for all presets). You must provide
 * the serial port name in operating system format and a list of addresses as object
 * @example
 * const serialPortName = 'COM1'
 * // Do not use 0 or 1 as addresses. 0 is used for broadcast events and 1 is the
 * // default address of this service.
 * const addresses = {
 *    myFloor/myRoom/myDevice: 2,
 *    myOtherFloor/myOtherRoom/myDevice: 3
 *    ...
 * }
 * const arduinoService = new ArduinoRS485({ serialPortName, addresses })
 * @param {Object} options configuration options
 * @param {string} options.serialPortName name of the port to use
 * @param {integer} [options.baudrate=57600] baud rate to be used
 * @param {integer} [options.myAddress=1] address of this rs485 server
 * @param {integer} [options.maxVersion=1] maximal suported interface version
 * @param {integer} [options.tickDelay=100] inner clock managing the token, every action is calculated
 * @param {0|1|2} [options.qos=1] quality of service to send messages
 */
class ArduinoRS485 {
    constructor (options) {
        options = sanitizeConfiguration(options)
        this._serial = new SerialConnection()
        this._callbacks = new Callbacks(['publish'])
        this._read = new ReadMessages()
        this._schedule = new RS485Schedule(options)
        this._serialPortName = options.serialPortName
        this._baudrate = options.baudrate
        this._qos = options.qos
        this._arduinoDNS = new ArduinoDNS(options)
    }

    /**
     * Sets a callback.
     * @param {string} event event name (not case sensitive) for the callback (supported: 'publish')
     * @param {Publish} callback function(...parameter)
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on (event, callback) {
        this._callbacks.on(event, callback)
    }

    /**
     * Publishes mqtt messages to the broker
     * @param {Message[]} mqttMessages messages to publish
     */
    _publish (mqttMessages) {
        for (const message of mqttMessages) {
            message.qos = this._qos
            this._callbacks.invokeCallback('publish', message)
        }
    }

    /**
     * Starts the server
     */
    async run () {
        this._serial.on('data', (byteArray) => {
            const readResult = this._read.read(byteArray)
            for (const result of readResult) {
                console.log('%s %s', result.hex, result.error)
                if (result.message) {
                    const mqttMessages = this._arduinoDNS.toMqttMessages(result.message)
                    this._publish(mqttMessages)
                    this._schedule.processReceivedMessage(result.message)
                }
            }
        })
        try {
            await this._serial.open(this._serialPortName, this._baudrate)
            this._schedule.on('send', async (byteArray) => {
                this._serial.sendData(byteArray)
            })
            this._schedule.run()
            console.log('rs485 service running')
        } catch (err) {
            await this._serial.listAvailablePorts()
            errorLog(err)
        }
    }

    /**
     * Stops the service
     */
    close () {
        this._schedule.close()
    }

    /**
     * Processes an incoming mqtt message
     * @param {Message} message mqtt message
     */
    processMessage (message) {
        const serialMessage = this._arduinoDNS.toSerialMessage(message)
        this._schedule.sendMessage(serialMessage)
    }
}

module.exports = ArduinoRS485
