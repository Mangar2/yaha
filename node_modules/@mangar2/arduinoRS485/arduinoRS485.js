/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const { Callbacks } = require('@mangar2/utils')
const SerialConnection = require('./serialconnection')
const ReadMessages = require('./readmessages')
const MqttToSerial = require('./mqtttoserial')
const RS485Schedule = require('./rs485schedule')

/**
 * @param {Object} options configuration options
 * @param {string} options.serialPortName name of the port to use
 * @param {integer} options.baudrate baud rate to be used
 * @param {integer} options.myAddress address of this rs485 server
 * @param {integer} options.maxVersion maximal suported interface version
 * @param {integer} options.tickDelay inner clock managing the token, every action is calculated
 */
class ArduinoRS485 {
    constructor (options) {
        this._serial = new SerialConnection()
        this._callbacks = new Callbacks(['publish'])
        this._read = new ReadMessages()
        this._schedule = new RS485Schedule(options)
        this._serialPortName = options.serialPortName
        this._baudrate = options.baudrate
        this._mqttToSerial = new MqttToSerial(options)
    }

    /**
     * Sets a callback.
     * @param {string} event event name (not case sensitive) for the callback (supported: 'publish')
     * @param {function} callback function(...parameter)
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on (event, callback) {
        this._callbacks.on(event, callback)
    }

    /**
     * Initializes the serial connection
     * @private
     */
    async run () {
        this._serial.on('data', (byteArray) => {
            const readResult = this._read.read(byteArray)
            for (const result of readResult) {
                console.log('%s %s', result.hex, result.error)
                if (result.message) {
                    this._schedule.processReceivedMessage(result.message)
                    // ToDo publish
                }
            }
        })
        await this._serial.open(this._portName, this._baudrate)
        this._schedule.on('send', async (byteArray) => {
            this._serial.sendData(byteArray)
        })
        this._schedule.run()
    }

    /**
     * Processes a mqtt message
     * @param {Message} message mqtt message
     */
    processMessage (message) {
        const serialMessage = this._mqttToSerial.toSerialMessage(message)
        this._schedule.sendMessage(serialMessage)
    }
}

module.exports = ArduinoRS485
