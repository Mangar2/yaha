/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const { types } = require('@mangar2/utils')
const {
    MESSAGE_SIZE_V0,
    MESSAGE_SIZE_V1,
    MAX_ADDRESS
} = require('./constants')

class ReadMessage {
    constructor() {
        this._startIndex = 0
        this._hexString = ""
        this._error = null
    }

    /**
     * Clears all error states
     */
    clearError () {
        this._error = null
    }

    /**
     * Detects noise (usually received '0') and skips it
     * @param {Array} byteArray
     * @private
     */
    _skipNoise (byteArray) {
        // The RS485 USB Adapter gets zeros from time to time, if nobody is sending.
        // Messages coming in starts with the sender address that may neither be zero nor > MAX_ADDRESS
        while (byteArray.length > this._startIndex && 
            (byteArray[this._startIndex] === 0 || byteArray[this._startIndex] > MAX_ADDRESS)) {
                this._startIndex++;
        }
    }


    /**
     * Sets the package content from an array of bytes
     * @param {Array} byteArray
     * @throws {string} error text
     * @private
     */
    _setFromByteArray (byteArray, startIndex) {
        startIndex = this._skipNoise(byteArray);

        if (byteArray.length >= MESSAGE_SIZE_V0 + startIndex) {
            this.setMessage(byteArray, startIndex);
            this.hexString = this.calcHexString(byteArray, startIndex, this.length);
            startIndex += this.length;
            this.state = COMLETELY_RECEIVED;
        } else if (byteArray.length > startIndex)  {
            this.error = "insufficient data received";
            this.hexString = this.calcHexString(byteArray, startIndex, MESSAGE_SIZE_V0);
        } 

        return startIndex;
    }

    /**
     * Sets a message partially from a stream
     * @param {array} byteArray containing the network traffic
     */
    setFromByteStream (byteArray) {
        this.clearError();
        if (types.isArray(byteArray)) {
            this._startIndex = this.setFromByteArray(byteArray, this._startIndex);
        } else {
            this._hexString = "";
        }
    };

}

module.exports = ReadMessage

serialIO.serialPort.on('data', (stream) => {
    try {
        serialIO.readAndStoreMessages(stream, (message) => {});
    }
    catch (err) {
        console.error(err);
    }
});

/**
 * Reads messages from a serial stream and stores it to a message tree
 * @param that pointer to the class object
 * @param {array} stream array of received bytes
 */
readAndStoreMessages (stream, callback) {
    var startIndex = 0;
    var message = new RS484Message();
    //console.log(stream.toString());
    startIndex = message.setFromByteStream(stream, startIndex);
    while (message.isComplete() && !message.hasError()) {
        message = this.state.setFriendlyName(message);
        this.processMessageRead(message);

        if (!message.isTokenMessage()) {
            console.log(message.hexString);
            if (!message.hasError()) {
                message.topic = this.rs485DNS.getTopic(message);
                if (callback !== undefined) {
                    callback(message);
                }
            }
        } 
        message = new RS484Message();
        startIndex = message.setFromByteStream(stream, startIndex);
    }
}

    /**
     * Creates a debug information as string from a
     * @param {array} byteArray
     * @param {number} startIndex first element to concider
     * @returns {string} string showing legth and hex code of the byteArray
     */
    toHexString (byteArray, startIndex, messageSize) {
        if (byteArray === undefined) {
            return;
        }
        var length = byteArray.length;
        var i;
        var hex;
        var log = "([" + length + "] ";

        for (i = 0; i < Math.min(length - startIndex, messageSize); i++) {
            hex = byteArray[i + startIndex].toString(16);
            if (hex.length < 2) {
                hex = "0" + hex;
            }
            log += " " + hex;
        }
        log +=")";
        return log;

    };