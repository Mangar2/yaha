/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * Provides a standard client to communicate with the mqtt broker
 */

'use strict'

var StatisticData () {
    this.total = 0
    this.token = 0
    this.parityError = 0
    this.insufficentData = 0
    this.notForMe = 0
}

var statistic = new StatisticData()

const NOTHING_RECEIVED = 0
const PARTIALLY_RECEIVED = 1
const COMLETELY_RECEIVED = 2

/**
 * Class to store a data packages from a network communication
 */
class RS485Message {
    constructor () {
        this._state = NOTHING_RECEIVED
        this._broadCase = 0
        this._sender = 0
        this._receiver = 0
        this._reply = 0
        this._key = 0
        this._value = 0
        this._parity = 0
        this._crc16 = 0
        this._error = ''
        this._JSONString = ''
        this._timestamp = 0
    }

    /**
     * Checks, if the message has been received completely
     * @returns {boolean} true
     */
    isComplete () {
        return this._state === COMLETELY_RECEIVED
    }

    /**
     * Sets the address (sender/receiver) information of the message
     * @param {*} sender 
     * @param {*} target 
     * @param {*} sendResponse 
     */
    setAddresses (sender, target, sendResponse) {
        this._sender = sender
        this._target = target
        this._sendResponse = sendResponse
    }

    /**
     * Sets the command and the value of the message
     * @param {char} command command of the message
     * @param {number} value value of the message
     */
    setCommand (command, value) {
        this._key = command
        this._value = value
    }

    /**
     * Sets the value of the package from a high and a low order byte
     * @param {byte} valueHigh
     * @param {byte} valueLow
     * @returns {undefined}
     */
    setValue (valueHigh, valueLow) {
        this.valueHigh = valueHigh
        this.valueLow = valueLow

        if (this._key === 'h' || this._key === 't' || this._key === 's') {
            this._value = valueHigh + (valueLow / 100)
        } else {
            this._value = valueHigh * 256 + valueLow
        }
    }



    /**
     * Searches for a byte in a stream
     * @param {Array} stream stream of input data
     * @param {integer} startIndex first element to concider
     * @param {integer} searchFor element to search for
     * @returns {integer} index of the first occurence or "undefined" if not found
     */
    searchByteStream (stream, startIndex, searchFor) {
        var found
        if (startIndex !== undefined) {
            for (var curIndex = startIndex; stream.length > curIndex; curIndex++) {
                if (stream[curIndex] === searchFor) {
                    found = curIndex
                    break
                }
            }
        }
        return found
    }

    /**
     * Searches the first element of a message
     * @param {Array} stream stram of input data
     */
    searchFirstMessageElement (stream) {
        var firstElement
        if (this._state === NOTHING_RECEIVED) {
            firstElement = this.searchByteStream(stream, 0, '{'.charCodeAt(0))
            this._state = PARTIALLY_RECEIVED
        } else if (this._state === PARTIALLY_RECEIVED) {
            firstElement = 0
        }
        return firstElement
    }

    /**
     * Searches the last element of a message
     * @param {Array} stream stram of input data
     */
    searchLastMessageElement (stream, startIndex) {
        var lastElement
        if (startIndex !== undefined) {
            lastElement = this.searchByteStream(stream, startIndex, '}'.charCodeAt(0))
            if (lastElement !== undefined) {
                this._state = COMLETELY_RECEIVED
            } else {
                lastElement = stream.length - 1
            }
        }
        return lastElement
    }

    /**
     * Sets the message from an json object received from serial
     * @param object Object containing a serial representation of the message
     */
    setFromObject (object) {
        this._sender = object.S
        this._receiver = object.R
        this._reply = object.A
        this._key = object.K
        this._value = object.V
        this.crc16 = parseInt(object.C)
        this._timestamp = new Date().toISOString()
    }

    /**
     * Sets the package content from a stream formatted as JSON
     * @param {Array} stream stram of input data
     * @returns {undefined}
     * @throws {string} error text
     */
    setFromStreamJSON (stream) {
        var firstElement = this.searchFirstMessageElement(stream)
        var lastElement = this.searchLastMessageElement(stream, firstElement)

        for (var curElement = firstElement; curElement <= lastElement; curElement++) {
            this._JSONString += String.fromCharCode(stream[curElement])
        }

        if (this._state === COMLETELY_RECEIVED) {
            var object = JSON.parse(this._JSONString)
            this.setFromObject(object)
        }
    }
}

module.exports = RS485Message
