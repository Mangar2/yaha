/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * Provides a standard client to communicate with the mqtt broker
 */

'use strict'

const SerialMessage = require('./serialmessage')
const RS485State = require('./rs485state')
const {
    STATE_UNCHANGED,
    ENABLE_SEND,
    REGISTRATION_INFO,
    REGISTRATION_REQUEST,
    STATE_CHANGED,
    NEIGHBOUR_UNKNOWN,
    BROADCAST_ADDRESS
} = require('./constants')

const TOKEN = '!'

/**
 * Creates a new token handler for RS485 based serial connections to arduinos
 * @param {integer} [myAddress = 1] address of this device
 */
class RS458Schedule {
    constructor (myAddress = 1) {
        this._myAddress = myAddress
        this._state = new RS485State()
    }

    /**
     * Logs the current state to the console
     */
    logState () {
        console.log(this.getStateInfo())
    }

    /**
     * Gets a state info
     * @returns {string}
     */
    getStateInfo () {
        const result =
            'State: ' + this._state.getStateString() +
            ' Leftmost: ' + this._state.leftmostCeibling +
            ' Neighbour: ' + this._state.neighbour
        return result
    }

    /**
     * Checks, if a message is addressed to myself
     * @param {SerialMessage} message serial message to check
     * @returns {boolean}
     * @private
     */
    _isForMe (message) {
        return message.receiver === BROADCAST_ADDRESS || message.receiver === this._myAddress
    }

    /**
     * Gets the address of the next receiver in the node chain
     * @returns {number} address of the next receiver
     * @private
     */
    _getReceiverAddress () {
        if (this._state.neighbour === NEIGHBOUR_UNKNOWN) {
            if (this._state.leftmostCeibling === NEIGHBOUR_UNKNOWN) {
                return BROADCAST_ADDRESS
            }
            return this._state.leftmostCeibling
        } else {
            return this._state.neighbour
        }
    }

    /**
     * Creates a message signaling a state
     * @param {number} stateUpdateResult value of the state to signal
     * @returns {SerialMessage|undefined} a state signaling message fitting to the result to the state update
     * @private
     */
    _createStateSignalingMessage (stateUpdateResult) {
        let message
        if (stateUpdateResult === REGISTRATION_INFO || stateUpdateResult === REGISTRATION_REQUEST || stateUpdateResult === ENABLE_SEND) {
            message = new SerialMessage()
            message.command = TOKEN
            message.value = stateUpdateResult
            message.sender = this._myAddress
            message.receiver = BROADCAST_ADDRESS
            message.reply = false
            if (stateUpdateResult === ENABLE_SEND) {
                message.receiver = this._getReceiverAddress()
            }
        }
        return message
    }

    /**
     * Update the sender address chain, if the senderAddress is closer than current rightmost and leftmost ceibling
     * @param {integer} senderAddress address of the sender of the last message
     * @private
     */
    _updateSenderAddressChain (senderAddress) {
        var rightCeibling = (this.myAddress < senderAddress) && (this.neighbour > senderAddress)
        if (this.chain[this.chain.length - 1].address < senderAddress) {
            this.chain.push({ address: senderAddress })
        } else {
            for (var pos = 0; pos < this.chain.length; pos++) {
                if (this.chain[pos].address === senderAddress) {
                    break
                }
                if (this.chain[pos].address > senderAddress) {
                    this.chain.splice(pos, 0, { address: senderAddress })
                    break
                }
            }
        }
        if (rightCeibling) {
            this.neighbour = senderAddress
        }
        this.leftmostCeibling = Math.min(this.leftmostCeibling, senderAddress)
    }

    /**
     * Handles a new state message and adapts the status
     * @param {SerialMessage} message a message received from an RS485 communication
     * @returns {SerialMessage|unknown} a state signaling message for the token communcation
     * @private
     */
    _processIncomingStateMessage (message) {
        var stateSignalingMessage
        if (message.command === TOKEN) {
            const isForMe = this._isForMe(message)
            this._updateSenderAddressChain(message.sender)
            const stateValue = this._state.updateState(message.value, !isForMe)
            stateSignalingMessage = this.createStateSignalingMessage(stateValue)
            if (stateSignalingMessage !== undefined) {
                stateSignalingMessage.version = message.version
                stateSignalingMessage.length = message.length
            }
        }
        return stateSignalingMessage
    }
}

module.exports = RS458Schedule
