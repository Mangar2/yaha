/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * Provides a standard client to communicate with the mqtt broker
 */

'use strict'

const { Callbacks, errorLog } = require('@mangar2/utils')
const RS485TokenExchange = require('./rs485tokenexchange')
const SendQueue = require('./sendqueue')

/**
 * Creates a new token handler for RS485 based serial connections to arduinos
 * @param {Object} options configuration options
 * @param {integer} options.myAddress address of this device
 * @param {integer} options.maxVersion maximal suported interface version
 */
class RS485Schedule {
    constructor (options) {
        this._tokenExchange = new RS485TokenExchange(options)
        this._callbacks = new Callbacks(['send'])
        this._sendQueue = new SendQueue()
        this._send = 0
        this._sendRetryCount = 0
        this._received = 0
    }

    /**
     * Sends a message to a serial port
     * @param {SerialMessage} message message to send
     * @returns true, if sending was successful
     */
    async _sendMessage (message) {
        let result = true
        try {
            const byteArray = message.getByteArray()
            await this._callbacks.invokeCallbackAsync('send', byteArray)
            console.log(message.getLoggingInfo())
            this._tokenExchange.enableChangeVersion(message)
            this.send++
        } catch (err) {
            errorLog(err)
            result = false
        }
        return result
    }

    /**
     * Sends a message from queue and removes it, if no reply expected
     * @returns undefined
     */
    async sendMessageFromQueue () {
        const message = this._sendQueue.getMessage(0)
        if (message === null) {
            return
        }
        const isMessageSend = this._sendMessage(message)
        if (isMessageSend) {
            this._sendRetryCount++
            if (this._sendRetryCount > 10 || message.reply === 0) {
                this._sendQueue.dequeue()
                this._sendRetryCount = 0
            }
        }
    }

    /**
     * Sets a callback.
     * @param {string} event event name (not case sensitive) for the callback (supported: 'send')
     * @param {function} callback function(...parameter)
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on (event, callback) {
        this._callbacks.on(event, callback)
    }

    /**
     * Handler called each tick to check if any message must or may be sent
     * @returns true, if any message has been sent.
     */
    async processTick () {
        const message = this._tokenExchange.processStateNoMessage()
        if (message) {
            await this._sendMessage(message)
        }

        if (this._tokenExchange.maySend) {
            this.sendMessageFromQueue()

            // Prevent to send a message twice in the same tick.
            this._tokenExchange.maySend = false
        }
    };
}

module.exports = RS485Schedule
