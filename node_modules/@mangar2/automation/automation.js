/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'
const DEBUG = false

const types = require('@mangar2/types')
const Rules = require('@mangar2/rules')
const ProcessRule = require('./processrule')
const errorLog = (err) => { require('@mangar2/errorlog')(err, DEBUG) }

/**
 * Creates a home automation class
 * @param {Object} configuration automation configuration
 * @param {number} configuration.longitued longitude of the place to automate
 * @param {number} configuration.latitude latitude of the place to automate
 * @param {Object} rules rule configuration
 */
class Automation {
    constructor (configuration, rules) {
        if (!types.isNumber(configuration.longitude)) {
            throw Error('automation configuration does not include a parameter "longitude" of type number')
        }
        if (!types.isNumber(configuration.latitude)) {
            throw Error('automation configuration does not include a parameter "latitude" of type number')
        }
        this.rules = new Rules(rules)
        this._processRule = new ProcessRule({}, configuration.longitude, configuration.latitude)
        this._history = {}
    }

    /**
     * Gets the list of rules
     * @returns {Object[]} list of rules
     */
    get rules () { return this._rules }

    /**
     * Sets the list of rules
     * @param {Object[]} rules list of rules to process for automation
     */
    set rules (rules) { this._rules = rules }

    /**
     * Sets all variables
     * @param {Object} variables key/value object containing a list of variables
     */
    set variables (variables) {
        this._processRule.variables = variables
    }

    /**
     * Sets a single variable (for example from a message)
     * @param {string} name name of the variable
     * @param {string|number} value value of the variable
     */
    setVariable (name, value) { this._processRule.setVariable(name, value) }

    /**
     * Sets the value of a variable by message
     * @param {Message} message message received
     */
    setVariableByMessage (message) {
        this.setVariable(message.topic, message.value)
    }

    /**
     * Checks all rules for errors
     * @returns {Object} map of variables (variable name/variable value)
     */
    checkRules () {
        let result = {}
        if (this._rules.rules.length === 0) {
            errorLog('no rules specified')
        }
        for (const errors of this._rules.invalidRules) {
            console.log('Error in rule "' + errors.name + '": ' + JSON.stringify(errors.messages, null, 2))
        }
        for (const rule of this._rules.rules) {
            console.log('Checking rule ' + rule.name)
            try {
                const usedVariables = this._processRule.neededVariables(rule)
                result = { ...result, ...usedVariables }
            } catch (err) {
                this._rules.invalidateRule(rule.name)
                err.message = 'Error in rule "' + rule.name + '": ' + err.message
                errorLog(err)
            }
        }
        return result
    }

    /**
     * Get all the variables to subscribe to
     * @returns {string[]} array of subscriptions
     */
    getSubscriptions () {
        const variables = this.checkRules()
        const subscriptions = {}
        for (const variable in variables) {
            if (variables[variable] === undefined) {
                subscriptions[variable] = 1
            }
        }
        return subscriptions
    }

    /**
     * @private
     * Checks if a rule is active either because it changes the value or because it needs to
     * resend the value
     * @param {Object} rule rule to check
     * @param {string} rule.name rule name
     * @param {number} rule.cooldownInSeconds time between two updates with the same value
     * @param {Date} date current date/time
     * @param {string|number} value new value for rule
     * @returns {boolean} true, if the rule is active
     */
    _isRuleActive (rule, date, value) {
        const name = rule.name
        const MILLISECONDS_IN_A_SECOND = 1000
        let result = (this._history[name] === undefined || this._history[name].value !== value)
        if (!result && types.isNumber(rule.cooldownInSeconds)) {
            const cooldown = rule.cooldownInSeconds * MILLISECONDS_IN_A_SECOND
            const needToResend = this._history[name].date.getTime() + cooldown <= date.getTime()
            result = needToResend
        }
        return result
    }

    /**
     * Updates the history entry for a rule
     * @param {string} name name of the rule
     * @param {Date} date current date/time
     * @param {Message} message current message
     */
    _updateHistory (name, date, value) {
        this._history[name] = { date: new Date(date.getTime()), value }
    }

    /**
     * Loops through all rules and processes them
     * @param {Date} [date] current date/time
     * @returns {Message[]} list of messages to process
     */
    processRules (date) {
        const result = { messages: [], usedVariables: {} }
        if (types.getType(date) === 'Date') {
            this._processRule.date = date
        } else {
            this._processRule.date = new Date()
        }
        for (const rule of this._rules.rules) {
            try {
                const checkResult = this._processRule.check(rule)
                const messages = checkResult.messages
                if (types.isArray(messages) && (messages.length > 0) && types.isObject(messages[0])) {
                    const message = messages[0]
                    if (this._isRuleActive(rule, this._processRule.date, message.value)) {
                        this._updateHistory(rule.name, this._processRule.date, message.value)
                        result.messages = [...result.messages, ...messages]
                    }
                }
                result.usedVariables = { ...result.usedVariables, ...checkResult.usedVariables }
            } catch (err) {
                this._rules.invalidateRule(rule.name)
                err.message = 'Error in rule "' + rule.name + '": ' + err.message
                errorLog(err)
            }
        }
        return result
    }
}

module.exports = Automation
