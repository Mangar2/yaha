/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const types = require('@mangar2/types')
const ProcessRule = require('./processrule')

/**
 * Creates a home automation class
 * @param {Object} configuration automation configuration
 * @param {number} configuration.longitued longitude of the place to automate
 * @param {number} configuration.latitude latitude of the place to automate
 * @param {Rules} rules rule configuration
 */
class Automation {
    constructor (configuration, rules) {
        if (!types.isNumber(configuration.longitude)) {
            throw Error('automation configuration does not include a parameter "longitude" of type number')
        }
        if (!types.isNumber(configuration.latitude)) {
            throw Error('automation configuration does not include a parameter "latitude" of type number')
        }
        this.rules = rules
        this._processRule = new ProcessRule({}, configuration.longitude, configuration.latitude)
        this._history = {}
    }

    /**
     * Sets the list of rules
     * @param {Object[]} rules list of rules to process for automation
     */
    set rules (rules) { this._rules = rules }

    /**
     * Sets all variables
     * @param {Object} variables key/value object containing a list of variables
     */
    set variables (variables) {
        this._processRule.variables = variables
    }

    /**
     * Sets a single variable (for example from a message)
     * @param {string} name name of the variable
     * @param {string|number} value value of the variable
     */
    setVariable (name, value) { this._processRules.setVariable(name, value) }

    /**
     * Sets the value of a variable by message
     * @param {Message} message message received
     */
    setVariableByMessage (message) {
        this.setVariable(message.topic, message.value)
    }

    checkRules () {
        let result = {}
        for (const rule of this._rules.rules) {
            const usedVariables = this._processRule.neededVariables(rule)
            result = { ...result, ...usedVariables }
        }
        return result
    }

    /**
     * @private
     * Checks if a rule changes the last value and remembers the new value of the rule
     * @param {string} name rule name
     * @param {string|number} value new value for rule
     */
    _isValueChanged (name, value) {
        const result = (this._history[name] === undefined || this._history[name] !== value)
        return result
    }

    /**
     * Loops through all rules and processes them
     * @param {Date} [date] current date/time
     * @returns {Message[]} list of messages to process
     */
    processRules (date) {
        const result = { messages: [], usedVariables: {} }
        if (types.getType(date) === 'Date') {
            this._processRule.date = date
        }
        for (const rule of this._rules.rules) {
            const checkResult = this._processRule.check(rule)
            const messages = checkResult.messages
            if (types.isArray(messages) && (messages.length > 0) && types.isObject(messages[0])) {
                const message = messages[0]
                if (this._isValueChanged(rule.name, message.value)) {
                    this._history[rule.name] = message.value
                    result.messages = [...result.messages, ...messages]
                }
            }
            result.usedVariables = { ...result.usedVariables, ...checkResult.usedVariables }
        }
        return result
    }
}

module.exports = Automation
