/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const types = require('@mangar2/types')
const Decision = require('@mangar2/decision')
const Message = require('@mangar2/message')
const { sunrise, sunset } = require('@mangar2/sun')
const { stringToSeconds } = require('./timeHelper')

/**
 * Processes rules based on a set of variables
 * @param {Object} variables key/value map where key is the variable name (usually a topic string)
 * @param {number} longitude geographical longitued poistion of the automation target in degrees
 * @param {number} latitude geographical latitued poistion of the automation target in degrees
 * @param {Date} [date=now] current date
 */
class ProcessRule {
    constructor (variables, longitude, latitude, date = new Date()) {
        this.date = date
        this._longitude = longitude
        this._latitude = latitude
        this.variables = variables
        this._usedVariables = {}
    }

    /**
     * Sets all variables
     * @param {Object} variables key/value object containing a list of variables
     */
    set variables (variables) {
        this._variables = variables
        this._updateVariables = true
    }

    /**
     * Sets a single variable
     * @param {string} name name of the variable to set
     * @param {*} value value of the variable to set
     */
    setVariable (name, value) {
        this._variables[name] = value
    }

    /**
     * Sets the current date/time
     * @param {Date} date current date
     */
    set date (date) {
        this._date = date
        this._updateVariables = true
    }

    /**
     * @private
     * Sets the calculated sun variables (sunrise/sunset/dusk/dawn)
     */
    _setDefaultVariables () {
        this._variables.time = this._date
        this._variables.sunrise = sunrise(this._longitude, this._latitude, this._date)
        this._variables.civildawn = sunrise(this._longitude, this._latitude, this._date, 96)
        this._variables.nauticaldawn = sunrise(this._longitude, this._latitude, this._date, 102)
        this._variables.astronomicaldawn = sunrise(this._longitude, this._latitude, this._date, 108)
        this._variables.sunset = sunset(this._longitude, this._latitude, this._date)
        this._variables.civiltdusk = sunset(this._longitude, this._latitude, this._date, 96)
        this._variables.nauticaldusk = sunset(this._longitude, this._latitude, this._date, 102)
        this._variables.astronomicaldusk = sunset(this._longitude, this._latitude, this._date, 108)
    }

    /**
     * @private
     * Gets a property from a rule, either directly or using the map provided by the rule
     * @param {Object|string|number} property rule property
     * @param {string|number} defaultValue value to return, if the property is not defined
     * @throws {Error} If the property includes a referenct to a variable that is not defined
     * @returns {string|number|undefined} property value
     */
    _getPropertyValue (property, defaultValue) {
        let value
        if (types.isObject(property)) {
            const variable = property.variable
            if (types.isString(variable)) {
                value = this._variables[variable]
                this._usedVariables[variable] = value
                if (value !== undefined && types.isObject(property.map)) {
                    value = property.map[value]
                }
            }
        } else {
            value = property
        }
        if (value === undefined || value === null) {
            value = defaultValue
        }
        return value
    }

    /**
     * @private
     * Checks, if the rule has a time constrains. The rule is valid if
     * it has a time constrains defining a time span and the current time is in the time span or it
     * has no time constrains
     * @param {Object} rule rule to check
     * @param {string} [rule.time] time of day to activate the time
     * @param {string} [rule.duration='6:00'] duration of the rule
     * @returns {boolean} true, if the rule is currently valid based on the time of day stored
     */
    _checkTime (rule) {
        let result = rule.time === undefined
        const timeString = this._getPropertyValue(rule.time)
        if (timeString !== undefined) {
            const durationString = this._getPropertyValue(rule.duration, '6:00')
            const timeInSeconds = stringToSeconds(timeString)
            const durationInSeconds = stringToSeconds(durationString)
            const timeOfDayInSeconds = (this._date.getHours() * 60 + this._date.getMinutes()) * 60 + this._date.getSeconds()
            result = timeOfDayInSeconds >= timeInSeconds && timeOfDayInSeconds < durationInSeconds + timeInSeconds
        }

        return result
    }

    /**
     * @private
     * Evaluates the rule 'check' constrains.
     * @param {Object} rule rule to check
     * @param {string} [rule.check] check function in JSON format
     * @returns {boolean} true, if rule has no 'check' property or the 'check' property evaluates to true
     */
    _checkDecision (rule) {
        const decision = rule.check === undefined
        const reason = ''
        let result = { decision, reason }
        try {
            if (types.isObject(rule.check)) {
                const decisionMaker = new Decision(this._variables)
                result = decisionMaker.decide(rule.check)
                this._usedVariables = { ...this._usedVariables, ...result.variables }
            }
        } catch (err) {
            result.reason = types.getType(err) === 'Error' ? err.message : err
        }
        return result
    }

    /**
     * Gets a list of needed variables for the rule
     * @param {Object} rule rule to check
     */
    neededVariables (rule) {
        this._checkTime(rule)
        this._checkDecision(rule)
        this._getPropertyValue(rule.value)
        return this._usedVariables
    }

    /**
     * Processes a rule and if the rule demands, create a message
     * @param {Object} rule rule to check
     * @returns {{messages: Message[], usedVariables}} Array of messages and object of variables used.
     */
    check (rule) {
        const result = { usedVariables: {}, messages: [] }

        if (this._updateVariables) {
            this._setDefaultVariables()
        }

        if (this._checkTime(rule)) {
            const decisionResult = this._checkDecision(rule)
            if (decisionResult.decision) {
                const { topic, name } = rule
                const value = this._getPropertyValue(rule.value)
                let reason = 'Rule: ' + name
                if (decisionResult.reason !== '') {
                    reason += ', ' + decisionResult.reason
                }
                if (types.isArray(topic)) {
                    for (const oneTopic of topic) {
                        result.messages.push(new Message(oneTopic, value, reason, this._date))
                    }
                } else {
                    result.messages.push(new Message(topic, value, reason, this._date))
                }
            }
        }
        result.usedVariables = this._usedVariables
        return result
    }
}

module.exports = ProcessRule
