/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const types = require('@mangar2/types')

const CheckInput = require('@mangar2/checkinput')
const checkRule = new CheckInput({
    type: 'object',
    properties: {
        topic: {
            anyOf: [
                { type: 'string' },
                {
                    type: 'array',
                    items: { type: 'string' }
                }
            ]
        },
        value: {
            anyOf: [
                { type: 'string' },
                { type: 'number' },
                {
                    type: 'object',
                    properties: {
                        variable: { type: 'string' },
                        map: { type: 'object' }
                    },
                    required: ['variable']
                }
            ]
        },
        time: {
            anyOf: [
                { type: 'string' },
                {
                    type: 'object',
                    properties: {
                        variable: { type: 'string' },
                        map: { type: 'object' }
                    },
                    required: ['variable']
                }
            ]
        },
        check: {
            type: 'object'
        }
    },
    required: ['topic', 'value']

})

/**
 * Creates an object holding automation rules
 * @param {Object} rulesTree rules tree
 */
class Rules {
    constructor (rulesTree) {
        this._rules = []
        this._invalidRules = []
        this._parseRules(rulesTree)
    }

    /**
     * Get the valid rules list
     * @returns {Object[]} array of rules
     */
    get rules () { return this._rules }

    /**
     * Get the invalid rules list
     * @returns {Object[]} array of invalid rules als { ruleName, errorMessages }
     */
    get invalidRules () { return this._invalidRules }

    /**
     * Parses a tree of rules and puts every rule in an array
     * @param {Object} node node in the rule tree
     * @param {string} link path to current node in the rule tree
     */
    _parseRules (node, link = '') {
        if (types.isObject(node)) {
            for (const key in node) {
                if (key === 'rules') {
                    for (const ruleIndex in node[key]) {
                        const rule = node[key][ruleIndex]
                        const isValid = checkRule.validate(rule)
                        rule.name = link === '' ? ruleIndex : link + '/' + ruleIndex
                        if (isValid) {
                            this.rules.push(rule)
                        } else {
                            this.invalidRules.push({ name: rule.name, messages: checkRule.messages })
                        }
                    }
                } else {
                    const childNode = node[key]
                    const childLink = link + '/' + key
                    this._parseRules(childNode, childLink)
                }
            }
        }
    }
}

module.exports = Rules
