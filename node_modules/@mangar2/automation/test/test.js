/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const VERBOSE = false

const testMotionHistory = require('./testMotionHistory')
const Message = require('@mangar2/message')
const Automation = require('@mangar2/automation')
const { timeOfDayStringToDate } = require('@mangar2/time')
const Testrun = require('@mangar2/testrun')
const testrun = new Testrun(VERBOSE)

/**
 * Adds motions to the automation class
 * @param {Automation} automation automation class
 * @param {Object} motionList list of motions, format topic:timeOfDayString
 */
function setMotions (automation, motionList) {
    for (const motionTopic in motionList) {
        const motionTime = timeOfDayStringToDate(motionList[motionTopic])
        automation.processMessage(new Message(motionTopic, 1, 'test motion', motionTime))
    }
}

/**
 * Sends messages to the automation class to set variables
 * @param {Automation} automation automation class
 * @param {Object} variableList list of variable: value elements to set variables
 */
function sendMessages (automation, variableList) {
    if (variableList !== undefined) {
        for (const variable in variableList) {
            automation.processMessage(new Message(variable, variableList[variable], 'test'))
        }
    }
}

testMotionHistory(testrun.unitTest)

testrun.on('prepare', testcase => {
    const automation = new Automation(
        { motionTopics: ['+/+/motion', '$SYS/+/set'], subscribeQoS: 2, longitude: 8.247253, latitude: 49.992862 })
    automation.setRules(testcase.rule)
    const subscriptions = automation.getSubscriptions()
    testrun.unitTest.assertDeepEqual(subscriptions, testcase.subscriptions,
        'found: ' + JSON.stringify(subscriptions, null, 2) + '\n' +
        'expected: ' + JSON.stringify(testcase.subscriptions, null, 2))
    return automation
})

const runTest = (test, automation) => {
    const testTime = timeOfDayStringToDate(test.time)
    sendMessages(automation, test.variables)
    setMotions(automation, test.motions)
    return automation.processRules(testTime)
}

testrun.on('run', runTest)

testrun.on('break', (test, automation) => {
    runTest(test, automation)
})

testrun.on('validate', (test, result, path) => {
    testrun.unitTest.assertEqual(result.messages.length, test.results.length, path)
    if (result.messages.length !== test.results.length) {
        testrun.runAgain()
    }
    for (const index in test.results) {
        const expected = test.results[index]
        const message = result.messages[index]
        if (message !== undefined) {
            testrun.unitTest.assertEqual(expected.topic, message.topic, 'topic ' + path)
            testrun.unitTest.assertEqual(expected.value, message.value, 'value ' + path)
            if (expected.QoS !== undefined) {
                testrun.unitTest.assertEqual(expected.QoS, message.QoS, 'qos ' + path)
            }
        }
    }
})

testrun.run(['leaving', 'duration'], __dirname)

testrun.unitTest.showResult(36)
