/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const shutdown = require('@mangar2/shutdown')
const Server = require('@mangar2/httpservice').HttpServer
const Client = require('@mangar2/httpservice').HttpClient
const Connect = require('@mangar2/connect')
const MqttInterface = require('@mangar2/mqtt')

/**
 * @private
 * Gets the interface (first section of the path)
 * @param {string} path http path
 * @returns {string} first section of the path
 */
function getInterface (path) {
    const pathArray = path.split('/').splice(1)
    const calledInterface = pathArray[0]
    return calledInterface
}

/**
 * @private
 * Gets the client id of the path (the second section of the path)
 * @param {string} path http path
 * @returns {string} client id of the path (second part)
 */
function getClientId (path) {
    const pathArray = path.split('/').splice(2)
    const clientId = pathArray.join('/')
    return clientId
}

/**
 * @private
 * Pauses the execution for a while (needs to "wait") for the result.
 * @param {number} timeInMilliseconds delay in milliseconds
 * @returns {Promise} promise to wait for
 */
function delay (timeInMilliseconds) {
    return new Promise(resolve => setTimeout(resolve, timeInMilliseconds))
}

/**
 * Creates a new broker
 * @param {Object} options options (configuration) of the broker
 * @param {number|string} options.port port number the broker will listen on
 * @param {Object} options.connections connection settings for the broker
 * @param {string} options.connections.fileName filename for persistence
 * @param {string} options.connections.directory directory (file path) for persistence
 * @param {number} options.connections.replyTimeoutInMilliseconds timeout to wait for an answer
 * of a http call
 * @param {number} [options.connections.inFlightWindow=1] amount of qos 1 and qos 2 messages
 * send for the same topic at the same time
 * @param {number} [options.connections.pubrelTimeoutInMilliseconds=one day] temeout to wait for a
 * corresponding pubrel message
 * @param {number} options.connections.maxRetryCount amount of resend of messages
 * before forcing a disconnect
 * @param {number} options.connections.maxQueuSize maximal amount of entries in a message queue
 * @param {Object} options.connections.log log settings
 * @example
 * const options = {
 *      port: 10000,
 *      persistInterval: 0,
 *       connections: {
 *           inFlightWindow: 1,
 *           timeoutInMilliseconds: 10000,
 *           maxRetryCount: 10,
 *           maxQueueSize: 1000,
 *           directory: '.',
 *            fileName: 'broker',
 *            log: [
 *               {
 *                   module: 'received',
 *                   topic: '#'
 *               }
 *           ]
 *       }
 *   }
 * const broker = new Broker(options)
 * broker.run()
 */
class Broker {
    constructor (options) {
        this.options = options
        this.running = false
        this.options.persistInterval = !isNaN(this.options.persistInterval) ? this.options.persistInterval : 30 * 1000

        this.server = new Server(this.options.port)
        this.mqtt = new MqttInterface(this.options.connections)
        this.mqtt.restoreFromFile()
        this.changed = false

        this.server.on('put', (payload, headers, path, res) => {
            this.changed = true
            const command = getInterface(path)
            const receivedPayload = JSON.parse(payload)
            const result = this.mqtt.processRequest(command, receivedPayload, headers)
            res.writeHead(result.statusCode, result.headers)
            res.end(result.payload)
        })

        this.server.on('get', (payload, headers, path, res) => {
            const command = getInterface(path)
            if (command === 'clients') {
                const clientId = getClientId(path)
                const result = this.mqtt.getConnections(clientId)
                const resultPayload = JSON.stringify(result.payload)
                res.writeHead(result.statusCode, result.headers)
                res.end(resultPayload)
            } else {
                throw Error('unknown path ' + path)
            }
        })

        this.mqtt.on('send', async (host, port, path, payload, headers) => {
            const client = new Client(host, port)
            const result = await client.send('/' + path, 'PUT', payload, headers)
            return result
        })

        shutdown(async () => {
            await this.close()
            process.exit(0)
        })
    }

    /**
     * Connects to a friendly broker and subscribs for all messages
     * @param {string} host name of the host (or his ip)
     * @param {number} port port number to connect to
     */
    connect (host, port) {
        this.connect = new Connect('broker/new', host, port, this.options.port)
        this.connect.connectAndSubscribe(false, { '#': 1 }, '0.0')
    }

    /**
     * Sets a callback.
     * @param {string} event callback name (supports 'send' and 'publish')
     * 'send' is called to send data. This function is provided by the broker but could be overwritten
     * 'publish' is called on receiving data. This function if provided by the broker but could be overwritten
     * @param {function} callback
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on (event, callback) { this.mqtt.on(event, callback) }

    /**
     * Starts the broker. It will listen to message, send messages and periodically store its status
     */
    run () {
        this.running = true
        this.server.listen()
        if (this.options.persistInterval !== 0) {
            this._persistBroker()
        }
        this._processMessages()
    }

    /**
     * Closes the broker, stops listening
     */
    async close () {
        this.running = false
        await this.server.close()
        if (this.options.persistInterval !== 0) {
            await this.mqtt.connections.persist()
        }
    }

    /**
     * @private
     * Send all messages that are "ready to send"
     */
    async _processMessages () {
        while (this.running) {
            let messagesSent = 0
            messagesSent = await this.mqtt.processSendMessage()
            await delay(messagesSent > 0 ? 5 : 50)
        }
    }

    /**
     * @private
     * Stores the broker connection data to file
     */
    async _persistBroker () {
        while (this.running) {
            if (this.changed) {
                this.changed = false
                await this.mqtt.connections.persist()
            }
            await delay(this.options.persistInterval)
        }
    }
}

module.exports = Broker
