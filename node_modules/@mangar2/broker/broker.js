/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      broker.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * Version:     1.0
 * ---------------------------------------------------------------------------------------------------
 */

'use strict';

const shutdown = require("@mangar2/shutdown");
const Server = require('@mangar2/httpserver');
const Client = require('@mangar2/httpclient');
const MqttInterface = require('@mangar2/mqtt');

function getInterface(path) {
    let pathArray = path.split("/").splice(1);
    let calledInterface = pathArray[0];
    return calledInterface;
}

function getClientId(path) {
    let pathArray = path.split("/").splice(2);
    let clientId = pathArray.join("/");
    return clientId;
}

/**
 * Pauses the execution for a while (needs to "wait") for the result.
 * @param {number} timeInMilliseconds delay in milliseconds
 */
function delay(timeInMilliseconds) {
    return new Promise(resolve => setTimeout(resolve, timeInMilliseconds));
}


module.exports = class Broker {

    constructor(config) {
        this.config = require('@mangar2/config')(config);
        this.running = false;
        this.config.broker.persistInterval = !isNaN(this.config.broker.persistInterval) ? this.config.broker.persistInterval : 30 * 1000;
        
        this.server = new Server(this.config.broker.port);
        this.mqtt = new MqttInterface(this.config.connections);
        this.changed = false;

        this.server.on("put", (payload, headers, path, res) => {
            this.changed = true;
            let command = getInterface(path);
            let receivedPayload = JSON.parse(payload);
            let result = this.mqtt.processRequest(command, receivedPayload, headers);
            res.writeHead(result.statusCode, result.headers);
            res.end(result.payload);
        });
    
        this.server.on("get", (payload, headers, path, res) => {
            let command = getInterface(path);
            if (command === "clients") {
                let clientId = getClientId(path);
                let result = this.mqtt.getConnections(clientId);
                let resultPayload = JSON.stringify(result.payload);
                res.writeHead(result.statusCode, result.headers);
                res.end(resultPayload);
            } else {
                throw Error("unknown path " + path);
            }
    
        })

        shutdown(async () => {
            await this.close();
            process.exit(0);
        });
    }

    /**
     * Starts the broker. It will listen to message, send messages and periodically store its status
     */
    run() {
        this.running = true;
        this.server.listen();
        if (this.config.broker.persistInterval !== 0) {
            this._persistBroker();
        }
        this._processMessages();
    }

    /**
     * Closes the broker, stops listening
     */
    async close() {
        this.running = false;
        await this.server.close();
        if (this.config.broker.persistInterval !== 0) {
            await this.mqtt.connections.persist();
        }
    }


    async _processMessages() {
        while (this.running) {
            let messagesSent = 0;
            messagesSent = this.mqtt.processSendMessage(async (host, port, path, payload, headers) => {
                let client = new Client(host, port);
                let result = await client.send("/" + path, "PUT", payload, headers);
                return result;
            })
            await delay(messagesSent > 0 ? 10 : 100);
        }
    }

    async _persistBroker() {
        while (this.running) {
            if (this.changed) {
                this.changed = false;
                await this.mqtt.connections.persist();
            }
            await delay(this.config.broker.persistInterval);
        }
    }


}


