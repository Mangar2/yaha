/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      broker.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * Version:     1.0
 * ---------------------------------------------------------------------------------------------------
 */

'use strict';

const shutdown = require("@mangar2/shutdown");
const Server = require('@mangar2/httpserver');
const Client = require('@mangar2/httpclient');
const MqttInterface = require('@mangar2/mqtt');
const config = require('@mangar2/config')(require(("./config.json")));

var server = new Server(config.broker.port);
var mqtt = new MqttInterface(config.connections);
var changed = false;

function processMessages() {
    let messagesSent = 0;
    messagesSent = mqtt.processSendMessage(async (host, port, message, headers) => {
        let client = new Client(host, port);
        let result = await client.send("/publish", "PUT", message, headers);
        return parseInt(result.headers.packetid);
    })
    setTimeout(processMessages, messagesSent > 0 ? 5 : 100);
}

function persistBroker() {
    let persistInterval = isNaN(config.broker.persistInterval) ? config.broker.persistInterval : 30 * 1000;
    if (changed) {
        changed = false;
        mqtt.connections.persist();
    }
    setTimeout(persistBroker, persistInterval);
}

function getInterface(path) {
    let pathArray = path.split("/").splice(1);
    let calledInterface = pathArray[0];
    return calledInterface;
}

function getClientId(path) {
    let pathArray = path.split("/").splice(2);
    let clientId = "/" + pathArray.join("/");
    return clientId;
}

server.on("put", (payload, headers, path, res) => {
    changed = true;
    let command = getInterface(path);
    let receivedPayload = JSON.parse(payload);
    let result = mqtt.processRequest(command, receivedPayload, headers);
    let resultPayload = JSON.stringify(result.payload);
    res.writeHead(result.httpcode, result.headers);
    res.end(resultPayload);
});

server.on("get", (payload, headers, path, res) => {
    let command = getInterface(path);
    if (command === "clients") {
        let clientId = getClientId(path);
        let result = mqtt.getConnections(clientId);
        let resultPayload = JSON.stringify(result.payload);
        res.writeHead(result.httpcode, result.headers);
        res.end(resultPayload);
    } else {
        throw Error("unknown path " + path);
    }

})

server.listen();
processMessages();
persistBroker();

shutdown(async () => {
    await server.close();
    process.exit(0);
});

