/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      broker.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

'use strict'

const shutdown = require('@mangar2/shutdown')
const Server = require('@mangar2/httpservice').HttpServer
const Client = require('@mangar2/httpservice').HttpClient
const Connect = require('@mangar2/connect')
const MqttInterface = require('@mangar2/mqtt')

function getInterface (path) {
    const pathArray = path.split('/').splice(1)
    const calledInterface = pathArray[0]
    return calledInterface
}

function getClientId (path) {
    const pathArray = path.split('/').splice(2)
    const clientId = pathArray.join('/')
    return clientId
}

/**
 * Pauses the execution for a while (needs to "wait") for the result.
 * @param {number} timeInMilliseconds delay in milliseconds
 */
function delay (timeInMilliseconds) {
    return new Promise(resolve => setTimeout(resolve, timeInMilliseconds))
}

module.exports = class Broker {
    constructor (options) {
        this.options = options
        this.running = false
        this.options.persistInterval = !isNaN(this.options.persistInterval) ? this.options.persistInterval : 30 * 1000

        this.server = new Server(this.options.port)
        this.mqtt = new MqttInterface(this.options.connections)
        this.mqtt.restoreFromFile()
        this.changed = false

        this.server.on('put', (payload, headers, path, res) => {
            this.changed = true
            const command = getInterface(path)
            const receivedPayload = JSON.parse(payload)
            const result = this.mqtt.processRequest(command, receivedPayload, headers)
            res.writeHead(result.statusCode, result.headers)
            res.end(result.payload)
        })

        this.server.on('get', (payload, headers, path, res) => {
            const command = getInterface(path)
            if (command === 'clients') {
                const clientId = getClientId(path)
                const result = this.mqtt.getConnections(clientId)
                const resultPayload = JSON.stringify(result.payload)
                res.writeHead(result.statusCode, result.headers)
                res.end(resultPayload)
            } else {
                throw Error('unknown path ' + path)
            }
        })

        this.mqtt.on('send', async (host, port, path, payload, headers) => {
            const client = new Client(host, port)
            const result = await client.send('/' + path, 'PUT', payload, headers)
            return result
        })

        shutdown(async () => {
            await this.close()
            process.exit(0)
        })
    }

    /**
     * Connects to a friendly broker and subscribs for all messages
     * @param {string} host name of the host (or his ip)
     * @param {number} port port number to connect to
     */
    connect (host, port) {
        this.connect = new Connect('broker/new', host, port, this.options.port)
        this.connect.connectAndSubscribe(false, { '#': 1 }, '0.0')
    }

    /**
     * Sets a callback.
     * @param {string} event callback name
     * @param {function} callback
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on (event, callback) { this.mqtt.on(event, callback) }

    /**
     * Starts the broker. It will listen to message, send messages and periodically store its status
     */
    run () {
        this.running = true
        this.server.listen()
        if (this.options.persistInterval !== 0) {
            this._persistBroker()
        }
        this._processMessages()
    }

    /**
     * Closes the broker, stops listening
     */
    async close () {
        this.running = false
        await this.server.close()
        if (this.options.persistInterval !== 0) {
            await this.mqtt.connections.persist()
        }
    }

    async _processMessages () {
        while (this.running) {
            let messagesSent = 0
            messagesSent = await this.mqtt.processSendMessage()
            await delay(messagesSent > 0 ? 5 : 50)
        }
    }

    async _persistBroker () {
        while (this.running) {
            if (this.changed) {
                this.changed = false
                await this.mqtt.connections.persist()
            }
            await delay(this.options.persistInterval)
        }
    }
}
