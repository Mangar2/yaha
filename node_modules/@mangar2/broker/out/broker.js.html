<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: broker.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: broker.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const shutdown = require('@mangar2/shutdown')
const Server = require('@mangar2/httpservice').HttpServer
const Client = require('@mangar2/httpservice').HttpClient
const Connect = require('@mangar2/connect')
const MqttInterface = require('@mangar2/mqtt')
const CheckInput = require('@mangar2/checkinput')
const sanitize = require('@mangar2/configuration')

/**
 * @private
 * Gets the interface (first section of the path)
 * @param {string} path http path
 * @returns {string} first section of the path
 */
function getInterface (path) {
    const pathArray = path.split('/').splice(1)
    const calledInterface = pathArray[0]
    return calledInterface
}

/**
 * @private
 * Gets the client id of the path (the second section of the path)
 * @param {string} path http path
 * @returns {string} client id of the path (second part)
 */
function getClientId (path) {
    const pathArray = path.split('/').splice(2)
    const clientId = pathArray.join('/')
    return clientId
}

/**
 * @private
 * Pauses the execution for a while (needs to "wait") for the result.
 * @param {number} timeInMilliseconds delay in milliseconds
 * @returns {Promise} promise to wait for
 */
function delay (timeInMilliseconds) {
    return new Promise(resolve => setTimeout(resolve, timeInMilliseconds))
}

/**
 * @private
 * Check broker configuration
 */

const checkConfiguration = new CheckInput({
    type: 'object',
    properties: {
        port: { type: 'number', minimum: 1025, maximum: 65536 },
        persistInterval: { type: 'number', minimum: 0, maximum: 365 * 24 * 3600 * 1000 },
        connections: {
            type: 'object'
        }
    },
    required: ['port', 'persistInterval', 'connections']
})

/**
 * @private
 * Configuration default values
 */
const defaultValues = {
    port: 9001,
    persistInterval: 60 * 1000,
    connections: {
        fileName: 'broker',
        directory: '.',
        log: [{
            module: 'all',
            topic: '$SYS/#'
        }]
    }
}

/**
 * Creates a new broker
 * @param {Object} configuration configuration (configuration) of the broker
 * @param {number|string} configuration.port port number the broker will listen on
 * @param {number} configuration.persistInterval in milliseconds. Intervall between persisting
 * internal state to file
 * @param {Object} configuration.connections connection settings for the broker
 * @param {string} configuration.connections.fileName filename for persistence
 * @param {string} configuration.connections.directory directory (file path) for persistence
 * @param {number} configuration.connections.replyTimeoutInMilliseconds timeout to wait for an answer
 * of a http call
 * @param {number} [configuration.connections.inFlightWindow=1] amount of qos 1 and qos 2 messages
 * send for the same topic at the same time
 * @param {number} [configuration.connections.pubrelTimeoutInMilliseconds=one day] temeout to wait for a
 * corresponding pubrel message
 * @param {number} configuration.connections.maxRetryCount amount of resend of messages
 * before forcing a disconnect
 * @param {number} configuration.connections.maxQueuSize maximal amount of entries in a message queue
 * @param {Object} configuration.connections.log log settings
 * @example
 * const configuration = {
 *      port: 10000,
 *      persistInterval: 0,
 *      connections: {
 *           directory: '.',
 *           fileName: 'broker',
 *           log: [
 *               {
 *                   module: 'received',
 *                   topic: '#'
 *               }
 *           ]
 *       }
 *   }
 * const broker = new Broker(configuration)
 * broker.run()
 */
class Broker {
    constructor (configuration) {
        this._configuration = sanitize(configuration, defaultValues, checkConfiguration)
        this.running = false

        this.server = new Server(this._configuration.port)
        this.mqtt = new MqttInterface(this._configuration.connections)
        this.mqtt.restoreFromFile()
        this.changed = false

        this.server.on('put', (payload, headers, path, res) => {
            this.changed = true
            const command = getInterface(path)
            const receivedPayload = JSON.parse(payload)
            const result = this.mqtt.processRequest(command, receivedPayload, headers)
            res.writeHead(result.statusCode, result.headers)
            res.end(result.payload)
        })

        this.server.on('get', (payload, headers, path, res) => {
            const command = getInterface(path)
            if (command === 'clients') {
                const result = this._getClientInfo(path)
                const resultPayload = JSON.stringify(result.payload)
                res.writeHead(result.statusCode, result.headers)
                res.end(resultPayload)
            } else {
                throw Error('unknown path ' + path)
            }
        })

        this.mqtt.on('send', async (host, port, path, payload, headers) => {
            const client = new Client(host, port)
            const result = await client.send('/' + path, 'PUT', payload, headers)
            return result
        })

        shutdown(async () => {
            await this.close()
            process.exit(0)
        })
    }

    /**
     * Connects to a friendly broker and subscribs for all messages
     * @param {string} host name of the host (or his ip)
     * @param {number} port port number to connect to
     */
    connect (host, port) {
        this.connect = new Connect('broker/new', host, port, this._configuration.port)
        this.connect.connectAndSubscribe(false, { '#': 1 }, '0.0')
    }

    /**
     * Sets a callback.
     * @param {string} event callback name (supports 'send' and 'publish')
     * 'send' is called to send data. This function is provided by the broker but could be overwritten
     * 'publish' is called on receiving data. This function if provided by the broker but could be overwritten
     * @param {function} callback
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on (event, callback) { this.mqtt.on(event, callback) }

    /**
     * Starts the broker. It will listen to message, send messages and periodically store its status
     */
    run () {
        this.running = true
        this.server.listen()
        if (this._configuration.persistInterval !== 0) {
            this._persistBroker()
        }
        this._processMessages()
    }

    /**
     * Closes the broker, stops listening
     */
    async close () {
        this.running = false
        await this.server.close()
        if (this._configuration.persistInterval !== 0) {
            await this.mqtt.connections.persist()
        }
    }

    /**
     * @private
     * Send all messages that are "ready to send"
     */
    async _processMessages () {
        while (this.running) {
            let messagesSent = 0
            messagesSent = await this.mqtt.processSendMessage()
            await delay(messagesSent > 0 ? 5 : 50)
        }
    }

    /**
     * @private
     * Stores the broker connection data to file
     */
    async _persistBroker () {
        while (this.running) {
            if (this.changed) {
                this.changed = false
                await this.mqtt.connections.persist()
            }
            await delay(this._configuration.persistInterval)
        }
    }

    /**
     * @private
     * @description
     * Gets information about the client status
     * @param {string} path http path to the client 'client/clientname
     */
    _getClientInfo (path) {
        const clientId = getClientId(path)
        const result = this.mqtt.getConnections(clientId)
        return result
    }
}

module.exports = Broker
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Broker.html">Broker</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Thu Mar 26 2020 21:53:26 GMT+0100 (GMT+01:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
