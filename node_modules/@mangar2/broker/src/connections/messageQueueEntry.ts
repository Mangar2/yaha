/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

import { Message, IMessage } from '@mangar2/mqtt-utils'

export interface IMessageQueueEntryParam {
    message: Message;
    packetid?: number;
    clientId?: string;
    host?: string;
    port?: number;
    version?: string;
    token?: string;
}

/**
 * @description
 * Creates a new message queue entry storing all information to send a message including receiver
 */
export class MessageQueueEntry {
    private _message: Message;
    private _packetid?: number;
    private _transmitTimestamp: number;
    private _status: string;
    private _retryCount: number;
    private _clientId?: string;
    private _host?: string;
    private _port?: number;
    private _version?: string;
    private _token?: string;

    constructor (param: IMessageQueueEntryParam) {
        this._message = param.message;
        // Unique packetid to identify the entry (optional)
        this._packetid = param.packetid;
        // Timestamp the payload was transmitted
        this._transmitTimestamp = 0;
        // Status of the entry
        this._status = 'new';
        // Amount of retries to transmit the playload
        this._retryCount = 0;

        this._clientId = param.clientId;
        this._host = param.host;
        this._port = param.port;
        this._version = param.version;
        this._token = param.token;
    }

    get qos () { return this._message.qos ?? 0; }

    /**
     * Payload of the message
     * @type {Message|Object}
     */
    get message () { return this._message }
    set message (message) { this._message = message }

    /**
     * Id of the transfer packet
     * @type {number}
     */
    get packetid () { return this._packetid }
    set packetid (packetid) { this._packetid = packetid }

    /**
     *  1 signals that it is a duplicate (has been send before), accepts also
     *  true/false or '1'/'0' instead of 1/0
     * @type {number}
     */
    get dup () { return this.retryCount > 1 ? 1 : 0 }
  
    /**
     * Id of the client
     * @type {string}
     */
    get clientId () { return this._clientId }
    set clientId (clientId) { this._clientId = clientId }

    /**
     * Status of the entry {new, duplicate, pubrel}
     * @type {string}
     */
    get status () { return this._status }
    set status (status) { this._status = status }

    /**
     * Version of the interface to use 'major.minor'
     * @type {string}
     */
    get version () { return this._version }
    set version (version) { this._version = version }

    /**
     * Timestamp of the last message transmit
     * @type {number}
     */
    get transmitTimestamp () { return this._transmitTimestamp }
    set transmitTimestamp (transmitTimestamp) { this._transmitTimestamp = transmitTimestamp }

    /**
     * Amount of retries to send the package
     * @type {number}
     */
    get retryCount () { return this._retryCount }
    set retryCount (retryCount) { this._retryCount = retryCount }

    /**
     * The client receive token
     * @type {string}
     */
    get token () { return this._token }
    set token (token) { this._token = token }

    /**
     * Host name of the client
     * @type {string}
     */
    get host () { return this._host }
    set host (host) { this._host = host }

    /**
     * Port number of the client
     * @type {number}
     */
    get port () { return this._port }
    set port (port) { this._port = port }

    /**
     * Restore the object by setting all properties (usually from a file)
     * @param {Object} properties object with all needed properties of this class.
     */
    static restoreFromObject(properties: { [key: string]: any }): MessageQueueEntry {
        if (properties['message'] !== undefined) {
            properties['message'] = Message.createMessage(properties['message'] as IMessage)
        }
        return new MessageQueueEntry(properties as IMessageQueueEntryParam );
    }

    /**
     * Sets infos of the client
     * @param {string} clientId id of the client
     * @param {string} host host name of the client
     * @param {number} port port number of the client
     * @param {string} version client interface version
     * @param {string} token token clients may check receiving published messages
     */
    setClientInfo(clientId: string, host: string, port: number, version: string, token: string): void {
        this.clientId = clientId;
        this.host = host;
        this.port = port;
        this.version = version;
        this.token = token;
    }

    /**
     * Sets the status to pubrel
     */
    setStatusToPubrel (): void {
        this.status = 'pubrel'
        this.retryCount = 0
    }

    /**
     * increases the retry counter and stores the actual timestamp
     */
    setTransmissionTimestamp (): void {
        const now = (new Date()).getTime()
        this._transmitTimestamp = now
        this.retryCount++
    }

    /**
     * Checks, if the status is pubrel
     * @returns {boolean}
     */
    isStatusPubrel (): boolean {
        return this.status === 'pubrel'
    }

    /**
     * Link to send the message to (/publish or /pubrel)
     * @readonly
     * @type {string}
     */
    get link (): string {
        if (this.status === 'pubrel') {
            return '/pubrel'
        } else {
            return '/publish'
        }
    }
}
