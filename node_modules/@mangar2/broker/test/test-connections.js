/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker BÃ¶hm
 * @copyright Copyright (c) 2020 Volker BÃ¶hm
 */

'use strict'
const { delay } = require('@mangar2/utils')
const { Message } = require('@mangar2/mqtt-utils')
const { TestRun } = require('@mangar2/unittest')
const { Connections } = require('@mangar2/broker/dist/connections/connections')
const VERBOSE = true
const testrun = new TestRun(VERBOSE)

function connect(connections, connectList) {
    if (connectList) {
        for (const connection of connectList) {
            connections.connect(connection.clientId, connection.host, connection.port, connection.clean, connection.version, connection.keepAlive)
            if (connection.will) {
                connections.setWill(connection.clientId, connection.will)
            }
        }
    }
}

testrun.on('prepare', async testcase => {
    const config = {
        fileName: 'connectionData',
        directory: '.',
        replyTimeoutInMilliseconds: 10,
        pubrelTimeoutInMilliseconds: 1000,
        maxRetryCount: 10
    }
    const connections = new Connections(config)
    connect(connections, testcase.connect)
    if (testcase.subscribe) {
        for (const subscription of testcase.subscribe) {
            connections.subscribe(subscription.client, subscription.topic)
        }
    }

    return connections
})

function getSendToken(connections, messageQueueEntry) {
    const clientId = messageQueueEntry.clientId
    const client = connections.getClientById(clientId)
    const sendToken = client.sendToken
    return sendToken
}

/**
 * Retrieves a list of messages and acknowledges it
 * @param {Connections} connections 
 * @returns {Array} List of messages
 */
function getAndAcknowledgeMessageList(connections) {
    const messageList =  connections.getAllMessagesToSend()
    const copiedList = []
    for (const messageQueueEntry of messageList) {
        copiedList.push({...messageQueueEntry})
        connections.acknowledgeMessage(messageQueueEntry)
        if (messageQueueEntry.status === 'pubrel') {
            const sendToken = getSendToken(connections, messageQueueEntry)
            connections.onPubrel(sendToken, messageQueueEntry.packetid)
        }
    }
    return copiedList
}

const runTest = async (test, connections) => {
    connect(connections, test.connect)
    if (test.publish) {
        for (const publish of test.publish) {
            const message = new Message(publish.topic, publish.value, publish.reason, publish.qos, publish.retain)
            connections.publishMessage(message)
        }
    }
    if (test.disconnect) {
        for (const clientId of test.disconnect) {
            connections.disconnect(clientId)
        }
    }
    if (test.unsubscribe) {
        for (const unsubscribe of test.unsubscribe) {
            connections.unsubscribe(unsubscribe.clientId, unsubscribe.topics)
        }
    }
    if (test.delay) {
        await delay(test.delay)
        connections.cleanup()
    }
    let messageList =  getAndAcknowledgeMessageList(connections)
    let messageLists = []
    while (messageList.length > 0) {
        messageLists.push(messageList)
        messageList =  getAndAcknowledgeMessageList(connections)
    }
    return messageLists
}

testrun.on('run', runTest)

testrun.on('break', async (test, automation) => {
    runTest(test, automation)
})


module.exports = async () => {
    return await testrun.asyncRun([
        'test-publish-cases',
        'test-disconnect-cases',
        'test-unsubscribe-cases',
        'test-will-cases',
        'test-clean-cases'
    ], __dirname, 10, 'js')
}