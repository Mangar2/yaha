/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      checkinput.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

'use scrict'

module.exports = class CheckInput {
    /**
     * Creates a new input check class
     * @param {object} definition swagger like content defintion
     */
    constructor (definition) {
        this.definition = definition
        this.messages = undefined
    }

    /**
     * Gets the list of error messages
     * @returns {object} error messages {topic: message, topic: message, ...}
     */
    get messages () { return this._messages }
    set messages (messages) { this._messages = messages }

    /**
     * Checks a boolean variable
     * @param {boolean} variable input data
     * @returns {true | string} true, if the variable is correct, else an error message
     */
    static checkBoolean (variable) {
        let result = true
        if (variable !== true && variable !== false) {
            result = ("'" + variable + "' is not boolean")
        }
        return result
    }

    /**
     * Checks a number variable against a defintion
     * @param {object} definition number definition
     * @param {string} variable input data
     * @returns {true | string} true, if the variable is correct, else an error message
     */
    static checkNumber (definition, variable) {
        let result = true
        if (typeof (variable) === 'string' && !isNaN(variable)) {
            variable = parseFloat(variable)
        }
        if (typeof (variable) !== 'number') {
            result = ("'" + variable + "' is not a number")
        } else if (definition.minimum !== undefined && variable < definition.minimum) {
            result = (variable + ' below ' + definition.minimum)
        } else if (definition.maximum !== undefined && variable > definition.maximum) {
            result = (variable + ' above ' + definition.maximum)
        }
        return result
    }

    /**
     * Checks a string format
     * @param {string} format string format description
     * @param {string} variable variable to check
     */
    static checkStringFormat (format, variable) {
        let result = true
        switch (format) {
        case 'date': result = variable.match(/^\d{4}-\d{2}-\d{2}$/) !== null; break
        case 'date-time': result = variable.match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(.\d{3})?(Z|[+-]\d{2}:\d{2})$/) !== null; break
        }
        if (result === false) {
            result = "'" + variable + "' is not a " + format
        }
        return result
    }

    /**
     * Checks a string variable against a defintion
     * @param {object} definition string definition
     * @param {string} variable input data
     * @returns {true | string} true, if the variable is correct, else an error message
     */
    static checkString (definition, variable) {
        let result = true
        if (typeof (variable) !== 'string') {
            result = "'" + variable + "' is not a string"
        } else if (definition.minLength !== undefined && variable.length < definition.minLength) {
            result = "'" + variable + "' minimum length " + definition.minLength + ' not reached'
        } else if (definition.maxLength !== undefined && variable.length > definition.maxLength) {
            result = "'" + variable + "'  maximum length " + definition.maxLength + ' exceeded'
        } else if (definition.format !== undefined) {
            result = CheckInput.checkStringFormat(definition.format, variable)
        }
        return result
    }

    /**
     * Checks a variable against an array of definitions, returns true, if it matches exactly one
     * @param {object} definitions variable definition
     * @param {any} variable input data
     * @returns {boolean} true, if it matches exactly one of the definitions
     */
    static anyOf (definitions, variable) {
        let result = []
        for (const definition of definitions) {
            const current = CheckInput.checkType(definition, variable)
            if (current === true) {
                result = true
                break
            } else {
                result.push(current)
            }
        }
        if (result !== true) {
            result = { anyOf: result }
        }
        return result
    }

    /**
     * Checks a variable against a defintion
     * @param {object} definition variable definition
     * @param {any} variable input data
     * @returns {boolean} true, if the variable matches the definition
     */
    static checkType (definition, variable) {
        let result = true
        if (definition.oneOf !== undefined) {
            result = CheckInput.oneOf(definition.oneOf, variable)
        } else if (definition.anyOf !== undefined) {
            result = CheckInput.anyOf(definition.anyOf, variable)
        } else if (definition.allOf !== undefined) {
            result = CheckInput.allOf(definition.allOf, variable)
        } else {
            switch (definition.type) {
            case 'string': result = CheckInput.checkString(definition, variable); break
            case 'number': result = CheckInput.checkNumber(definition, variable); break
            case 'array': result = CheckInput.checkArray(definition, variable); break
            case 'object': result = CheckInput.checkObject(definition, variable); break
            case 'boolean': result = CheckInput.checkBoolean(variable); break
            }
        }
        return result
    }

    /**
     * Adds an error message to the result structure
     * @param {true|object} result current result structure
     * @param {string} property property name
     * @param {string} message error message
     */
    static addErrormessageToResult (result, property, message) {
        if (typeof (result) !== 'object') {
            result = {}
        }
        result[property] = message
        return result
    }

    /**
     * Checks if required elements are available
     * @param {array} required array of required properties
     * @param {object} object input data
     * @returns {boolean | object} true, if the object has all required properties else object of error messages
     */
    static checkRequired (required, object) {
        let result = true
        if (required !== undefined) {
            for (const property of required) {
                if (object[property] === undefined) {
                    result = CheckInput.addErrormessageToResult(result, property, 'missing property ' + property)
                }
            }
        }
        return result
    }

    /**
     * Checks if all properties matches the property definitions
     * @param {object} propertyDefintions list of property definitions
     * @param {object} object input data
     */
    static checkProperties (propertyDefintions, object) {
        let result = true
        if (propertyDefintions !== undefined) {
            for (const property in propertyDefintions) {
                if (object[property] !== undefined) {
                    const check = CheckInput.checkType(propertyDefintions[property], object[property])
                    if (check !== true) {
                        result = CheckInput.addErrormessageToResult(result, property, check)
                    }
                }
            }
        }
        return result
    }

    /**
     * Checks an object against a definition
     * @param {object} definition object definition
     * @param {object} object input data
     * @returns {boolean} true, if the object matches the definition
     */
    static checkObject (definition, object) {
        let result = true
        if (typeof (object) !== 'object') {
            result = 'object expected'
        } else {
            const required = CheckInput.checkRequired(definition.required, object)
            const properties = CheckInput.checkProperties(definition.properties, object)
            if (required !== true || properties !== true) {
                result = {}
                if (required !== true) {
                    result = required
                }
                if (properties !== true) {
                    result = { ...result, ...properties }
                }
            }
        }
        return result
    }

    /**
     * Checks an array against a definition
     * @param {object} definition array definition
     * @param {array} array input data
     */
    static checkArray (definition, array) {
        let result = true
        if (!Array.isArray(array)) {
            result = 'array expected'
        } else if (definition.minItems !== undefined && array.length < definition.minItems) {
            result = ' array must have at least ' + definition.minItems + ' elements'
        } else if (definition.maxItems !== undefined && array.length <= definition.maxItems) {
            result = ' array may not have more than ' + definition.maxItems + ' elements'
        } else {
            for (const index in array) {
                const item = array[index]
                const check = CheckInput.checkType(definition.items, item)
                if (check !== true) {
                    result = CheckInput.addErrormessageToResult(result, index, check)
                }
            }
        }
        return result
    }

    /**
     * Checks an object against a swagger defintion
     * @param {object} data data to check against definition
     * @returns {boolean} true, if the data matches to the definition
     */
    validate (data) {
        let result
        const check = CheckInput.checkType(this.definition, data)
        if (check === true) {
            result = true
            this.messages = ''
        } else {
            result = false
            this.messages = check
        }
        return result
    }

    /**
     * Validates the input and throws a message on error
     * @param {object} data data to check against definition
     * @param {string} message start of an error message
     */
    throwOnValidationError (data, message) {
        if (!this.validate(data)) {
            throw (Error(message + JSON.stringify(this.messages)))
        }
    }
}
