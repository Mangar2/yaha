/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use scrict'

const types = require('@mangar2/types')

/**
 * @private
 * Checks an element "deeply" for differences
 * @param {any} a first element to compare
 * @param {any} b second element to compare
 * @param {string} path path to the element to compare
 * @throws {string} description of the difference including the path to the element
 */
function deepEqualRec (a, b, path) {
    if (typeof (a) !== typeof (b) || types.isArray(a) !== types.isArray(b)) {
        throw path + ': types are different '
    }
    if (types.isArray(a)) {
        if (a.length !== b.length) {
            throw path + ': arrays have different length'
        }
        for (const index in a) {
            deepEqualRec(a[index], b[index], path + '/' + index)
        }
    } else if (types.isObject(a)) {
        if (Object.keys(a).length !== Object.keys(b).length) {
            throw path + ': objects have different amount of properties'
        }
        if (a.constructor.name !== b.constructor.name) {
            throw path + ': objects have different constructor names: ' + a.constructor.name + ' != ' + b.constructor.name
        }
        for (const index in a) {
            deepEqualRec(a[index], b[index], path + '/' + index)
        }
    } else if (a !== b) {
        throw path + ': elements have different value: ' + a + ' !== ' + b
    }
}

/**
 * @private
 * Checks, if a is a multiple of b
 * @param {number} a
 * @param {number} b
 * @returns {boolean}
 */
function isMultipleOf (a, b) {
    let result = false
    if (b !== 0) {
        const factor = Math.trunc(a / b)
        const multiply = b * factor
        const difference = Math.abs(a - multiply)
        result = difference <= a / 1E12
    }
    return result
}

/**
 * @private
 * Creates a result object
 * @property {boolean} check result of the check
 */
class CheckResult {
    constructor (check) {
        this.check = check
        this.messages = null
    }

    /**
     * Gets the check result
     * @returns {boolean}
     */
    get check () { return this._check }

    /**
     * Sets the check result
     * @param {boolean}  check
     */
    set check (check) { this._check = check }

    /**
     * Gets the messages
     * @returns {Object|string}
     */
    get messages () { return this._messages }

    /**
     * Sets the messages
     * @param {Object|string} messages
     */
    set messages (messages) { this._messages = messages }

    /**
     * Invalidates the result. It sets 'check' to false and the error message
     * @param {string|Object} message error message
     * @param {string} [property] name of the property causing the invalidation
     */
    invalidate (message, property) {
        if (property === undefined) {
            if (this.messages === null) {
                this.messages = message
            } else if (types.isObject(this.messages)) {
                this.messages = { ...this.messages, ...message }
            } else {
                if (!types.isArray(this.messages)) {
                    this.messages = [this.messages]
                }
                if (types.isArray(message)) {
                    this.messages.push(...message)
                } else {
                    this.messages.push(message)
                }
            }
        } else {
            if (!types.isObject(this.messages)) {
                this.messages = {}
            }
            this.messages[property] = message
        }
        this.check = false
    }

    /**
     * Sets the property related to the message
     * @param {string} property name of the property related to this message
     */
    setProperty (property) {
        if (this.messages !== null) {
            const messages = this.messages
            this.messages = {}
            this.messages[property] = messages
        }
    }

    /**
     * Adds an alternative result. the value is combined with an or. If value is still false
     * the messages are added in an array
     * @param {CheckResult} result result of an alternative evaluation
     */
    addAlternative (result) {
        this.check = this.check || result.check
        if (!this.check) {
            this.invalidate(result.messages)
        }
    }

    /**
     * Adds another check. the value is combined with an and, the messages are combined
     * @param {CheckResult} result result of an alternative evaluation
     */
    addCheck (result) {
        this.check = this.check && result.check
        if (!this.check) {
            this.invalidate(result.messages)
        }
    }
}

/**
 * Creates a new JSON Schema validation class
 * Checks a data object according a JSON Schema. This is not (yet) a full implementation. Currently supported:
 * additionalItems
 * additionalProperties
 * allOf,
 * anyOf,
 * boolean_schema,
 * const,
 * contains
 * enum,
 * exclusiveMaximum,
 * exclusiveMinimum,
 * if-then-else,
 * items,
 * maximum,
 * maxItems,
 * maxLength,
 * maxProperties,
 * minimum,
 * minItems,
 * minLength,
 * minProperties,
 * multipleOf,
 * not,
 * oneOf,
 * properties,
 * ref (not external),
 * required,
 * type, (including all simple types)
 * uniqueItems (not deep unique - objects and arrays are always different)
 * @param {Any} definition JSON schema definition
 * @example
 * check = new CheckInput({
 *   type: 'object',
 *   properties: {
 *       topic: { type: 'string' },
 *       value: { type: 'string' },
 *   },
 *   required: ['topic', 'value']
 * })
 * // returns true, as the parameter fits to the descriptions
 * check.validate({ topic: '/a/b', value: 'on' })
 *
 * // returns false and fills the error message
 * // check.message is { topic: 'missing property topic', value: 'missing property value' }
 * check.validate ( {} )
 *
 * // Throws an Error, as the validation does not fits to the description
 * check.throwOnValidationError({ topic: '/a/b' })
 *
 * // Prints the error message
 * console.log(check.messages)
 */
class CheckInput {
    constructor (definition) {
        this.definition = definition
        this.messages = undefined
    }

    /**
     * Gets the list of error messages
     * @returns {Object|string} error message tree
     */
    get messages () { return this._messages }
    set messages (messages) { this._messages = messages }

    /**
     * @private
     * Checks a boolean variable
     * @param {Object} definition boolean definition
     * @param {boolean} variable input data
     * @returns {CheckResult} result of the check
     */
    _checkBoolean (definition, variable) {
        const result = new CheckResult(true)
        if (variable !== true && variable !== false) {
            result.invalidate("'" + variable + "' is not boolean")
        }
        return result
    }

    /**
     * @private
     * Checks if a value evaluates to true or false
     * @param {Object} definition true or false
     * @param {boolean} variable input data
     * @returns {CheckResult} result of the check
     */
    _checkTrueFalse (definition, variable) {
        const result = new CheckResult(true)
        if (definition === true) {
            // do nothing true validates to everything
        } else if (definition === false) {
            result.invalidate(' everything is invalid ')
        }
        return result
    }

    /**
     * @private
     * Checks a number variable against a defintion
     * @param {Object} definition number definition
     * @param {string} variable input data
     * @returns {CheckResult} result of the check
     */
    _checkNumber (definition, variable) {
        const result = new CheckResult(true)
        if (definition.minimum !== undefined && variable < definition.minimum) {
            result.invalidate(variable + ' below ' + definition.minimum)
        } else if (definition.maximum !== undefined && variable > definition.maximum) {
            result.invalidate(variable + ' above ' + definition.maximum)
        } else if (definition.exclusiveMinimum !== undefined && variable <= definition.exclusiveMinimum) {
            result.invalidate(variable + ' below or equal to ' + definition.exclusiveMinimum)
        } else if (definition.exclusiveMaximum !== undefined && variable >= definition.exclusiveMaximum) {
            result.invalidate(variable + ' above or equal to ' + definition.exclusiveMaximum)
        } else if (types.isNumber(definition.multipleOf) && !isMultipleOf(variable, definition.multipleOf)) {
            result.invalidate(variable + ' is not a multiple of ' + definition.multipleOf)
        }
        return result
    }

    /**
     * @private
     * Checks a string format
     * @param {string} format string format description
     * @param {string} variable variable to check
     * @returns {CheckResult} result of the check
     */
    _checkStringFormat (format, variable) {
        const result = new CheckResult(true)
        switch (format) {
        case 'date': result.check = variable.match(/^\d{4}-\d{2}-\d{2}$/) !== null; break
        case 'date-time': result.check = variable.match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(.\d{3})?(Z|[+-]\d{2}:\d{2})$/) !== null; break
        }
        if (result.check === false) {
            result.invalidate("'" + variable + "' is not a " + format)
        }
        return result
    }

    /**
     * @private
     * Checks a string variable against a defintion
     * @param {Object} definition string definition
     * @param {string} variable input data
     * @returns {CheckResult} result of the check
     */
    _checkString (definition, variable) {
        let result = new CheckResult(true)
        if (definition.minLength !== undefined && variable.length < definition.minLength) {
            result.invalidate("'" + variable + "' minimum length " + definition.minLength + ' not reached')
        } else if (definition.maxLength !== undefined && variable.length > definition.maxLength) {
            result.invalidate("'" + variable + "'  maximum length " + definition.maxLength + ' exceeded')
        } else if (definition.format !== undefined) {
            result = this._checkStringFormat(definition.format, variable)
        }
        return result
    }

    /**
     * @private
     * Checks if two objects are equal
     * @param {any} definition first object
     * @param {any} variable input data
     * @returns {CheckResult} result of the check
     */
    _isEqual (definition, variable) {
        const result = new CheckResult(true)
        try {
            deepEqualRec(definition, variable, '')
        } catch (err) {
            result.invalidate(err)
        }
        return result
    }

    /**
     * @private
     * Checks if two objects are equal
     * @param {Array} definition enum definition array
     * @param {any} variable input data
     * @returns {CheckResult} result of the check
     */
    _checkEnum (definition, variable) {
        let result = new CheckResult(false)
        if (types.isArray(definition)) {
            for (const element of definition) {
                result = this._isEqual(element, variable)
                if (result.check) {
                    break
                }
            }
        }
        return result
    }

    /**
     * @private
     * Checks an if then else construct
     * @param {Object} definition definition of the Schema
     * @param {Object} definition.if if part
     * @param {Object} definition.then then part
     * @param {Object} definition.else else part
     * @param {any} variable input data
     * @returns {CheckResult} result of the check
     */
    _checkIfThenElse (definition, variable) {
        const ifCheck = this._checkType(definition.if, variable)
        let result = new CheckResult(true)
        if (ifCheck.check === true && definition.then !== undefined) {
            result = this._checkType(definition.then, variable)
        } else if (ifCheck.check === false && definition.else !== undefined) {
            result = this._checkType(definition.else, variable)
        }
        return result
    }

    /**
     * @private
     * Checks a variable against an array of definitions, returns true, if it matches any
     * @param {Object} definitions variable definition
     * @param {any} variable input data
     * @returns {CheckResult} result of the check
     */
    _anyOf (definitions, variable) {
        const result = new CheckResult(false)
        for (const definition of definitions) {
            const current = this._checkType(definition, variable)
            result.addAlternative(current)
        }
        if (!result.check) {
            result.setProperty('anyOf')
        }
        return result
    }

    /**
     * @private
     * Checks a variable against an array of definitions, returns true, if it matches all
     * @param {Object} definitions variable definition
     * @param {any} variable input data
     * @returns {CheckResult} result of the check
     */
    _allOf (definitions, variable) {
        const result = new CheckResult(true)
        for (const definition of definitions) {
            const current = this._checkType(definition, variable)
            result.addCheck(current)
        }
        if (!result.check) {
            result.setProperty('allOf')
        }
        return result
    }

    /**
     * @private
     * Checks a variable against an array of definitions, returns true, if it matches exactly one
     * @param {Object} definitions variable definition
     * @param {any} variable input data
     * @returns {CheckResult} result of the check
     */
    _oneOf (definitions, variable) {
        const result = new CheckResult(false)
        for (const definition of definitions) {
            const current = this._checkType(definition, variable)
            if (result.check === true && current.check === true) {
                result.invalidate(' matches more than one ')
                break
            } else {
                result.addAlternative(current)
            }
        }
        if (!result.check) {
            result.setProperty('allOf')
        }
        return result
    }

    /**
     * @private
     * Checks the basic type of a variable
     * @param {Object} definition variable definition
     * @param {string|Array} definition.type allowed type(s) of the variable
     * @param {any} variable input data
     * @returns {CheckResult} result of the check with 'check' and 'message'
     */
    _checkBasicType (definition, variable) {
        const result = new CheckResult(true)
        if (definition.type !== undefined) {
            const typeList = types.isArray(definition.type) ? definition.type : [definition.type]
            for (const type of typeList) {
                switch (type) {
                case 'string': result.check = types.isString(variable); break
                case 'number': result.check = types.isNumber(variable); break
                case 'integer': result.check = Number.isInteger(variable); break
                case 'array': result.check = types.isArray(variable); break
                case 'object': result.check = types.isObject(variable); break
                case 'boolean': result.check = types.isBoolean(variable); break
                case 'null': result.check = variable === null; break
                }
                if (result.check) {
                    break
                }
            }
            if (!result.check) {
                result.invalidate('Wrong type. Required is: ' + JSON.stringify(typeList))
            }
        }
        return result
    }

    /**
     * @private
     * Resolves a ref string returning the right reference
     * @param {string} path path into the schema definition
     * @param {any} definition current definition
     * @returns {any} referenced part of the definition
     */
    _resolveRef (path, definition) {
        const pathChunks = path.split('/')
        let result = definition
        if (pathChunks.length > 0 && pathChunks[0] === '#') {
            result = this.definition
            pathChunks.shift()
        }
        for (let chunk of pathChunks) {
            const zeroSplit = chunk.split('~0')
            chunk = zeroSplit.join('~')
            const slashSplit = chunk.split('~1')
            chunk = slashSplit.join('/')
            chunk = unescape(chunk)
            if (result === undefined) {
                break
            }
            result = result[chunk]
        }
        return result
    }

    /**
     * @private
     * Checks the "commands" of the JSON schema definition (oneOf, const, enum, ...)
     * @param {Object} definition variable defintion
     * @param {any} variable input data
     */
    _checkCommands (definition, variable) {
        const result = new CheckResult(true)
        if (definition.oneOf !== undefined) {
            result.addCheck(this._oneOf(definition.oneOf, variable))
        }
        if (definition.anyOf !== undefined) {
            result.addCheck(this._anyOf(definition.anyOf, variable))
        }
        if (definition.allOf !== undefined) {
            result.addCheck(this._allOf(definition.allOf, variable))
        }
        if (definition.const !== undefined) {
            result.addCheck(this._isEqual(definition.const, variable))
        }
        if (definition.enum !== undefined) {
            result.addCheck(this._checkEnum(definition.enum, variable))
        }
        if (definition.if !== undefined) {
            result.addCheck(this._checkIfThenElse(definition, variable))
        }
        if (definition.not !== undefined) {
            const curResult = this._checkType(definition.not, variable)
            if (curResult.check) {
                result.invalidate(' element must not match the schema ')
            }
        }
        return result
    }

    /**
     * @private
     * Checks a variable against a defintion
     * @param {Object} definition variable definition
     * @param {any} variable input data
     * @returns {CheckResult} result of the check with 'check' and 'message'
     */
    _checkType (definition, variable) {
        let result = new CheckResult(true)
        if (types.isBoolean(definition)) {
            result = this._checkTrueFalse(definition, variable)
            return result
        }
        if (definition.$ref !== undefined) {
            const refDefinition = this._resolveRef(definition.$ref, definition)
            if (refDefinition === undefined) {
                result.invalidate('reference ' + definition.$ref + ' not found')
                return result
            }
            result = this._checkType(refDefinition, variable)
            return result
        }
        result = this._checkCommands(definition, variable)
        if (definition.type === 'number' && types.isString(variable) && !isNaN(variable)) {
            variable = Number(variable)
        }
        result.addCheck(this._checkBasicType(definition, variable))
        if (types.isString(variable)) {
            result.addCheck(this._checkString(definition, variable))
        } else if (types.isNumber(variable)) {
            result.addCheck(this._checkNumber(definition, variable))
        } else if (types.isArray(variable)) {
            result.addCheck(this._checkArray(definition, variable))
        } else if (types.isObject(variable)) {
            result.addCheck(this._checkObject(definition, variable))
        } else if (types.isBoolean(variable)) {
            result.addCheck(this._checkBoolean(definition, variable))
        }
        return result
    }

    /**
     * @private
     * Checks if required elements are available
     * @param {Array} required array of required properties
     * @param {Object} object input data
     * @returns {CheckResult} result of the check with 'check' and 'message'
     */
    _checkRequired (required, object) {
        const result = new CheckResult(true)
        if (required !== undefined) {
            for (const property of required) {
                if (object[property] === undefined) {
                    result.invalidate('missing property ', property)
                }
            }
        }
        return result
    }

    /**
     * @private
     * Checks the type of additional (non defined) properties
     * @param {ObjectDefinition} definition object definition
     * @param {any} property property to check
     * @returns {CheckResult} result of the check with 'check' and 'message'
     */
    _checkAdditionalProperties (definition, property) {
        let result = new CheckResult(true)
        if (definition === false) {
            result.invalidate('unknown property, misspelled?')
        } else if (types.isObject(definition)) {
            result = this._checkBasicType(definition, property)
        }
        return result
    }

    /**
     * @private
     * Checks if properties matching a pattern have the right type
     * available not defined in the definition
     * @param {Object} patternProperties list of pattern based check rules for properties
     * @param {Object} object input data
     * @param {string} propertyName property to check
     * @returns {CheckResult} result of the check with 'check' and 'message'
     */
    _checkPatternProperties (patternProperties, object, propertyName) {
        let result = new CheckResult(undefined)
        for (const pattern in patternProperties) {
            const regExp = new RegExp(pattern)
            if (regExp.test(propertyName)) {
                result = this._checkType(patternProperties[pattern], object)
                result.setProperty(propertyName)
            }
        }
        return result
    }

    /**
     * @private
     * Checks if all properties matches the property definitions
     * @param {Object} definition object defition
     * @param {Object} object input data
     * @returns {CheckResult} result of the check with 'check' and 'message'
     */
    _checkProperties (definition, object) {
        const result = new CheckResult(true)
        const propertyDef = types.isObject(definition.properties) ? definition.properties : false
        const patternProperty = types.isObject(definition.patternProperties) ? definition.patternProperties : false
        const additionalPropery = definition.additionalProperties
        for (const propertyName in object) {
            let checked = false
            if (propertyDef && propertyDef[propertyName] !== undefined) {
                const curResult = this._checkType(propertyDef[propertyName], object[propertyName])
                curResult.setProperty(propertyName)
                result.addCheck(curResult)
                checked = true
            }
            if (patternProperty) {
                const curResult = this._checkPatternProperties(patternProperty, object[propertyName], propertyName)
                if (curResult.check !== undefined) {
                    curResult.setProperty(propertyName)
                    result.addCheck(curResult)
                    checked = true
                }
            }
            if (!checked && additionalPropery !== undefined) {
                const curResult = this._checkAdditionalProperties(additionalPropery, object[propertyName])
                curResult.setProperty(propertyName)
                result.addCheck(curResult)
            }
        }
        return result
    }

    /**
     * @private
     * Checks an object against a definition
     * @param {ObjectDefinition} definition object definition
     * @param {Object} object input data
     * @returns {CheckResult} result of the check with 'check' and 'message'
     */
    _checkObject (definition, object) {
        const result = new CheckResult(true)
        if (definition.minProperties !== undefined && Object.keys(object).length < definition.minProperties) {
            result.invalidate(' object must have at least ' + definition.minItems + ' properties')
        } else if (definition.maxProperties !== undefined && Object.keys(object).length > definition.maxProperties) {
            result.invalidate(' object may not have more than ' + definition.maxItems + ' properties')
        } else {
            const properties = this._checkProperties(definition, object)
            result.addCheck(properties)
            const required = this._checkRequired(definition.required, object)
            result.addCheck(required)
        }
        return result
    }

    /**
     * @private
     * Checks if an array contains elements
     * @param {Object} definition contains definition
     * @param {Array} array input data
     * @returns {CheckResult} result of the check with 'check' and 'message'
     */
    _checkContains (definition, array) {
        const result = new CheckResult(false)
        for (const element of array) {
            result.addAlternative(this._checkType(definition, element))
        }
        if (result.check === false) {
            result.invalidate('no array element validates to the definition')
        }
        return result
    }

    /**
     * Checks the items of an array having an items property of type Array
     * @param {Object} definition array definition
     * @param {Array} definition.items items defintion
     * @param {Object} [definition.additionalItems] definition for additional items
     * @param {Array} array of items
     */
    _checkArrayItems (definition, array) {
        const result = new CheckResult(true)
        for (const index in array) {
            const item = array[index]
            const defItem = definition.items[index]
            let check
            if (defItem !== undefined) {
                check = this._checkType(defItem, item)
            } else if (definition.additionalItems !== undefined) {
                check = this._checkType(definition.additionalItems, item)
            } else {
                break
            }
            if (!check.check) {
                check.setProperty(index)
            }
            result.addCheck(check)
        }
        return result
    }

    /**
     * @private
     * Checks an array against a definition
     * @param {Object} definition array definition
     * @param {Array} array input data
     * @returns {CheckResult} result of the check with 'check' and 'message'
     */
    _checkArray (definition, array) {
        const result = new CheckResult(true)
        if (definition.minItems !== undefined && array.length < definition.minItems) {
            result.invalidate(' array must have at least ' + definition.minItems + ' elements')
        }
        if (definition.maxItems !== undefined && array.length > definition.maxItems) {
            result.invalidate(' array may not have more than ' + definition.maxItems + ' elements')
        }
        if (definition.uniqueItems === true) {
            const isUnique = (new Set(array)).size === array.length
            if (!isUnique) {
                result.invalidate(' array items must be unique ')
            }
        }
        if (definition.contains !== undefined) {
            result.addCheck(this._checkContains(definition.contains, array))
        }
        if (types.isArray(definition.items)) {
            result.addCheck(this._checkArrayItems(definition, array))
        } else if (definition.items !== undefined) {
            for (const index in array) {
                const item = array[index]
                const check = this._checkType(definition.items, item)
                if (!check.check) {
                    check.setProperty(index)
                }
                result.addCheck(check)
            }
        }
        return result
    }

    /**
     * Checks an object against a swagger defintion
     * @param {Object} data data to check against definition
     * @returns {boolean} true, if the data matches to the definition else false
     */
    validate (data) {
        const check = this._checkType(this.definition, data)
        this.messages = check.messages
        return check.check
    }

    /**
     * Validates the input and throws a message on error
     * @param {Object} data data to check against definition
     * @param {string} [message=''] start of an error message
     */
    throwOnValidationError (data, message = '') {
        if (!this.validate(data)) {
            throw (Error(message + JSON.stringify(this.messages)))
        }
    }
}

module.exports = CheckInput
