/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use scrict'

/**
 * Creates a new input check class
 * Checks a data object according an object definition - used to check input parameters
 * @param {ArrayDefinition | ObjectDefinition | StringDefintion | NumberDefinition} definition swagger like content defintion
 * @example
 * check = new CheckInput({
 *   type: 'object',
 *   properties: {
 *       topic: { type: 'string' },
 *       value: { type: 'string' },
 *   },
 *   required: ['topic', 'value']
 * })
 * // returns true, as the parameter fits to the descriptions
 * check.validate({ topic: '/a/b', value: 'on' })
 *
 * // returns false and fills the error message
 * // check.message is { topic: 'missing property topic', value: 'missing property value' }
 * check.validate ( {} )
 *
 * // Throws an Error, as the validation does not fits to the description
 * check.throwOnValidationError({ topic: '/a/b' })
 *
 * // Prints the error message
 * console.log(check.message)
 */
module.exports = class CheckInput {
    constructor (definition) {
        this.definition = definition
        this.messages = undefined
    }

    /**
     * Gets the list of error messages
     * @returns {object} error messages {topic: message, topic: message, ...}
     */
    get messages () { return this._messages }
    set messages (messages) { this._messages = messages }

    /**
     * @private
     * Checks a boolean variable
     * @param {boolean} variable input data
     * @returns {true | string} true, if the variable is correct, else an error message
     */
    static checkBoolean (variable) {
        let result = true
        if (variable !== true && variable !== false) {
            result = ("'" + variable + "' is not boolean")
        }
        return result
    }

    /**
     * @private
     * Checks a number variable against a defintion
     * @param {object} definition number definition
     * @param {string} variable input data
     * @returns {true | string} true, if the variable is correct, else an error message
     */
    static checkNumber (definition, variable) {
        let result = true
        if (typeof (variable) === 'string' && !isNaN(variable)) {
            variable = parseFloat(variable)
        }
        if (typeof (variable) !== 'number') {
            result = (JSON.stringify(variable) + ' is not a number')
        } else if (definition.minimum !== undefined && variable < definition.minimum) {
            result = (variable + ' below ' + definition.minimum)
        } else if (definition.maximum !== undefined && variable > definition.maximum) {
            result = (variable + ' above ' + definition.maximum)
        }
        return result
    }

    /**
     * @private
     * Checks a string format
     * @param {string} format string format description
     * @param {string} variable variable to check
     * @returns {true | string} true, if the variable matches the format, else an error message
     */
    static checkStringFormat (format, variable) {
        let result = true
        switch (format) {
        case 'date': result = variable.match(/^\d{4}-\d{2}-\d{2}$/) !== null; break
        case 'date-time': result = variable.match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(.\d{3})?(Z|[+-]\d{2}:\d{2})$/) !== null; break
        }
        if (result === false) {
            result = "'" + variable + "' is not a " + format
        }
        return result
    }

    /**
     * @private
     * Checks a string variable against a defintion
     * @param {object} definition string definition
     * @param {string} variable input data
     * @returns {true | string} true, if the variable is correct, else an error message
     */
    static checkString (definition, variable) {
        let result = true
        if (typeof (variable) !== 'string') {
            result = "'" + JSON.stringify(variable) + "' is not a string"
        } else if (definition.minLength !== undefined && variable.length < definition.minLength) {
            result = "'" + variable + "' minimum length " + definition.minLength + ' not reached'
        } else if (definition.maxLength !== undefined && variable.length > definition.maxLength) {
            result = "'" + variable + "'  maximum length " + definition.maxLength + ' exceeded'
        } else if (definition.format !== undefined) {
            result = CheckInput.checkStringFormat(definition.format, variable)
        }
        return result
    }

    /**
     * @private
     * Checks a variable against an array of definitions, returns true, if it matches exactly one
     * @param {object} definitions variable definition
     * @param {any} variable input data
     * @returns {true | string} true, if it matches exactly one of the definitions, else an error message
     */
    static anyOf (definitions, variable) {
        let result = []
        for (const definition of definitions) {
            const current = CheckInput.checkType(definition, variable)
            if (current === true) {
                result = true
                break
            } else {
                result.push(current)
            }
        }
        if (result !== true) {
            result = { 'anyOf - no rule matches': result }
        }
        return result
    }

    /**
     * @private
     * Checks a variable against a defintion
     * @param {object} definition variable definition
     * @param {any} variable input data
     * @returns {true | string} true, if the variable matches the definition, else an error message
     */
    static checkType (definition, variable) {
        let result = true
        if (definition.oneOf !== undefined) {
            result = CheckInput.oneOf(definition.oneOf, variable)
        } else if (definition.anyOf !== undefined) {
            result = CheckInput.anyOf(definition.anyOf, variable)
        } else if (definition.allOf !== undefined) {
            result = CheckInput.allOf(definition.allOf, variable)
        } else {
            switch (definition.type) {
            case 'string': result = CheckInput.checkString(definition, variable); break
            case 'number': result = CheckInput.checkNumber(definition, variable); break
            case 'array': result = CheckInput.checkArray(definition, variable); break
            case 'object': result = CheckInput.checkObject(definition, variable); break
            case 'boolean': result = CheckInput.checkBoolean(variable); break
            }
        }
        return result
    }

    /**
     * @private
     * Adds an error message to the result structure
     * @param {true|object} result current result structure
     * @param {string} property property name
     * @param {string} message error message
     * @returns {object} new error message object
     */
    static addErrormessageToResult (result, property, message) {
        if (typeof (result) !== 'object') {
            result = {}
        }
        result[property] = message
        return result
    }

    /**
     * @private
     * Checks if required elements are available
     * @param {array} required array of required properties
     * @param {object} object input data
     * @returns {boolean | object} true, if the object has all required properties else object of error messages
     */
    static checkRequired (required, object) {
        let result = true
        if (required !== undefined) {
            for (const property of required) {
                if (object[property] === undefined) {
                    result = CheckInput.addErrormessageToResult(result, property, 'missing property')
                }
            }
        }
        return result
    }

    /**
     * @private
     * Checks if all properties matches the property definitions
     * @param {object} propertyDefintions list of property definitions
     * @param {object} object input data
     * @returns {true | object} true, if the all properties matches else object of error messages
     */
    static checkProperties (propertyDefintions, object) {
        let result = true
        if (propertyDefintions !== undefined) {
            for (const property in propertyDefintions) {
                if (object[property] !== undefined) {
                    const check = CheckInput.checkType(propertyDefintions[property], object[property])
                    if (check !== true) {
                        result = CheckInput.addErrormessageToResult(result, property, check)
                    }
                }
            }
        }
        return result
    }

    /**
     * @private
     * Checks if an object requires strict property check and if so, that there are no properties
     * available not defined in the definition
     * @param {ObjectDefinition} definition object definition
     * @param {object} object input data
     * @returns {true | object} true, if the object matches the definition else object of error messages
     */
    static checkStrict (definition, object) {
        let result = true
        if (definition.strict === true) {
            for (const property in object) {
                if (definition.properties[property] === undefined) {
                    result = CheckInput.addErrormessageToResult(result, property, 'unknown property, misspelled?')
                }
            }
        }
        return result
    }

    /**
     * @private
     * Checks an object against a definition
     * @param {ObjectDefinition} definition object definition
     * @param {object} object input data
     * @returns {true | object} true, if the object matches the definition else object of error messages
     */
    static checkObject (definition, object) {
        let result = true
        if (typeof (object) !== 'object') {
            result = 'object expected'
        } else {
            const required = CheckInput.checkRequired(definition.required, object)
            const properties = CheckInput.checkProperties(definition.properties, object)
            const strict = CheckInput.checkStrict(definition, object)
            if (required !== true || properties !== true || strict !== true) {
                result = {}
                if (required !== true) {
                    result = required
                }
                if (properties !== true) {
                    result = { ...result, ...properties }
                }
                if (strict !== true) {
                    result = { ...result, ...strict }
                }
            }
        }
        return result
    }

    /**
     * @private
     * Checks an array against a definition
     * @param {ArrayDefinition} definition array definition
     * @param {array} array input data
     * @returns {true | object} true, if the all properties matches else object of error messages
     */
    static checkArray (definition, array) {
        let result = true
        if (!Array.isArray(array)) {
            result = 'array expected'
        } else if (definition.minItems !== undefined && array.length < definition.minItems) {
            result = ' array must have at least ' + definition.minItems + ' elements'
        } else if (definition.maxItems !== undefined && array.length <= definition.maxItems) {
            result = ' array may not have more than ' + definition.maxItems + ' elements'
        } else {
            for (const index in array) {
                const item = array[index]
                const check = CheckInput.checkType(definition.items, item)
                if (check !== true) {
                    result = CheckInput.addErrormessageToResult(result, index, check)
                }
            }
        }
        return result
    }

    /**
     * Checks an object against a swagger defintion
     * @param {object} data data to check against definition
     * @returns {boolean} true, if the data matches to the definition else false
     */
    validate (data) {
        let result
        const check = CheckInput.checkType(this.definition, data)
        if (check === true) {
            result = true
            this.messages = ''
        } else {
            result = false
            this.messages = check
        }
        return result
    }

    /**
     * Validates the input and throws a message on error
     * @param {object} data data to check against definition
     * @param {string} [message=''] start of an error message
     */
    throwOnValidationError (data, message = '') {
        if (!this.validate(data)) {
            throw (Error(message + JSON.stringify(this.messages)))
        }
    }
}

/**
 * @typedef {object} ArrayDefinition
 * @property {'array'} type indicates that the type is an array
 * @property {number} [minItems] minimum amount of array items
 * @property {number} [maxItems] maximum amount of array items
 * @property {object} [items] description of the items for an array data type
 */

/**
 * @typedef {object} ObjectDefinition
 * @property {'object'} type indicates that the type is an onbject
 * @property {object} [properties] property definitions
 * @property {string[]} [required] list of required properties for objects
 * @property {boolean} [strict] true, if undefined properties are not allowed
 */

/**
 * @typedef {object} StringDefinition
 * @property {'string'} type indicates that the type is an onbject
 * @property {number} [minLength] minimal string length
 * @property {number} [maxLenght] maximal string length
 * @property {string} [format] (currently supported 'date' and 'date-time') format defintion
 */

/**
 * @typedef {object} NumberDefinition
 * @property {'number'} type indicates that the type is an onbject
 * @property {number} [minimum] minimal allowed value
 * @property {number} [maximum] maximal allowed value
 */
