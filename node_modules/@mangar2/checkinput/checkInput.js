/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview JSON schema validator matching standard version 0.7
 */

'use scrict'

const types = require('@mangar2/types')
const deepEqualRec = require('./deepequal')
const CheckResult = require('./checkresult')
const { checkBoolean, checkTrueFalse, checkNumber } = require('./checkbasictypes')
const checkString = require('./checkstring')
const checkType = require('./checktype')
const checkObject = require('./checkobject')
const checkArray = require('./checkArray')
const resolveRef = require('./resolveref')

/**
 * Creates a new JSON Schema validation class to validate a data object according to a JSON Schema.
 * Many thanks to epoberezkin/JSON-Schema-Test-Suite for providing a cool test suite.
 * I use it to check my implementation
 * This is not (yet) a complete implementation. The following tests are not running yet:
 * - remote-refs (neither local nor remote)
 * - unicode-code-points (EmacsScript length is used to get the lengt of  a string)
 * - propertyNames
 * definitions
 * @param {Any} definition JSON schema definition
 * @param {Object} options schema validation options
 * @param {boolean} [options.deepUnique=true] if true, the content is checked deeply. For example different objects with the same
 * @param {boolean} [options.stringToNumber=false] if true, strings containing numbers are automatically  converted
 * @example
 * check = new CheckInput({
 *   type: 'object',
 *   properties: {
 *       topic: { type: 'string' },
 *       value: { type: 'string' },
 *   },
 *   required: ['topic', 'value']
 * })
 * // returns true, as the parameter fits to the descriptions
 * check.validate({ topic: '/a/b', value: 'on' })
 *
 * // returns false and fills the error message
 * // check.message is { topic: 'missing property topic', value: 'missing property value' }
 * check.validate ( {} )
 *
 * // Throws an Error, as the validation does not fits to the description
 * check.throwOnValidationError({ topic: '/a/b' })
 *
 * // Prints the error message
 * console.log(check.messages)
 */
class CheckInput {
    constructor (definition, options = {}) {
        this.definition = definition
        this.messages = undefined
        this._options = options
        this._checkSubschema = (subDef, variable) => {
            return this._checkSchema(subDef, variable)
        }
    }

    /**
     * @description Gets the list of error messages
     * @type {Object|string} error message tree
     */
    get messages () { return this._messages }
    set messages (messages) { this._messages = messages }

    /**
     * @private
     * @description Checks if two objects are equal
     * @param {any} definition first object
     * @param {any} variable input data
     * @returns {CheckResult} result of the check
     */
    _isEqual (definition, variable) {
        const result = deepEqualRec(definition, variable)
        return result
    }

    /**
     * @private
     * @description Checks if two objects are equal
     * @param {Array} definition enum definition array
     * @param {any} variable input data
     * @returns {CheckResult} result of the check
     */
    _checkEnum (definition, variable) {
        let result = new CheckResult(false)
        if (types.isArray(definition)) {
            for (const element of definition) {
                const cur = this._isEqual(element, variable)
                if (cur.check) {
                    result = cur
                    break
                }
            }
        }
        if (result.check === false) {
            result.invalidate('"' + variable + '" does not match ' +
                JSON.stringify(definition))
        }
        return result
    }

    /**
     * @private
     * @description Checks an if then else construct
     * @param {Object} definition definition of the Schema
     * @param {Object} definition.if if part
     * @param {Object} definition.then then part
     * @param {Object} definition.else else part
     * @param {any} variable input data
     * @returns {CheckResult} result of the check
     */
    _checkIfThenElse (definition, variable) {
        const ifCheck = this._checkSchema(definition.if, variable)
        let result = new CheckResult(true)
        if (ifCheck.check === true && definition.then !== undefined) {
            result = this._checkSchema(definition.then, variable)
        } else if (ifCheck.check === false && definition.else !== undefined) {
            result = this._checkSchema(definition.else, variable)
        }
        return result
    }

    /**
     * @private
     * @description Checks a variable against an array of definitions, returns true, if it matches any
     * @param {Object} definitions variable definition
     * @param {any} variable input data
     * @returns {CheckResult} result of the check
     */
    _anyOf (definitions, variable) {
        const result = new CheckResult(false)
        for (const index in definitions) {
            const definition = definitions[index]
            const current = this._checkSchema(definition, variable)
            current.setProperty(index)
            result.addAlternative(current)
        }
        if (!result.check) {
            result.setProperty('anyOf')
        }
        return result
    }

    /**
     * @private
     * @description Checks a variable against an array of definitions, returns true, if it matches all
     * @param {Object} definitions variable definition
     * @param {any} variable input data
     * @returns {CheckResult} result of the check
     */
    _allOf (definitions, variable) {
        const result = new CheckResult(true)
        for (const definition of definitions) {
            const current = this._checkSchema(definition, variable)
            result.addCheck(current)
        }
        if (!result.check) {
            result.setProperty('allOf')
        }
        return result
    }

    /**
     * @private
     * @description Checks a variable against an array of definitions, returns true, if it matches exactly one
     * @param {Object} definitions variable definition
     * @param {any} variable input data
     * @returns {CheckResult} result of the check
     */
    _oneOf (definitions, variable) {
        const result = new CheckResult(false)
        for (const definition of definitions) {
            const current = this._checkSchema(definition, variable)
            if (result.check === true && current.check === true) {
                result.invalidate(' matches more than one ')
                break
            } else {
                result.addAlternative(current)
            }
        }
        if (!result.check) {
            result.setProperty('oneOf')
        }
        return result
    }

    /**
     * @private
     * @description Checks the "commands" of the JSON schema definition (oneOf, const, enum, ...)
     * @param {Object} definition variable defintion
     * @param {any} variable input data
     */
    _checkCommands (definition, variable) {
        const result = new CheckResult(true)
        if (definition.oneOf !== undefined) {
            result.addCheck(this._oneOf(definition.oneOf, variable))
        }
        if (definition.anyOf !== undefined) {
            result.addCheck(this._anyOf(definition.anyOf, variable))
        }
        if (definition.allOf !== undefined) {
            result.addCheck(this._allOf(definition.allOf, variable))
        }
        if (definition.const !== undefined) {
            result.addCheck(this._isEqual(definition.const, variable))
        }
        if (definition.enum !== undefined) {
            result.addCheck(this._checkEnum(definition.enum, variable))
        }
        if (definition.if !== undefined) {
            result.addCheck(this._checkIfThenElse(definition, variable))
        }
        if (definition.not !== undefined) {
            const curResult = this._checkSchema(definition.not, variable)
            if (curResult.check) {
                result.invalidate(' element must not match the schema ')
            }
        }
        return result
    }

    /**
     * @private
     * @description Checks a variable against the base schema of the definition
     * @param {Object} definition variable definition
     * @param {any} variable input data
     * @returns {CheckResult} result of the check with 'check' and 'message'
     */
    _checkBaseSchema (definition, variable) {
        const result = new CheckResult(true)
        if (types.isString(variable)) {
            result.addCheck(checkString(definition, variable))
        } else if (types.isNumber(variable)) {
            result.addCheck(checkNumber(definition, variable))
        } else if (types.isArray(variable)) {
            result.addCheck(checkArray(definition, variable, this._checkSubschema, this._options.deepUnique))
        } else if (types.isObject(variable)) {
            result.addCheck(checkObject(definition, variable, this._checkSubschema))
        } else if (types.isBoolean(variable)) {
            result.addCheck(checkBoolean(variable))
        }
        return result
    }

    /**
     * @private
     * @description Checks a variable against a defintion
     * @param {Object} definition variable definition
     * @param {any} variable input data
     * @returns {CheckResult} result of the check with 'check' and 'message'
     */
    _checkSchema (definition, variable) {
        let result = new CheckResult(true)
        if (types.isBoolean(definition)) {
            result = checkTrueFalse(definition)
            return result
        }
        if (definition.$ref !== undefined) {
            const refDefinition = resolveRef(definition.$ref, this.definition)
            if (refDefinition === undefined) {
                result.invalidate('reference ' + definition.$ref + ' not found')
                return result
            }
            result = this._checkSchema(refDefinition, variable)
            return result
        }
        if (definition.default !== undefined && variable === undefined) {
            variable = definition.default
        }
        if (this._options.stringToNumber && definition.type === 'number' && types.isString(variable) && !isNaN(variable)) {
            variable = Number(variable)
        }
        result.addCheck(checkType(definition, variable))
        result.addCheck(this._checkBaseSchema(definition, variable))
        result.addCheck(this._checkCommands(definition, variable))
        return result
    }

    /**
     * @description Checks an object against a swagger defintion
     * @param {Object} data data to check against definition
     * @returns {boolean} true, if the data matches to the definition else false
     */
    validate (data) {
        const check = this._checkSchema(this.definition, data)
        this.messages = check.messages
        return check.check
    }

    /**
     * @description Validates the input and throws a message on error
     * @param {Object} data data to check against definition
     * @param {string} [message=''] starting string of the error message
     */
    throwOnValidationError (data, message = '') {
        if (!this.validate(data)) {
            throw (Error(message + JSON.stringify(this.messages)))
        }
    }
}

module.exports = CheckInput
