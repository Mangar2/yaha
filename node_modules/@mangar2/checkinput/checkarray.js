/**
 * @private
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use scrict'

const types = require('@mangar2/types')
const deepEqualRec = require('./deepequal')
const CheckResult = require('./checkresult')

/**
 * @private
 * Checks if an array does not contain any element twice.
 * @param {Array} data the array to test
 * @param {boolean} [deepUnique=true] if true, the content is checked deeply. For example different objects with the same
 * content are then concidered as equal. If false, it only tests the object reference.
 */
function isUniqueArray (data, deepUnique) {
    let result = true
    if (deepUnique === false) {
        result = (new Set(data)).size === data.length
    } else {
        for (let outer = 0; outer < data.length; outer++) {
            for (let inner = outer + 1; inner < data.length; inner++) {
                const checkResult = deepEqualRec(data[outer], data[inner], '')
                if (checkResult.check === true) {
                    result = false
                    break
                }
            }
            if (result === false) {
                break
            }
        }
    }
    return result
}

/**
 * @private
 * Checks array data to the constrains of an array defintion
 * @param {Object} definition array schema definition
 * @param {Array} data array data
 * @param {boolean} [deepUnique=true] if true, the content is checked deeply. For example different objects with the same
 */
function checkArrayConstrains (definition, data, deepUnique) {
    const result = new CheckResult(true)
    if (definition.minItems !== undefined && data.length < definition.minItems) {
        result.invalidate(' array must have at least ' + definition.minItems + ' elements')
    }
    if (definition.maxItems !== undefined && data.length > definition.maxItems) {
        result.invalidate(' array may not have more than ' + definition.maxItems + ' elements')
    }
    if (definition.uniqueItems === true && !isUniqueArray(data, deepUnique)) {
        result.invalidate(' array items must be unique ')
    }
    return result
}

/**
  * @private
  * Checks if an array contains elements
  * @param {Object} definition contains definition
  * @param {Array} array input data
  * @param {function} checkSubschema (definition, data)
  * @returns {CheckResult} result of the check with 'check' and 'message'
  */
function checkContains (definition, array, checkSubschema) {
    const result = new CheckResult(false)
    for (const element of array) {
        result.addAlternative(checkSubschema(definition, element))
    }
    if (result.check === false) {
        result.invalidate('no array element validates to the definition')
    }
    return result
}

/**
  * @private
  * Checks the items of an array having an items property of type Array
  * @param {Object} definition array definition
  * @param {Array} definition.items items defintion
  * @param {Object} [definition.additionalItems] definition for additional items
  * @param {Array} array of items
  * @param {function} checkSubschema (definition, data)
  * @returns {CheckResult} result of the check with 'check' and 'message'
  */
function checkArrayItems (definition, array, checkSubschema) {
    const result = new CheckResult(true)
    for (const index in array) {
        const item = array[index]
        const defItem = definition.items[index]
        let check
        if (defItem !== undefined) {
            check = checkSubschema(defItem, item)
        } else if (definition.additionalItems !== undefined) {
            check = checkSubschema(definition.additionalItems, item)
        } else {
            break
        }
        if (!check.check) {
            check.setProperty(index)
        }
        result.addCheck(check)
    }
    return result
}

/**
  * @private
  * Checks an array against a definition
  * @param {Object} definition array definition
  * @param {Array} array input data
  * @param {function} checkSubschema (definition, data)
  * @param {boolean} deepUnique true, if the unique check compares the whole structure of Objects
  * @returns {CheckResult} result of the check with 'check' and 'message'
  */
function checkArray (definition, array, checkSubschema, deepUnique) {
    const result = new CheckResult(true)
    result.addCheck(checkArrayConstrains(definition, array, deepUnique))
    if (definition.contains !== undefined) {
        result.addCheck(checkContains(definition.contains, array, checkSubschema))
    }
    if (types.isArray(definition.items)) {
        result.addCheck(checkArrayItems(definition, array, checkSubschema))
    } else if (definition.items !== undefined) {
        for (const index in array) {
            const item = array[index]
            const check = checkSubschema(definition.items, item)
            if (!check.check) {
                check.setProperty(index)
            }
            result.addCheck(check)
        }
    }
    return result
}

module.exports = checkArray
