/**
 * @private
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use scrict'

const types = require('@mangar2/types')
const CheckResult = require('./checkresult')

/**
 * @private
 * Checks if required elements are available
 * @param {Array} required array of required properties
 * @param {Object} object input data
 * @returns {CheckResult} result of the check with 'check' and 'message'
 */
function checkRequiredProperties (required, object) {
    const result = new CheckResult(true)
    if (required !== undefined) {
        for (const property of required) {
            if (object[property] === undefined) {
                result.invalidate('missing property ', property)
            }
        }
    }
    return result
}

/**
 * @private
 * Checks an object for its basc constrains
 * @param {Object} definition object schema definition
 * @param {Object} object object data
 */
function checkObjectConstrains (definition, object) {
    const result = new CheckResult(true)
    if (definition.minProperties !== undefined && Object.keys(object).length < definition.minProperties) {
        result.invalidate(' object must have at least ' + definition.minItems + ' properties')
    }
    if (definition.maxProperties !== undefined && Object.keys(object).length > definition.maxProperties) {
        result.invalidate(' object may not have more than ' + definition.maxItems + ' properties')
    }
    return result
}

/**
 * @private
 * Checks if an object has all properties
 * @param {Array} propertyList list of property strings
 * @param {Object} object object to check
 */
function _hasAllProperties (propertyList, object) {
    const result = new CheckResult(true)
    if (types.isArray(propertyList)) {
        for (const property of propertyList) {
            if (object[property] === undefined) {
                result.invalidate('missing dependent property: ' + property)
            }
        }
    }
    return result
}

/**
 * @private
 * Checks a simple dependency structure having an array of dependent property per property
 * @param {Object} dependencies dependency definition
 * @param {Object} object data object
 * @param {function} checkSubschema (definition, data)
 */
function checkDependency (dependencies, object, checkSubschema) {
    const result = new CheckResult(true)
    if (types.isObject(dependencies)) {
        for (const property in dependencies) {
            const dependencyDefinition = dependencies[property]
            if (object[property] !== undefined) {
                let check = _hasAllProperties(dependencyDefinition, object)
                result.addCheck(check)
                check = checkSubschema(dependencyDefinition, object)
                result.addCheck(check)
            }
        }
    }
    return result
}

/**
 * @private
 * Checks the type of additional (non defined) properties
 * @param {ObjectDefinition} definition object definition
 * @param {any} object input data
 * @param {function} checkSubschema (definition, data)
 * @returns {CheckResult} result of the check with 'check' and 'message'
 */
function checkAdditionalProperties (definition, object, checkSubschema) {
    let result = new CheckResult(true)
    if (definition === false) {
        result.invalidate('unknown property, misspelled?')
    } else if (types.isObject(definition)) {
        result = checkSubschema(definition, object)
    }
    return result
}

/**
 * @private
 * Checks if properties matching a pattern have the right type
 * available not defined in the definition
 * @param {Object} patternProperties list of pattern based check rules for properties
 * @param {Object} object input data
 * @param {string} propertyName property to check
 * @param {function} checkSubschema (definition, data)
 * @returns {CheckResult} result of the check with 'check' and 'message'
 */
function checkPatternProperties (patternProperties, object, propertyName, checkSubschema) {
    let result = new CheckResult(undefined)
    for (const pattern in patternProperties) {
        const regExp = new RegExp(pattern)
        if (regExp.test(propertyName)) {
            result = checkSubschema(patternProperties[pattern], object)
            result.setProperty(propertyName)
        }
    }
    return result
}

/**
 * @private
 * Checks if all properties matches the property definitions
 * @param {Object} definition object defition
 * @param {Object} object input data
 * @param {function} checkSubschema (definition, data)
 * @returns {CheckResult} result of the check with 'check' and 'message'
 */
function checkProperties (definition, object, checkSubschema) {
    const result = new CheckResult(true)
    const propertyDef = types.isObject(definition.properties) ? definition.properties : false
    const patternProperty = types.isObject(definition.patternProperties) ? definition.patternProperties : false
    const additionalPropery = definition.additionalProperties
    for (const propertyName in object) {
        let checked = false
        if (propertyDef && propertyDef[propertyName] !== undefined) {
            result.addCheck(checkSubschema(propertyDef[propertyName], object[propertyName]), propertyName)
            checked = true
        }
        if (patternProperty) {
            const curResult = checkPatternProperties(patternProperty, object[propertyName], propertyName, checkSubschema)
            result.addCheck(curResult)
            if (curResult.check !== undefined) {
                checked = true
            }
        }
        if (!checked && additionalPropery !== undefined) {
            result.addCheck(checkAdditionalProperties(additionalPropery, object[propertyName], checkSubschema), propertyName)
        }
    }
    return result
}

/**
 * @private
 * Checks an object against a definition
 * @param {ObjectDefinition} definition object definition
 * @param {Object} object input data
 * @param {function} checkSubschema (definition, data)
 * @returns {CheckResult} result of the check with 'check' and 'message'
 */
function checkObject (definition, object, checkSubschema) {
    const result = new CheckResult(true)
    result.addCheck(checkObjectConstrains(definition, object))
    result.addCheck(checkDependency(definition.dependencies, object, checkSubschema))
    result.addCheck(checkProperties(definition, object, checkSubschema))
    result.addCheck(checkRequiredProperties(definition.required, object))
    return result
}

module.exports = checkObject
