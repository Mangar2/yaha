/**
 * @private
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use scrict'

const types = require('@mangar2/types')
const CheckResult = require('./checkresult')

/**
 * @private
 * @description Checks if required elements are available
 * @param {Array} required array of required properties
 * @param {Object} object input data
 * @returns {CheckResult} result of the check with 'check' and 'message'
 */
function _checkRequiredProperties (required, object) {
    const result = new CheckResult(true)
    if (required !== undefined) {
        for (const property of required) {
            if (object[property] === undefined) {
                result.invalidate('missing property ', property)
            }
        }
    }
    return result
}

/**
 * @private
 * @description Checks an object for its basc constrains
 * @param {Object} definition object schema definition
 * @param {Object} object object data
 */
function _checkObjectConstrains (definition, object) {
    const result = new CheckResult(true)
    if (definition.minProperties !== undefined && Object.keys(object).length < definition.minProperties) {
        result.invalidate(' object must have at least ' + definition.minItems + ' properties')
    }
    if (definition.maxProperties !== undefined && Object.keys(object).length > definition.maxProperties) {
        result.invalidate(' object may not have more than ' + definition.maxItems + ' properties')
    }
    return result
}

/**
 * @private
 * @description Checks if an object has all properties
 * @param {Array} propertyList list of property strings
 * @param {Object} object object to check
 */
function _hasAllProperties (propertyList, object) {
    const result = new CheckResult(true)
    if (types.isArray(propertyList)) {
        for (const property of propertyList) {
            if (object[property] === undefined) {
                result.invalidate('missing dependent property: ' + property)
            }
        }
    }
    return result
}

/**
 * @private
 * @description Checks a simple dependency structure having an array of dependent property per property
 * @param {Object} dependencies dependency definition
 * @param {Object} object data object
 * @param {function} checkSubschema (definition, data)
 */
function _checkDependency (dependencies, object, checkSubschema) {
    const result = new CheckResult(true)
    if (types.isObject(dependencies)) {
        for (const property in dependencies) {
            const dependencyDefinition = dependencies[property]
            if (object[property] !== undefined) {
                let check = _hasAllProperties(dependencyDefinition, object)
                result.addCheck(check)
                check = checkSubschema(dependencyDefinition, object)
                result.addCheck(check)
            }
        }
    }
    return result
}

/**
 * @private
 * @description Checks the type of additional (non defined) properties
 * @param {ObjectDefinition} definition object definition
 * @param {any} object input data
 * @param {function} checkSubschema (definition, data)
 * @returns {CheckResult} result of the check with 'check' and 'message'
 */
function _checkAdditionalProperties (definition, object, checkSubschema) {
    let result = new CheckResult(true)
    if (definition === false) {
        result.invalidate('unknown property, misspelled?')
    } else if (types.isObject(definition)) {
        result = checkSubschema(definition, object)
    }
    return result
}

/**
 * @private
 * @description Checks if properties matching a pattern have the right type
 * available not defined in the definition
 * @param {Object} patternProperties list of pattern based check rules for properties
 * @param {Object} object input data
 * @param {string} propertyName property to check
 * @param {function} checkSubschema (definition, data)
 * @returns {CheckResult} result of the check with 'check' and 'message'
 */
function _checkPatternProperties (patternProperties, object, propertyName, checkSubschema) {
    let result = new CheckResult(undefined)
    for (const pattern in patternProperties) {
        const regExp = new RegExp(pattern)
        if (regExp.test(propertyName)) {
            result = checkSubschema(patternProperties[pattern], object)
            result.setProperty(propertyName)
        }
    }
    return result
}

/**
 * @private
 * @description Checks if all properties matches the property definitions
 * @param {Object} definition object defition
 * @param {Object} object input data
 * @param {function} checkSubschema (definition, data)
 * @returns {CheckResult} result of the check with 'check' and 'message'
 */
function _checkProperties (definition, object, checkSubschema) {
    const result = new CheckResult(true)
    const propertyDef = types.isObject(definition.properties) ? definition.properties : {}
    const patternProperty = types.isObject(definition.patternProperties) ? definition.patternProperties : false
    const additionalProperties = definition.additionalProperties
    if (propertyDef || patternProperty || additionalProperties !== undefined) {
        for (const propertyName in object) {
            const propertyObject = object[propertyName]
            let checked = false
            if (propertyDef[propertyName] !== undefined) {
                result.addCheck(checkSubschema(propertyDef[propertyName], propertyObject), propertyName)
                checked = true
            }
            if (patternProperty) {
                const curResult = _checkPatternProperties(patternProperty, propertyObject, propertyName, checkSubschema)
                result.addCheck(curResult)
                if (curResult.check !== undefined) {
                    checked = true
                }
            }
            if (!checked && additionalProperties !== undefined) {
                result.addCheck(_checkAdditionalProperties(additionalProperties, propertyObject, checkSubschema), propertyName)
            }
        }
    }
    return result
}

/**
 * Checks the property names
 * @param {Object} definition property names schema definition
 * @param {Object} object object to check
 * @param {function} checkSubschema (definition, data)
 * @returns {CheckResult} result of the check with 'check' and 'message'
 */
function _checkPropertyNames (definition, object, checkSubschema) {
    const result = new CheckResult(true)
    if (definition !== undefined) {
        for (const property in object) {
            result.addCheck(checkSubschema(definition, property), property)
        }
    }
    return result
}

/**
 * @private
 * @description Checks an object against a definition
 * @param {ObjectDefinition} definition object definition
 * @param {Object} object input data
 * @param {function} checkSubschema (definition, data)
 * @returns {CheckResult} result of the check with 'check' and 'message'
 */
function checkObject (definition, object, checkSubschema) {
    const result = new CheckResult(true)
    result.addCheck(_checkPropertyNames(definition.propertyNames, object, checkSubschema))
    result.addCheck(_checkObjectConstrains(definition, object))
    result.addCheck(_checkDependency(definition.dependencies, object, checkSubschema))
    result.addCheck(_checkProperties(definition, object, checkSubschema))
    result.addCheck(_checkRequiredProperties(definition.required, object))
    return result
}

module.exports = checkObject
