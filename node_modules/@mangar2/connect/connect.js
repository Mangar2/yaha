/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      connect.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

'use strict'

const HttpClient = require('@mangar2/httpclient')
const mqttVersion = require('@mangar2/mqttversion')
const Callbacks = require('@mangar2/callbacks')
const os = require('os')

/**
 * Gets the IP v4 address of the current device
 * @returns {string} IP v4 address
 */
function getIPv4Address () {
    const networkInterfaces = os.networkInterfaces()
    let address
    for (const network in networkInterfaces) {
        const networkInterface = networkInterfaces[network]
        networkInterface.forEach(function (info) {
            if (info.family === 'IPv4' && info.internal === false) {
                address = info.address
            }
        })
    }
    return address
}

module.exports = class Connect {
    /**
     * Organises connections to broker
     * @param {string} clientId id of this client
     * @param {string} brokerHost hostname (or ip) of the broker
     * @param {number} brokerPort port of the broker
     * @param {number} listenerPort port to listen for published messages from broker
     */
    constructor (clientId, brokerHost, brokerPort, listenerPort) {
        this._clientId = clientId
        this._listenerPort = listenerPort
        this._myAddress = getIPv4Address()
        this.isConnected = false
        this.client = new HttpClient(brokerHost, brokerPort)
        this._nextPacketId = 1
        this._callbacks = new Callbacks()

        this.on('send', async (path, httpMethod, payload, headers) => {
            return this.client.send(path, httpMethod, payload, headers)
        })
    }

    /**
     * @type {boolean} true, if the client is connected
     */
    get isConnected () { return this._isConnected }
    set isConnected (isConnected) { this._isConnected = isConnected }

    /**
     * Sets a callback.
     * @param {string} event event name (not case sensitive) for the callback
     * @param {function} callback(parameter)
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on (event, callback) { this._callbacks.on(event, callback) }

    /**
     * provides a new packet id
     * @returns {number} "nearly unique" packet id (between 0 .. 65536)
     */
    _providePacketId () {
        const packetid = this._nextPacketId
        this._nextPacketId++
        this._nextPacketId %= 0x10000
        if (this._nextPacketId === 0) {
            this._nextPacketId = 1
        }
        return packetid
    }

    /**
     * Sends an object via put as application/json message
     * @param {string} path path for the http PUT
     * @param {object} payload data to be transported via. PUT
     */
    async send (path, headers, payload) {
        if (headers['content-type'] === undefined) {
            headers['content-type'] = 'application/json'
        }
        return this._callbacks.invokeCallbackAsync('send', path, 'put', payload, headers)
    }

    /**
     * Connects to the broker
     * @param {boolean} clean true, if a disconnect shall clean any connection information
     * @param {string|undefined} version client interface version, 0.0 or 1.0, default = 1.0
     */
    async connect (clean, version = '1.0') {
        const httpObjects = mqttVersion.connect(version, this._clientId, this._myAddress, this._listenerPort, clean)
        const result = await this.send('/connect', httpObjects.headers, httpObjects.payload)

        if (!httpObjects.resultCheck(result)) {
            throw (Error('Unable to connect status code: ' + result.statusCode + ' ' + JSON.stringify(result.headers)))
        }

        this.isConnected = true
        if (result.headers['content-type'].startsWith('application/json')) {
            result.payload = JSON.parse(result.payload)
        }
        return result.payload
    }

    /**
     * Disconnects from the broker
     * @param {string | undefined} version interface version (0.0 or 1.0, default is 1.0)
     */
    async disconnect (version = '1.0') {
        const httpObjects = mqttVersion.disconnect(version, this._clientId)
        const result = await this.send('/disconnect', httpObjects.headers, httpObjects.payload)

        if (!httpObjects.resultCheck(result)) {
            throw (Error('Unable to disconnect status code: ' + result.statusCode))
        }

        this._isConnected = false
        return {}
    }

    /**
     * Subscribe to the broker
     * @param {object} topics topics to subscribe to {topic1: QoS1, topic2: QoS2, ...}
     * @param {string } version interface version (0.0 or 1.0, default is 1.0)
     */
    async subscribe (topics, version = '1.0') {
        const httpObjects = mqttVersion.subscribe(version, topics, this._clientId, this._providePacketId())

        const result = await this.send('/subscribe', httpObjects.headers, httpObjects.payload)
        const headers = result.headers

        if (!httpObjects.resultCheck(result)) {
            throw (Error('Unable to subscribe status code: ' + result.statusCode + ' headers ' + JSON.stringify(headers)))
        }

        if (result.headers['content-type'].startsWith('application/json')) {
            result.payload = JSON.parse(result.payload)
        }
        return result.payload
    }

    /**
     * Unsubscribes from the broker
     * @param {Array} topics topics to unsubscribe [topic1, topic2, ...]
     * @param {string} version interface version (0.0 or 1.0, default is 1.0)
     */
    async unsubscribe (topics, version = '1.0') {
        const httpObjects = mqttVersion.unsubscribe(version, topics, this._clientId, this._providePacketId())
        const result = await this.send('/unsubscribe', httpObjects.headers, httpObjects.payload)

        if (!httpObjects.resultCheck(result)) {
            throw (Error('Unable to unsubscribe status code: ' + result.statusCode))
        }

        return {}
    }

    /**
     * First connect, then subscribe
     * @param {boolean} clean true, if a disconnect shall clean any connection information
     * @param {object} topics topics to subscribe to {topic1: QoS1, topic2: QoS2, ...}
     * @param {string} version interface version (0.0 or 1.0, default is 1.0)
     */
    async connectAndSubscribe (clean, topics, version = '1.0') {
        let result
        result = await this.connect(clean, version)
        if (this._isConnected) {
            const subscribeResult = await this.subscribe(topics, version)
            result = { ...result, ...subscribeResult }
        }
        return result
    }

    /**
     * Closes the connection to the broker
     * @param {function} callback callback called on broker response
     */
    async close () {
        await this.client.close()
    }
}
