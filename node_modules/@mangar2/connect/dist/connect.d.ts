/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview Provides functions to connect to the (http based) yaha mqtt broker
 */
/**
 * Organises connections to broker
 * This is part of the http based mqtt broker. Use this class to connect/disconnect and subscribe/unsubscribe to the broker
 * All functions are based on async/promises
 */
declare class Connect {
    private _clientId;
    private _listenerPort;
    private _myAddress;
    private _isConnected;
    private client;
    private _nextPacketId;
    private _callbacks;
    private _token?;
    /**
     * @param {string} clientId id of this client
     * @param {string} brokerHost hostname (or ip) of the broker
     * @param {number} brokerPort port of the broker
     * @param {number} listenerPort port to listen for published messages from broker
     * @example
     * let connect = new Connect("/connect/test", "127.0.0.1", 9001, 9002);
     * result = await connect.connect(CLEAN);
     */
    constructor(clientId: string, brokerHost: string, brokerPort: number, listenerPort: number);
    /**
     * True, if the client is connected
     * @type {boolean}
     */
    get isConnected(): boolean;
    set isConnected(isConnected: boolean);
    /**
     * Gets/Sets send and receive token
     * @type {{send:string, receive:string}} token
     */
    get token(): {
        send: string;
        receive: string;
    } | undefined;
    set token(token: {
        send: string;
        receive: string;
    } | undefined);
    /**
     * Sets a callback.
     * @param {string} event event name (not case sensitive) for the callback
     * @param {function} callback(parameter)
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on(event: string, callback: (parameter: any) => void): void;
    /**
     * @private
     * @description
     * provides a new packet id
     * @returns {number} "nearly unique" packet id (between 0 .. 65536)
     */
    private _providePacketId;
    /**
     * @private
     * @description
     * Sends an object via put as application/json message
     * @param {string} path path for the http PUT
     * @param {Object} payload data to be transported via. PUT
     * @returns {Object} received answer
     */
    private _send;
    /**
 * Connects to the broker
 * @param {boolean} clean true, if a disconnect shall clean any connection information
 * @param {string} [version='1.0'] interface version (0.0 or 1.0)
 * @param {number} [keepAlive=600000] time in milliseconds the broker will keep the connection without receiving calls
 * @returns {Object} payload returned from connect request
 */
    connect(clean: boolean, version?: string, keepAlive?: number): Promise<any>;
    /**
     * Disconnects from the broker
     * @param {string} [version='1.0'] interface version (0.0 or 1.0)
     * @returns {Object} empty object
     */
    disconnect(version?: string): Promise<any>;
    /**
     * Subscribe to the broker
     * @param {Object} topics topics to subscribe to {topic1: QoS1, topic2: QoS2, ...}
     * @param {string} [version='1.0'] interface version (0.0 or 1.0)
     * @returns {Object} payload returned from subscribe request
     */
    subscribe(topics: Record<string, number>, version?: string): Promise<any>;
    /**
     * Unsubscribes from the broker
     * @param {Array} topics topics to unsubscribe [topic1, topic2, ...]
     * @param {string} [version='1.0'] interface version (0.0 or 1.0)
     * @returns {Object} empty object
     */
    unsubscribe(topics: string[], version?: string): Promise<any>;
    /**
     * Sends a ping request to signal the client is alive
     * @returns {boolean} true on success
     */
    pingreq(): Promise<boolean>;
    /**
     * First connect, then subscribe
     * @param {boolean} clean true, if a disconnect shall clean any connection information
     * @param {Object} topics topics to subscribe to {topic1: QoS1, topic2: QoS2, ...}
     * @param {string} [version='1.0'] interface version (0.0 or 1.0)
     * @param {number} [keepAlive=600000] time in milliseconds the broker will keep the connection without receiving calls
     * @returns {Object} combined result from connect and subscribe
     */
    connectAndSubscribe(clean: boolean, topics: Record<string, number>, version?: string, keepAlive?: number): Promise<any>;
    /**
     * Closes the connection to the broker
     */
    close(): Promise<void>;
}
export default Connect;
