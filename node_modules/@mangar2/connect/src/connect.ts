/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview Provides functions to connect to the (http based) yaha mqtt broker
 */

'use strict'

import { HttpClient } from '@mangar2/httpservice';
import { Interfaces } from '@mangar2/mqtt-utils';
import { Callbacks } from '@mangar2/utils';
import os from 'os';

/**
 * @private
 * @description
 * Gets the IP v4 address of the current device
 * @returns {string} IP v4 address
 */
function getIPv4Address(): string | undefined {
    const networkInterfaces = os.networkInterfaces();
    if (networkInterfaces === undefined) {
        return undefined;
    }
    let address: string | undefined;
    for (const network in networkInterfaces) {
        const networkInterface = networkInterfaces[network];
        networkInterface.forEach(function (info: { family: string; internal: boolean; address: string | undefined; }) {
            if (info.family === 'IPv4' && info.internal === false) {
                address = info.address;
            }
        });
    }
    return address!;
}

/**
 * Organises connections to broker
 * This is part of the http based mqtt broker. Use this class to connect/disconnect and subscribe/unsubscribe to the broker
 * All functions are based on async/promises
 */
class Connect {
    private _clientId: string;
    private _listenerPort: number;
    private _myAddress: string | undefined;
    private _isConnected: boolean;
    private client: HttpClient;
    private _nextPacketId: number;
    private _callbacks: Callbacks;
    private _token?: { send: string, receive: string };

    /**
     * @param {string} clientId id of this client
     * @param {string} brokerHost hostname (or ip) of the broker
     * @param {number} brokerPort port of the broker
     * @param {number} listenerPort port to listen for published messages from broker
     * @example
     * let connect = new Connect("/connect/test", "127.0.0.1", 9001, 9002);
     * result = await connect.connect(CLEAN);
     */
    constructor(clientId: string, brokerHost: string, brokerPort: number, listenerPort: number) {
        this._clientId = clientId;
        this._listenerPort = listenerPort;
        this._myAddress = getIPv4Address();
        this._isConnected = false;
        this.client = new HttpClient(brokerHost, brokerPort);
        this._nextPacketId = 1;
        this._callbacks = new Callbacks();

        this.on('send', async (path, httpMethod, payload, headers) => {
            const result = await this.client.send(path, httpMethod, payload, headers);
            return result;
        });
    }

    /**
     * True, if the client is connected
     * @type {boolean}
     */
    get isConnected(): boolean { return this._isConnected; }
    set isConnected(isConnected: boolean) { this._isConnected = isConnected; }

    /**
     * Gets/Sets send and receive token
     * @type {{send:string, receive:string}} token
     */
    get token(): { send: string, receive: string } | undefined { return this._token; }
    set token(token: { send: string, receive: string } | undefined) { this._token = token; }

    /**
     * Sets a callback.
     * @param {string} event event name (not case sensitive) for the callback
     * @param {function} callback(parameter)
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on(event: string, callback: (parameter: any) => void): void { this._callbacks.on(event, callback); }

    /**
     * @private
     * @description
     * provides a new packet id
     * @returns {number} "nearly unique" packet id (between 0 .. 65536)
     */
    private _providePacketId(): number {
        const packetid = this._nextPacketId;
        this._nextPacketId++;
        this._nextPacketId %= 0x10000;
        if (this._nextPacketId === 0) {
            this._nextPacketId = 1;
        }
        return packetid;
    }

    /**
     * @private
     * @description
     * Sends an object via put as application/json message
     * @param {string} path path for the http PUT
     * @param {Object} payload data to be transported via. PUT
     * @returns {Object} received answer
     */
    private async _send(path: string, headers: Record<string, any>, payload: any): Promise<any> {
        const result = await this._callbacks.invokeCallbackAsync('send', path, 'put', payload, headers);
        return result;
    }

        /**
     * Connects to the broker
     * @param {boolean} clean true, if a disconnect shall clean any connection information
     * @param {string} [version='1.0'] interface version (0.0 or 1.0)
     * @param {number} [keepAlive=600000] time in milliseconds the broker will keep the connection without receiving calls
     * @returns {Object} payload returned from connect request
     */
        async connect(clean: boolean, version: string = '1.0', keepAlive: number = 600 * 1000): Promise<any> {
            const httpObjects = Interfaces.connect(version, {
                clientId: this._clientId, host: this._myAddress, port: this._listenerPort, clean, keepAlive
            });
            const result = await this._send('/connect', httpObjects.headers, httpObjects.payload);
    
            if (!httpObjects.resultCheck(result)) {
                throw new Error('Unable to connect status code: ' + result.statusCode + ' ' + JSON.stringify(result.headers));
            }
    
            this.isConnected = true;
            if (result.headers['content-type'].startsWith('application/json')) {
                result.payload = JSON.parse(result.payload);
            }
    
            if (version >= '1.0') {
                this.token = result.payload.token;
            }
            return result.payload;
        }
    
        /**
         * Disconnects from the broker
         * @param {string} [version='1.0'] interface version (0.0 or 1.0)
         * @returns {Object} empty object
         */
        async disconnect(version: string = '1.0'): Promise<any> {
            const httpObjects = Interfaces.disconnect(version, this._clientId);
            const result = await this._send('/disconnect', httpObjects.headers, httpObjects.payload);
    
            if (!httpObjects.resultCheck(result)) {
                throw new Error('Unable to disconnect status code: ' + result.statusCode);
            }
    
            this._isConnected = false;
            return {};
        }
    
        /**
         * Subscribe to the broker
         * @param {Object} topics topics to subscribe to {topic1: QoS1, topic2: QoS2, ...}
         * @param {string} [version='1.0'] interface version (0.0 or 1.0)
         * @returns {Object} payload returned from subscribe request
         */
        async subscribe(topics: Record<string, number>, version: string = '1.0'): Promise<any> {
            const httpObjects = Interfaces.subscribe(version, topics, this._clientId, this._providePacketId());
    
            const result = await this._send('/subscribe', httpObjects.headers, httpObjects.payload);
            const headers = result.headers;
    
            if (!httpObjects.resultCheck(result)) {
                throw new Error('Unable to subscribe status code: ' + result.statusCode + ' headers ' + JSON.stringify(headers));
            }
    
            if (headers['content-type'].startsWith('application/json')) {
                result.payload = JSON.parse(result.payload);
            }
            return result.payload;
        }
    
        /**
         * Unsubscribes from the broker
         * @param {Array} topics topics to unsubscribe [topic1, topic2, ...]
         * @param {string} [version='1.0'] interface version (0.0 or 1.0)
         * @returns {Object} empty object
         */
        async unsubscribe(topics: string[], version: string = '1.0'): Promise<any> {
            const httpObjects = Interfaces.unsubscribe(version, topics, this._clientId, this._providePacketId());
            const result = await this._send('/unsubscribe', httpObjects.headers, httpObjects.payload);
    
            if (!httpObjects.resultCheck(result)) {
                throw new Error('Unable to unsubscribe status code: ' + result.statusCode);
            }
    
            return {};
        }
    
        /**
         * Sends a ping request to signal the client is alive
         * @returns {boolean} true on success
         */
        async pingreq(): Promise<boolean> {
            const payload = { token: this.token?.send };
            const headers = { 'content-type': 'application/json; charset=UTF-8' };
            const result = await this._send('/pingreq', headers, payload);
            return result.statusCode === 204 && result.headers.packet === 'pingresp';
        }
    
        /**
         * First connect, then subscribe
         * @param {boolean} clean true, if a disconnect shall clean any connection information
         * @param {Object} topics topics to subscribe to {topic1: QoS1, topic2: QoS2, ...}
         * @param {string} [version='1.0'] interface version (0.0 or 1.0)
         * @param {number} [keepAlive=600000] time in milliseconds the broker will keep the connection without receiving calls
         * @returns {Object} combined result from connect and subscribe
         */
        async connectAndSubscribe(clean: boolean, topics: Record<string, number>, version: string = '1.0', keepAlive: number = 600 * 1000): Promise<any> {
            let result = await this.connect(clean, version, keepAlive);
            if (this.isConnected) {
                const subscribeResult = await this.subscribe(topics, version);
                result = { ...result, ...subscribeResult };
            }
            return result;
        }
    
        /**
         * Closes the connection to the broker
         */
        async close(): Promise<void> {
            await this.client.close();
        }
    }
    
    export default Connect;
    