/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

'use strict'

const Connect = require('@mangar2/connect')
const UnitTest = require('@mangar2/unittest')
const os = require('os')

var unitTest = new UnitTest(true, true)
const PORT = 9002
const CLIENT_ID = '/connect/test'
const connect = new Connect(CLIENT_ID, '127.0.0.1', 9001, PORT)

/**
 * Gets the IP v4 address of the current device
 * @returns {string} IP v4 address
 */
function getIPv4Address () {
    const networkInterfaces = os.networkInterfaces()
    let address
    for (const network in networkInterfaces) {
        const networkInterface = networkInterfaces[network]
        networkInterface.forEach(function (info) {
            if (info.family === 'IPv4' && info.internal === false) {
                address = info.address
            }
        })
    }
    return address
}

const returnHeader = {
    'content-type': 'application/json; charset=UTF-8',
    accept: 'application/json,text/plain',
    'accept-charset': 'UTF-8',
    version: '1.0'
}

// Test connect
async function testConnect (clean) {
    connect.on('send', (...param) => {
        unitTest.assertDeepEqual(param, [
            '/connect',
            'put',
            {
                clientId: CLIENT_ID,
                host: getIPv4Address(),
                port: PORT,
                clean: clean,
                keepAlive: undefined
            },
            returnHeader
        ], 'connect')
        return {
            headers: { 'content-type': 'application/json; charset=UTF-8', packet: 'connack' },
            payload: JSON.stringify({ present: 0 }),
            statusCode: 200
        }
    })
    await connect.connect(clean).catch(reason => {
        console.log(reason)
    })
    unitTest.assertTrue(connect.isConnected, 'connected')
}

// Test disconnect
async function testDisconnect () {
    connect.on('send', (...param) => {
        unitTest.assertDeepEqual(param, [
            '/disconnect',
            'put',
            {
                clientId: CLIENT_ID
            },
            returnHeader
        ], 'disconnect')
        return {
            headers: { 'content-type': 'application/json; charset=UTF-8' },
            payload: JSON.stringify({ }),
            statusCode: 204
        }
    })

    await connect.disconnect().catch(reason => console.log(reason))
    unitTest.assertTrue(!connect.isConnected, 'disconnected')
}

// Test subscribe
async function testSubscribe () {
    connect.on('send', (...param) => {
        unitTest.assertDeepEqual(param, [
            '/subscribe',
            'put',
            {
                clientId: CLIENT_ID,
                topics: { '/a/a': 0, '/a/1': 1, '/a/2': 2, 'b/b': 1 }
            },
            { ...returnHeader, packetid: 1 }
        ], 'subscribe')
        return {
            headers: { 'content-type': 'application/json; charset=UTF-8', packet: 'suback', packetid: 1 },
            payload: JSON.stringify({ }),
            statusCode: 200
        }
    })

    await connect.subscribe({ '/a/a': 0, '/a/1': 1, '/a/2': 2, 'b/b': 1 })
}

// Test unsubscribe
async function testUnsubscribe () {
    connect.on('send', (...param) => {
        unitTest.assertDeepEqual(param, [
            '/unsubscribe',
            'put',
            {
                topics: ['/a/a', '/a/1', '/a/2', 'b/b'],
                clientId: CLIENT_ID
            },
            { ...returnHeader, packetid: 2 }
        ], 'unsubscribe')
        return {
            headers: { 'content-type': 'application/json; charset=UTF-8', packet: 'unsuback', packetid: 2 },
            payload: JSON.stringify({ }),
            statusCode: 204
        }
    })

    await connect.unsubscribe(['/a/a', '/a/1', '/a/2', 'b/b'])
}

(async function test () {
    const CLEAN = true
    try {
        await testConnect(CLEAN)
        await testDisconnect()
        await testConnect(!CLEAN)
        await testSubscribe()
        await testUnsubscribe()
    } catch (err) {
        console.log(err)
        unitTest.fail('exception')
    }
    unitTest.showResult(8)
})()
