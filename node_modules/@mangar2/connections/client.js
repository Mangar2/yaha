/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:        client.js
 * Purpouse:    Hold one connection to a service/sensor
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * Version:     1.0
 * ---------------------------------------------------------------------------------------------------
 */

'use strict'

const TopicMatch = require('@mangar2/topicmatch')
const MessageQueueEntry = require('./messageQueueEntry')

module.exports = class Client {
    /**
     * Creates a new connection
     * @param {string} clientId id of the client
     * @param {string} host name of the client host
     * @param {number} port port the client listens to
     */
    constructor (clientId, host, port) {
        this.clientId = clientId
        this.host = host
        this.port = port

        this.subscribePattern = new TopicMatch()
        this.nextMessageId = 0
        this.token = {}
        this.qos2Queue = {}
        if (Client.maxQueueSize === undefined) {
            Client.setMaxQueueSize(100)
        }
    }

    /**
     * Restores the client from a JSON object.
     * @param {object} jsonObject
     */
    restoreFromJSON (jsonObject) {
        for (const property in jsonObject) {
            this[property] = jsonObject[property]
        }
        this.subscribePattern = new TopicMatch(this.subscribePattern.topicPatternList)
        this.rebuildMessageQueues()
    }

    /**
     * Sets the maximal length of a queue per topic
     * @param {integer} size new size of the queue
     */
    static setMaxQueueSize (size) {
        Client.maxQueueSize = size
    }

    /**
     * Recreates the message queue from persistend data
     */
    rebuildMessageQueues () {
        if (this.QoS0Queue !== undefined) {
            for (const index in this.QoS0Queue) {
                const entry = this.QoS0Queue[index]
                this.QoS0Queue[index] = new MessageQueueEntry(entry.qos, entry.payload)
            }
        }
        for (const topic in this.orderedTopicsQueue) {
            const queue = this.orderedTopicsQueue[topic]
            for (const index in queue) {
                const entry = queue[index]
                queue[index] = new MessageQueueEntry()
                queue[index].restoreFromObject(entry)
            }
        }
    }

    /**
     * Gets the token the client will use to publish data
     * @returns {string}
     */
    getSendToken () {
        return this.token.send
    }

    /**
     * @returns {boolean} true, if the client is connected
     */
    isConnected () {
        return this.status === 'connected'
    }

    /**
     * Gets the message queue
     * @returns {Array} array of queued elements
     */
    getMessageQueue () {
        return this.messageQueue
    }

    /**
     * Cleans up the session
     */
    cleanSession () {
        this.orderedTopicsQueue = {}
        this.qos2Queue = {}
        this.subscribePattern = new TopicMatch()
        this.status = 'clean'
    }

    /**
     * Initializes values if not already set
     */
    init () {
        this.QoS0Queue = []
        if (this.subscribePattern === undefined) {
            this.subscribePattern = new TopicMatch()
        }
        if (this.orderedTopicsQueue === undefined) {
            this.orderedTopicsQueue = {}
        }
    }

    /**
     * Sets the clean value (does NOT clean the session). If the parameter clean is
     * undefined AND the property clean is undefined it will set clean to true.
     * @param {boolean|string} clean new clean value (accepts true, "true", 1, "1" as true value). Any other value is false.
     */
    setClean (clean) {
        if (clean !== undefined) {
            this.clean = (clean === true || clean === 'true' || clean === 1 || clean === '1')
        } else if (this.clean === undefined) {
            this.clean = true
        }
    }

    /**
     * sets the connection to "connected", resets the unsuccessful counter to 0, starts with
     * messageId 0 and stores the current timestamp.
     * @param {any} clientId id of the client
     * @param {string} host host name
     * @param {string} port port name
     * @param {bool} clean true, if the connection will be cleaned on disconnect
     * @param {string} version client interface version
     */
    connect (clientId, host, port, clean = true, version = '1.0') {
        this.startToTransmitTimestamp = 0

        if (this.clientId === undefined && clientId !== undefined) {
            this.clientId = clientId
        }

        if (this.clientId !== clientId) {
            throw Error('clientId does not match (' + clientId + ')')
        }

        this.host = host
        this.port = port
        this.version = version

        this.setClean(clean)

        if (this.clean) {
            this.cleanSession()
        }

        this.init()
        this.clearRetryCount()
        this.validate()

        this.status = 'connected'
        this.connectTimestamp = new Date().getTime()
        this.token = { send: 'send' + this.clientId, receive: 'receive' + this.clientId }
        return this.token
    }

    /**
     * Disconnects a client
     * @param {any} clientId id of the client
     * @throws {Error} if clientId does not match
     */
    disconnect (clientId) {
        if (this.clientId !== clientId) {
            throw Error('clientId does not match (' + clientId + ')')
        }

        this.status = 'disconnected'
        this.QoS0Queue = []
        if (this.clean) {
            this.cleanSession()
        }
    }

    /**
     * Validates a subscribe/unsubscribe parameter
     * @param {any} clientId id of the client
     * @throws {Error} if clientId does not match or subscription is not given
     */
    validateSubscribe (clientId, topics) {
        if (this.clientId !== clientId) {
            throw Error('clientId does not match (' + clientId + ')')
        }
        if (topics === undefined || topics.constructor !== Object || Object.entries(topics).length === 0) {
            throw Error('Subsribe without topics')
        }
        if (this.status !== 'connected') {
            throw Error('Subscribe without beeing connected')
        }
    }

    /**
     * Adds a subscription to the connection
     * @param {object} subscribe {QoS:Qos, topics:[topic1, topic2, ...]}
     * @throws {Error} if clientId does not match or subscription is not given
     */
    subscribeOldFormat (subscribe) {
        const QoS = this.convertQoSToValidQoS(subscribe.QoS)
        const topics = subscribe.topics
        const result = []

        if (!Array.isArray(topics)) {
            this.subscribePattern.setPattern(topics, QoS)
            result.push(QoS)
        } else {
            for (const topic of topics) {
                this.subscribePattern.setPattern(topic, QoS)
                result.push(QoS)
            };
        }
        return result
    }

    /**
     * Adds a subscription to the connection
     * @param {any} clientId id of the client
     * @param {object} topics {topic1:QoS1, topic2:Qos2, ...}
     * @throws {Error} if clientId does not match or subscription is not given
     */
    subscribe (clientId, topics) {
        let result = []
        try {
            this.validateSubscribe(clientId, topics)
            if (topics.topics === undefined) {
                for (const topic in topics) {
                    const QoS = this.convertQoSToValidQoS(topics[topic])
                    result.push(QoS)
                    this.subscribePattern.setPattern(topic, QoS)
                }
            } else {
                result = this.subscribeOldFormat(topics)
            }
        } catch (err) {
            result = [0x80]
            console.error(err.message)
        }
        return result
    }

    /**
     * checks if topics is either a string or an array with at least one element
     * @param {string|array} topics
     */
    static isStringOrFilledArray (topics) {
        let result = false
        if (topics !== undefined) {
            if (Array.isArray(topics) && topics.length > 0) {
                result = true
            } else if (typeof (topics) === 'string') {
                result = true
            }
        }
        return result
    }

    /**
     * removes subscriptions from topics
     * @param {any} clientId id of the client
     * @param {string|array} topics array of topic strings with wildchars
     * @throws {Error} if clientId does not match or subscription is not given
     */
    unsubscribe (clientId, topics) {
        if (this.clientId !== clientId) {
            throw Error('clientId does not match (' + clientId + ')')
        }
        if (!Client.isStringOrFilledArray(topics)) {
            throw Error('Unsubscribe without topics')
        }
        if (this.status !== 'connected') {
            throw Error('Unsubscribe without beeing connected')
        }
        this.subscribePattern.removePattern(topics)
    }

    /**
     * Adds a message to an ordered topic
     * @param {object} messageQueueEntry entry of the message queue
     */
    addMessageToOrderedTopic (messageQueueEntry) {
        const message = messageQueueEntry.payload
        const topic = message.topic

        if (!Array.isArray(this.orderedTopicsQueue[topic])) {
            this.orderedTopicsQueue[topic] = []
        }
        this.orderedTopicsQueue[topic].push(messageQueueEntry)
        if (this.orderedTopicsQueue[topic].length > Client.maxQueueSize) {
            this.orderedTopicsQueue[topic].slice(0, 1)
        }
    }

    /**
     * Deletes an entry from the qos2 queue
     * @param {number} packetid unique identifier of the packet (unique by client)
     */
    deleteFromQos2Queue (packetid) {
        delete this.qos2Queue[packetid]
    }

    /**
     * Checks, if a packet id is in the qos 2 queue.
     * @param {number} packetid unique identifier of the packet (unique by client)
     */
    isInQos2Queue (packetid) {
        return this.qos2Queue[packetid] !== undefined
    }

    /**
     * Adds an entry to the qos=2 queue to remember send packages and to ignore duplicates
     * @param {number} packetid id of the package
     * @param {string} topic topic of the corresponding message
     */
    addToQos2Queue (packetid, topic) {
        this.qos2Queue[packetid] = { time: new Date().getTime(), topic }
    }

    /**
     * checks, if a message must be published
     * @param {object} message message to add to a publish storage
     * @param {object} QoS quality of service received from published headers
     * @param {boolean} dup true (or 1), if the message is a duplicated
     * @param {TopicMatch} pattern optional: alternative match filter to filter messages
     * (only relevant in QoS=2 that is not yet implemented)
     */
    publishMessage (message, qos, dup, pattern) {
        const topic = message.topic
        let sendQos

        if (pattern !== undefined && pattern.constructor.name === 'TopicMatch') {
            sendQos = pattern.getBestMatch(topic)
        } else {
            sendQos = this.subscribePattern.getBestMatch(topic)
        }

        if (sendQos !== undefined) {
            sendQos = this.calcQoS(qos, sendQos)
            const messageQueueEntry = new MessageQueueEntry(sendQos, message)
            if (sendQos === 0) {
                this.QoS0Queue.push(messageQueueEntry)
            } else {
                messageQueueEntry.setId(this.genMessageId())
                this.addMessageToOrderedTopic(messageQueueEntry)
            }
        }
    }

    /**
     * Acknowledges a message, either delete it or set it to pubrel
     * @param {string} topic topic to delete message from
     * @param {Number} packet id of the message
     */
    acknowledgeMessageById (topic, packetid) {
        const messageQueue = this.orderedTopicsQueue[topic]
        if (Array.isArray(messageQueue)) {
            for (const index in messageQueue) {
                const messageQueueEntry = messageQueue[index]
                if (messageQueueEntry.getPacketid() === packetid) {
                    if (messageQueueEntry.getQoS() === 2 && !messageQueueEntry.isPubrel()) {
                        messageQueueEntry.setPubrel()
                    } else {
                        messageQueue.splice(index, 1)
                    }
                    break
                }
            }
        }
    }

    /**
     * calculates the next message id
     * @returns {number} message id
     */
    genMessageId () {
        var result = this.nextMessageId
        if (result >= 0 || result < 0xFFFF) {
            this.nextMessageId++
        } else {
            result = 0
            this.nextMessageId = 1
        }
        return result
    }

    /**
     * Converts a QoS to a valid QoS. (0,1,2) by converting it to Number and setting it to
     * "0" on any invalid entry
     * @param {any} Qos QoS to transform
     * @return {Number} valid QoS
     */
    convertQoSToValidQoS (QoS) {
        var numberQoS = Number(QoS)
        if (numberQoS !== 1 && numberQoS !== 2) {
            numberQoS = 0
        }
        return numberQoS
    }

    /**
     * Calculates the resulting QoS from message an subscription
     * @param {Number} messageQoS QoS from message
     * @param {Number} subscribeQoS QoS from subscription
     */
    calcQoS (messageQoS, subscribeQoS) {
        var validMessageQoS = this.convertQoSToValidQoS(messageQoS)
        var validSubscribeQoS = this.convertQoSToValidQoS(subscribeQoS)
        var result = Math.min(validMessageQoS, validSubscribeQoS)
        return result
    }

    /**
     * get messages to send for an ordered topic
     * @param {string} topic topic of the messages
     * @param {number} inFlightWindow maximal amount of messages to process
     * @param {number} timeoutInMilliseconds timeout waiting for messages
     */
    _getOrderedMessagesToSend (topic, inFlightWindow, timeoutInMilliseconds) {
        let count = 0
        const now = (new Date()).getTime()
        const result = []
        for (const entry of this.orderedTopicsQueue[topic]) {
            if (entry.status === 'new') {
                entry.status = 'sending'
            } else if (entry.status === 'pubrel') {
                // do nothing, keep status
            } else if (entry.transmitTimestamp + timeoutInMilliseconds < now) {
                entry.status = 'duplicate'
            } else {
                break
            }
            entry.setTransmissionTimestamp()
            entry.setClientInfo(
                this.clientId, this.host, this.port, this.version, this.token.receive)
            result.push(entry)
            count++
            if (count === inFlightWindow) break
        }
        return result
    }

    /**
     * returns all entries of the QoS0Message queue and deletes the queue
     * @returns {Array[MessageQueueEntry]} array of messages to send
     */
    _getNotOrderedMessagesToSendAndClearTheQueue () {
        const result = []
        if (this.isConnected()) {
            for (const entry of this.QoS0Queue) {
                entry.status = 'sending'
                entry.setClientInfo(
                    this.clientId, this.host, this.port, this.version, this.token.receive)
                result.push(entry)
            }
            this.QoS0Queue = []
        }
        return result
    }

    /**
     * Get all messages to send
     * @param {number} inFlightWindow maximal amount of qos1 and qos2 messages to process
     * @param {number} timeoutInMilliseconds timeout waiting for messages
     */
    getAllMessagesToSend (inFlightWindow, timeoutInMilliseconds) {
        let result = []
        // qos= 0 message are deleted, even if the client is not connected
        const notOrderedMessages = this._getNotOrderedMessagesToSendAndClearTheQueue()
        if (this.isConnected()) {
            for (const topic in this.orderedTopicsQueue) {
                const messages = this._getOrderedMessagesToSend(
                    topic, inFlightWindow, timeoutInMilliseconds)
                result = [...result, ...messages]
            }
            result = [...notOrderedMessages, ...result]
        }
        return result
    }

    /**
     * Gets the maximal retry count for a client
     */
    getMaxRetryCount () {
        let result = 0
        for (const topic in this.orderedTopicsQueue) {
            const queue = this.orderedTopicsQueue[topic]
            // We only check the first entry, as all following entries may not have a higher
            // retry count
            if (queue.length > 0) {
                const entry = queue[0]
                if (entry.retryCount > result) {
                    result = entry.retryCount
                }
            }
        }
        return result
    }

    /**
     * clears all retry counts
     */
    clearRetryCount () {
        for (const topic in this.orderedTopicsQueue) {
            const queue = this.orderedTopicsQueue[topic]
            for (const entry of queue) {
                entry.retryCount = 0
            }
        }
    }

    /**
     * Validates the object, throws errors, on failure
     */
    validate () {
        if (this.clientId === undefined) {
            throw Error('Connection without client id (clientId)')
        }
        if (this.host === undefined) {
            throw Error('Connection without host')
        }
        if (this.port === undefined) {
            throw Error('Connection without port')
        }
        if (this.clean !== true && this.clean !== false) {
            throw Error('Illegal clean value ' + this.clean)
        }
    }
}
