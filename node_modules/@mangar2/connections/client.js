/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:        client.js
 * Purpouse:    Hold one connection to a service/sensor
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * Version:     1.0
 * ---------------------------------------------------------------------------------------------------
 */

'use strict'

const TopicMatch = require('@mangar2/topicmatch')
const Message = require('@mangar2/message')
const MessageQueueEntry = require('./messageQueueEntry')

module.exports = class Client {
    /**
     * Creates a new connection
     */
    constructor () {
        this._clientId = undefined
        this.host = undefined
        this.port = undefined
        this.will = undefined

        this.subscribePattern = new TopicMatch()
        this.nextMessageId = 0
        this.token = {}
        this.qos2Queue = {}
        this.keepAlive = 0
        this.lastActiveTimestamp = 0

        if (Client.maxQueueSize === undefined) {
            Client.maxQueueSize = 100
        }
    }

    /**
     * Gets/Sets the name of the sender host
     * @type {string} name of the host
     */
    get host () { return this._host }
    set host (host) { this._host = host }

    /**
     * Gets/Sets the number of the client port
     * @type {number} name of the port
     */
    get port () { return this._port }
    set port (port) { this._port = port }

    /**
     * get/set the id of the client. Note: it may not be changed
     * @type {string}
     */
    get clientId () { return this._clientId }
    set clientId (clientId) {
        if (this._clientId === undefined && clientId !== undefined) {
            this._clientId = clientId
        }
        if (this.clientId !== clientId) {
            throw Error('clientId may not be changed (' + clientId + ')')
        }
    }

    /**
     * Sets/gets the maximal length of a queue per topic. Longer queues will be truncated
     * @return {integer} maximal size of the queue
     * @param {integer} size maximal size of the queue
     */
    static set maxQueueSize (size) { Client._maxQueueSize = size }
    static get maxQueueSize () { return Client._maxQueueSize }

    /**
     * Sets the will message
     * @param {object} will will message configuration
     * @param {number} will.qos will message quality of service
     * @param {boolean} will.retain true, if the will message is retained
     * @param {string} will.topic topic of the will message
     * @param {string|number} will.value value of the will message
     */
    get will () { return this._will }
    set will (will) { this._will = will }

    /**
     * Gets the token the client will use to publish data
     * @returns {string}
     */
    get sendToken () {
        return this.token.send
    }

    /**
     * Sets the last active timestamp to now
     */
    actualizeLastActiveTimestamp () {
        this.lastActiveTimestamp = new Date().getTime()
    }

    /**
     * Checks, if the client has received messages lately
     * @returns {boolean} true, if the client is alive
     */
    isAlive () {
        const mqttStandardAliveFactor = 1.5
        const now = new Date().getTime()
        return this.lastActiveTimestamp + this.keepAlive * mqttStandardAliveFactor >= now
    }

    /**
     * @returns {boolean} true, if the client is connected
     */
    isConnected () {
        return this.status === 'connected'
    }

    /**
     * Restores the client from a JSON object.
     * @param {object} jsonObject
     */
    restoreFromJSON (jsonObject) {
        for (const property in jsonObject) {
            this[property] = jsonObject[property]
        }
        this.subscribePattern = new TopicMatch(this.subscribePattern.topicPatternList)
        this.rebuildMessageQueues()
    }

    rebuildPayload (payload) {
        const message = new Message(payload.topic, payload.value, payload.reason)
        return message
    }

    /**
     * Recreates the message queue from persistend data
     */
    rebuildMessageQueues () {
        if (this.QoS0Queue !== undefined) {
            const queue = this.QoS0Queue
            for (const index in queue) {
                const entry = queue[index]
                queue[index] = new MessageQueueEntry()
                queue[index].restoreFromObject(entry)
            }
        }
        for (const topic in this.orderedTopicsQueue) {
            const queue = this.orderedTopicsQueue[topic]
            for (const index in queue) {
                const entry = queue[index]
                queue[index] = new MessageQueueEntry()
                queue[index].restoreFromObject(entry)
            }
        }
    }

    /**
     * Cleans up the session
     */
    cleanSession () {
        this.orderedTopicsQueue = {}
        this.qos2Queue = {}
        this.subscribePattern = new TopicMatch()
        this.status = 'clean'
    }

    /**
     * Initializes values if not already set
     */
    init () {
        if (this.clean) {
            this.cleanSession()
        }
        this.QoS0Queue = []

        if (this.orderedTopicsQueue === undefined) {
            this.orderedTopicsQueue = {}
        }
        this.clearRetryCount()
    }

    /**
     * Sets the clean value (does NOT clean the session). If the parameter clean is
     * undefined AND the property clean is undefined it will set clean to true.
     * @param {boolean|string} clean new clean value (accepts true, "true", 1, "1" as true value). Any other value is false.
     */
    setClean (clean) {
        if (clean !== undefined) {
            this.clean = (clean === true || clean === 'true' || clean === 1 || clean === '1')
        } else if (this.clean === undefined) {
            this.clean = true
        }
    }

    /**
     * Removes old entries from the qos2Queue
     * @param {number} timeoutInMilliseconds amount of milliseconds to keep entries in
     * the queue
     */
    cleanupQos2Queue (timeoutInMilliseconds) {
        const now = new Date().getTime()
        const qos2Queue = this.qos2Queue
        for (const index in qos2Queue) {
            const entry = qos2Queue[index]
            if (entry.time + timeoutInMilliseconds < now) {
                delete qos2Queue[index]
            }
        }
    }

    /**
     * sets the connection to "connected", resets the unsuccessful counter to 0, starts with
     * messageId 0 and stores the current timestamp.
     * @param {any} clientId id of the client
     * @param {string} host host name
     * @param {string} port port name
     * @param {bool} clean true, if the connection will be cleaned on disconnect
     * @param {string} version client interface version
     * @param {number} keepAlive keep alive time in milliseconds. The broker will disconnect
     * any client not sending messages in the keepAlive interval. Default is one hour
     */
    connect (clientId, host, port, clean = true, version = '1.0', keepAlive = (3600 * 1000)) {
        this.startToTransmitTimestamp = 0

        this.clientId = clientId
        this.host = host
        this.port = port
        this.version = version
        this.keepAlive = keepAlive
        this.setClean(clean)

        this.init()
        this.status = 'connected'
        this.actualizeLastActiveTimestamp()
        this.connectTimestamp = new Date().getTime()
        this.token = { send: 'send' + this.clientId, receive: 'receive' + this.clientId }
        return this.token
    }

    /**
     * Validates the existance of a valid connection
     * @param {string} clientId id of the client
     * @param {string} action actio name for the error message
     * @throws {Error} Connection not valid
     */
    validateConnection (clientId, action) {
        if (this.clientId !== clientId) {
            throw Error(action + ': clientId does not match (' + clientId + ')')
        }
        if (this.status !== 'connected') {
            throw Error(action + ' without beeing connected')
        }
    }

    /**
     * Disconnects a client
     * @param {any} clientId id of the client
     * @throws {Error} if clientId does not match
     */
    disconnect () {
        this.status = 'disconnected'
        this.QoS0Queue = []
        if (this.clean) {
            this.cleanSession()
        }
    }

    /**
     * Adds a subscription to the connection
     * @param {object} subscribe {QoS:Qos, topics:[topic1, topic2, ...]}
     * @throws {Error} if clientId does not match or subscription is not given
     */
    subscribeOldFormat (subscribe) {
        const QoS = this.convertQoSToValidQoS(subscribe.QoS)
        const topics = subscribe.topics
        const result = []

        if (!Array.isArray(topics)) {
            this.subscribePattern.setPattern(topics, QoS)
            result.push(QoS)
        } else {
            for (const topic of topics) {
                this.subscribePattern.setPattern(topic, QoS)
                result.push(QoS)
            };
        }
        return result
    }

    /**
     * Adds a subscription to the connection
     * @param {any} clientId id of the client
     * @param {object} topics {topic1:QoS1, topic2:Qos2, ...}
     * @throws {Error} if clientId does not match or subscription is not given
     */
    subscribe (clientId, topics) {
        let result = []
        try {
            this.validateConnection(clientId, 'subscribe')
            if (topics.topics === undefined) {
                for (const topic in topics) {
                    const qos = this.convertQoSToValidQoS(topics[topic])
                    result.push(qos)
                    this.subscribePattern.setPattern(topic, qos)
                }
            } else {
                result = this.subscribeOldFormat(topics)
            }
        } catch (err) {
            result = [0x80]
        }
        return result
    }

    /**
     * removes subscriptions from topics
     * @param {any} clientId id of the client
     * @param {string|array} topics array of topic strings with wildchars
     * @throws {Error} if clientId does not match or subscription is not given
     */
    unsubscribe (clientId, topics) {
        this.validateConnection(clientId, 'unsubscribe')
        this.subscribePattern.removePattern(topics)
    }

    /**
     * Adds a message to an ordered topic
     * @param {object} messageQueueEntry entry of the message queue
     */
    addMessageToOrderedTopic (messageQueueEntry) {
        const message = messageQueueEntry.payload
        const topic = message.topic

        if (!Array.isArray(this.orderedTopicsQueue[topic])) {
            this.orderedTopicsQueue[topic] = []
        }
        this.orderedTopicsQueue[topic].push(messageQueueEntry)
        if (this.orderedTopicsQueue[topic].length > Client.maxQueueSize) {
            this.orderedTopicsQueue[topic].slice(0, 1)
        }
    }

    /**
     * Deletes an entry from the qos2 queue
     * @param {number} packetid unique identifier of the packet (unique by client)
     */
    deleteFromQos2Queue (packetid) {
        delete this.qos2Queue[packetid]
    }

    /**
     * Checks, if a packet id is in the qos 2 queue.
     * @param {number} packetid unique identifier of the packet (unique by client)
     */
    isInQos2Queue (packetid) {
        return this.qos2Queue[packetid] !== undefined
    }

    /**
     * Adds an entry to the qos=2 queue to remember send packages and to ignore duplicates
     * @param {number} packetid id of the package
     * @param {string} topic topic of the corresponding message
     */
    addToQos2Queue (packetid, topic) {
        this.qos2Queue[packetid] = { time: new Date().getTime(), topic }
    }

    /**
     * checks, if a message must be published
     * @param {object} message message to add to a publish storage
     * @param {object} QoS quality of service received from published headers
     * @param {TopicMatch} pattern optional: alternative match filter to filter messages
     */
    publishMessage (message, qos, pattern) {
        const topic = message.topic
        let sendQos

        if (pattern !== undefined && pattern.constructor.name === 'TopicMatch') {
            sendQos = pattern.getBestMatch(topic)
        } else {
            sendQos = this.subscribePattern.getBestMatch(topic)
        }

        if (sendQos !== undefined) {
            sendQos = this.calcQoS(qos, sendQos)
            const messageQueueEntry = new MessageQueueEntry(sendQos, message)
            if (sendQos === 0) {
                this.QoS0Queue.push(messageQueueEntry)
            } else {
                messageQueueEntry.packetid = this.genMessageId()
                this.addMessageToOrderedTopic(messageQueueEntry)
            }
        }
    }

    /**
     * Acknowledges a message, either delete it or set it to pubrel
     * @param {string} topic topic to delete message from
     * @param {Number} packet id of the message
     */
    acknowledgeMessageById (topic, packetid) {
        const messageQueue = this.orderedTopicsQueue[topic]
        if (Array.isArray(messageQueue)) {
            for (const index in messageQueue) {
                const messageQueueEntry = messageQueue[index]
                if (messageQueueEntry.packetid === packetid) {
                    if (messageQueueEntry.qos === 2 && !messageQueueEntry.isStatusPubrel()) {
                        messageQueueEntry.setStatusToPubrel()
                    } else {
                        messageQueue.splice(index, 1)
                    }
                    break
                }
            }
        }
    }

    /**
     * calculates the next message id
     * @returns {number} message id
     */
    genMessageId () {
        var result = this.nextMessageId
        if (result >= 0 || result < 0xFFFF) {
            this.nextMessageId++
        } else {
            result = 0
            this.nextMessageId = 1
        }
        return result
    }

    /**
     * Converts a QoS to a valid QoS. (0,1,2) by converting it to Number and setting it to
     * "0" on any invalid entry
     * @param {any} Qos QoS to transform
     * @return {Number} valid QoS
     */
    convertQoSToValidQoS (QoS) {
        var numberQoS = Number(QoS)
        if (numberQoS !== 1 && numberQoS !== 2) {
            numberQoS = 0
        }
        return numberQoS
    }

    /**
     * Calculates the resulting QoS from message an subscription
     * @param {Number} messageQoS QoS from message
     * @param {Number} subscribeQoS QoS from subscription
     */
    calcQoS (messageQoS, subscribeQoS) {
        var validMessageQoS = this.convertQoSToValidQoS(messageQoS)
        var validSubscribeQoS = this.convertQoSToValidQoS(subscribeQoS)
        var result = Math.min(validMessageQoS, validSubscribeQoS)
        return result
    }

    /**
     * get messages to send for an ordered topic
     * @param {string} topic topic of the messages
     * @param {number} inFlightWindow maximal amount of messages to process
     * @param {number} timeoutInMilliseconds timeout waiting for messages
     */
    _getOrderedMessagesToSend (topic, inFlightWindow, timeoutInMilliseconds) {
        let count = 0
        const now = (new Date()).getTime()
        const result = []
        for (const entry of this.orderedTopicsQueue[topic]) {
            if (entry.status === 'new') {
                entry.status = 'sending'
            } else if (entry.status === 'pubrel') {
                // do nothing, keep status
            } else if (entry.transmitTimestamp + timeoutInMilliseconds < now) {
                entry.status = 'duplicate'
            } else {
                break
            }
            entry.setTransmissionTimestamp()
            entry.setClientInfo(
                this.clientId, this.host, this.port, this.version, this.token.receive)
            result.push(entry)
            count++
            if (count === inFlightWindow) break
        }
        return result
    }

    /**
     * returns all entries of the QoS0Message queue and deletes the queue
     * @returns {Array[MessageQueueEntry]} array of messages to send
     */
    _getNotOrderedMessagesToSendAndClearTheQueue () {
        const result = []
        if (this.isConnected()) {
            for (const entry of this.QoS0Queue) {
                entry.status = 'sending'
                entry.setClientInfo(
                    this.clientId, this.host, this.port, this.version, this.token.receive)
                result.push(entry)
            }
            this.QoS0Queue = []
        }
        return result
    }

    /**
     * Get all messages to send
     * @param {number} inFlightWindow maximal amount of qos1 and qos2 messages to process
     * @param {number} timeoutInMilliseconds timeout waiting for messages
     */
    getAllMessagesToSend (inFlightWindow, timeoutInMilliseconds) {
        let result = []
        // qos= 0 message are deleted, even if the client is not connected
        const notOrderedMessages = this._getNotOrderedMessagesToSendAndClearTheQueue()
        if (this.isConnected()) {
            for (const topic in this.orderedTopicsQueue) {
                const messages = this._getOrderedMessagesToSend(
                    topic, inFlightWindow, timeoutInMilliseconds)
                result = [...result, ...messages]
            }
            result = [...notOrderedMessages, ...result]
        }
        return result
    }

    /**
     * Gets the maximal retry count for a client
     */
    getMaxRetryCount () {
        let result = 0
        for (const topic in this.orderedTopicsQueue) {
            const queue = this.orderedTopicsQueue[topic]
            // We only check the first entry, as all following entries may not have a higher
            // retry count
            if (queue.length > 0) {
                const entry = queue[0]
                if (entry.retryCount > result) {
                    result = entry.retryCount
                }
            }
        }
        return result
    }

    /**
     * clears all retry counts
     */
    clearRetryCount () {
        for (const topic in this.orderedTopicsQueue) {
            const queue = this.orderedTopicsQueue[topic]
            for (const entry of queue) {
                entry.retryCount = 0
            }
        }
    }
}
