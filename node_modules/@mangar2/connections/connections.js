/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const Persist = require('@mangar2/persist')
const TopicMatch = require('@mangar2/topicmatch')
const CheckInput = require('@mangar2/checkinput')
const Message = require('@mangar2/message')
const Client = require('./client.js')
var persistConnections = new Persist()

/**
 * Check valid configuration options
 */
const checkConfig = new CheckInput({
    type: 'object',
    properties: {
        fileName: { type: 'string' },
        directory: { type: 'string' },
        inFlightWindow: { type: 'number' },
        replyTimeoutInMilliseconds: { type: 'number' },
        pubrelTimeoutInMilliseconds: { type: 'number' },
        maxRetryCount: { type: 'number' },
        maxQueueSize: { type: 'number' }
    },
    required: ['fileName', 'directory']
})

/**
 * Creates a connection object
 * @param {object} configuration configuration
 * @param {string} configuration.fileName filename for persistence
 * @param {string} configuration.directory directory (file path) for persistence
 * @param {nubmber} configuration.replyTimeoutInMilliseconds timeout to wait for an answer
 * of a http call, default 10 seconds
 * @param {number} configuration.inFlightWindow amount of qos 1 and qos 2 messages
 * send for the same topic at the same time, default 1
 * @param {number} configuration.pubrelTimeoutInMilliseconds timout to wait for a
 * corresponding pubrel message, default one day
 * @param {number} configuration.maxRetryCount amount of resend of messages
 * before forcing a disconnect
 * @param {number} configuration.maxQueuSize maximal amount of entries in a message queue
 */
module.exports = class Connections {
    constructor (configuration) {
        if (checkConfig.validate(configuration) !== true) {
            throw Error(JSON.stringify(checkConfig.messages, null, 2))
        }
        this.configuration = {
            fileName: configuration.fileName,
            directory: configuration.directory,
            inFlightWindow: configuration.inFlightWindow || 1,
            replyTimeoutInMilliseconds: configuration.replyTimeoutInMilliseconds || (10 * 1000),
            maxRetryCount: configuration.maxRetryCount || 10,
            pubrelTimeoutInMilliseconds: configuration.pubrelTimeoutInMilliseconds || (24 * 3600 * 1000)
        }

        if (typeof (this.configuration.maxQueuSize) === 'number') {
            Client.setMaxQueueSize(this.configuration.maxQueuSize)
        }

        this.retainMessages = {}
        this.clients = {}
        this.tokenMap = {}
    }

    /**
     * Restores all clients from last valid saved file
     */
    async restoreFromFile () {
        const data = persistConnections.readData(this.configuration.directory, this.configuration.fileName)
        if (data !== undefined) {
            this.retainMessages = data.retainMessages || {}
            this.tokenMap = data.tokenMap || {}

            for (const clientId in data.clients) {
                const clientData = data.clients[clientId]
                this.clients[clientId] = new Client()
                this.clients[clientId].restoreFromJSON(clientData)
            }
        }
    }

    /**
     * Persists all connections
     */
    async persist () {
        await persistConnections.saveObjectToFile(this.configuration.directory, this.configuration.fileName, this)
    }

    /**
     * Gets a client by id
     * @param {any} clientId id of the client
     * @param {boolean} create if true, a client is created, if no clientId available
     * @throws {Error}
     */
    getClientById (clientId, create = false) {
        if (clientId === undefined) {
            throw Error('Connect without client id (clientId)')
        }

        if (this.clients[clientId] === undefined && create) {
            this.clients[clientId] = new Client(clientId)
        }

        if (this.clients[clientId] === undefined) {
            throw Error('Unknown clientId ' + clientId)
        }

        return this.clients[clientId]
    }

    /**
     * Gets a client by token
     * @param {string} token client send token
     * @returns {Client|undefined} undefined, if client was not found
     */
    getClientByToken (token) {
        let client
        if (token !== undefined) {
            const clientId = this.tokenMap[token]
            if (clientId !== undefined) {
                client = this.getClientById(clientId)
            }
        }
        return client
    }

    /**
     * Connects a client (Stores a connection to a client)
     * @param {any} clientId id of the client
     * @param {string} host host name
     * @param {string} port port name
     * @param {bool} clean true, if the connection will be cleaned on disconnect
     * @param {string} [version='1.0'] client interface version
     * @param {number} [keepAlive=3600000] keep alive time in milliseconds. The broker will disconnect
     * any client not sending messages in the keepAlive interval. Default is one hour
     * @returns {object} {mqttcode, present} present == 1, if an old session is recovered
     * @throws {Error}
     */
    connect (clientId, host, port, clean = true, version = '1.0', keepAlive = (3600 * 1000)) {
        const sessionAvailable = (this.clients[clientId] !== undefined && this.clients[clientId] !== 'clean')
        const present = !clean && sessionAvailable ? 1 : 0
        const client = this.getClientById(clientId, true)
        let sendToken = client.sendToken
        if (sendToken !== undefined) {
            delete this.tokenMap[sendToken]
        }
        const token = client.connect(clientId, host, port, clean, version, keepAlive)
        sendToken = client.sendToken
        this.tokenMap[sendToken] = clientId
        return { mqttcode: 0, present, token }
    }

    /**
     * Disconnects a client
     * @param {string} clientId id of the client
     * @throws {Error}
     */
    disconnect (clientId) {
        const client = this.getClientById(clientId, false)
        client.disconnect()
    }

    /**
     * Clean up jobs. Call regularly (example once a minute)
     * Automatically disconnects clients not sending data until timeout
     */
    cleanup () {
        this._autoDisconnect()
        this._cleanupQos2Queues()
    }

    /**
     * Check each client for auto-disconnect and sends a will message on disconnect
     */
    _autoDisconnect () {
        for (const clientId in this.clients) {
            const client = this.getClientById(clientId)
            const isAlive = client.isAlive()
            if (!isAlive && client.isConnected()) {
                this.publishWill(clientId, client.will)
                this.disconnect(clientId)
            }
        }
    }

    /**
     * clean up the qos2 queues of the clients
     */
    _cleanupQos2Queues () {
        for (const clientId in this.clients) {
            const client = this.getClientById(clientId)
            client.cleanupQos2Queue(this.configuration.pubrelTimeoutInMilliseconds)
        }
    }

    /**
     * Subscribes to topics
     * @param {string} clientId id of the client
     * @param {object} topics {QoS, topics} or {topic1: QoS1, topic2: QoS2, ...}
     * @returns {number[]} array of QoS values
     */
    subscribe (clientId, topics) {
        const client = this.getClientById(clientId, false)
        // Retain messages are not supported for outdated style topics
        if (topics.topics === undefined) {
            const match = new TopicMatch(topics)
            for (const retainTopic in this.retainMessages) {
                const qos = this.retainMessages[retainTopic].qos
                const payload = this.retainMessages[retainTopic].payload
                const retain = true
                client.publishMessage({ payload, qos, retain }, match)
            }
        }
        return client.subscribe(clientId, topics)
    }

    /**
     * Unsubsribes to topics
     * @param {string} clientId id of the client
     * @param {string[]} topics array of topics strings (topic with wildchars '+' and '#')
     */
    unsubscribe (clientId, topics) {
        const client = this.getClientById(clientId, false)
        client.unsubscribe(clientId, topics)
    }

    /**
     * Handles a pubrel message, deleting the entry from the qos2 queue
     * @param {string} token client send token
     * @param {number} packetid unique identifier of the corresponding publish packet
     */
    onPubrel (token, packetid) {
        const client = this.getClientByToken(token)
        if (client !== undefined) {
            client.deleteFromQos2Queue(packetid)
        }
    }

    /**
     * Sets the will message of a client
     * @param {string} clientId id of the client
     * @param {object} will will message configuration
     * @param {number} will.qos will message quality of service
     * @param {boolean} will.retain true, if the will message is retained
     * @param {string} will.topic topic of the will message
     * @param {string|number} will.value value of the will message
     */
    setWill (clientId, will) {
        const client = this.getClientById(clientId)
        if (client !== undefined) {
            client.will = will
        }
    }

    /**
     * Sends a will message
     * @param {string} clientId id of the client
     * @param {object} will will message configuration
     * @param {number} will.qos will message quality of service
     * @param {boolean} will.retain true, if the will message is retained
     * @param {string} will.topic topic of the will message
     * @param {string|number} will.value value of the will message
     */
    publishWill (clientId, will) {
        if (will !== undefined) {
            const { qos, retain, topic, value } = will
            if (topic !== undefined && topic !== '') {
                const payload = new Message(topic, value, 'client ' + clientId + ' was auto disconnected')
                this.publishMessage(payload, qos, retain)
            }
        }
    }

    /**
     * Checks, if a token corresponds to a client. Returns the client
     * @param {string} token
     * @returns {string|undefined} clientId.
     * @throws {string} error message
     */
    checkToken (token) {
        const clientId = this.tokenMap[token]
        if (clientId !== undefined) {
            return clientId
        }
        throw Error('publish message with unknown token')
    }

    /**
     * Checks and remembers a qos2 message. Returns true, if the message
     * @param {string} clientId id of the client
     * @param {string} topic topic sent
     * @param {object} qos quality of service received from published headers
     * @param {boolean} dup true, if the message is a duplicate
     * @param {string} packetid id of the sender package
     */
    isDuplicateQos2message (clientId, topic, qos, dup, packetid) {
        let isDuplicate = false
        if (qos === 2) {
            const sendClient = this.getClientById(clientId)
            isDuplicate = dup && sendClient.isInQos2Queue(packetid)
            sendClient.addToQos2Queue(packetid, topic)
        }
        return isDuplicate
    }

    /**
     * Adds messages that needs to be published
     * @param {Message} payload message to add to a publish storage
     * @param {object} qos quality of service received from published headers
     * @param {boolean} retain true, if the message should be retained for future subscribers
     */
    publishMessage (payload, qos, retain) {
        for (var clientId in this.clients) {
            if (retain) {
                if (payload.value === undefined || payload.value === '') {
                    delete this.retainMessages[payload.topic]
                } else {
                    this.retainMessages[payload.topic] = { payload, qos }
                }
            }
            const client = this.getClientById(clientId)
            client.publishMessage({ payload, qos })
        }
    }

    /**
     * Acknowledges a message (qos = 1 or 2 only)
     * @param {MessageQueueEntry} queueEntry entry of message queue acknowledged
     */
    acknowledgeMessage (queueEntry) {
        const client = this.getClientById(queueEntry.clientId)
        client.acknowledgeMessageById(queueEntry.payload.topic, queueEntry.packetid)
    }

    /**
     * Gets all messages to send for all clients
     * function to be called for each message. The function has the parameter QoS and message
     * @returns {integer} amount of messages sent
     */
    getAllMessagesToSend () {
        let allMessages = []
        for (const clientId in this.clients) {
            const client = this.clients[clientId]
            if (client.getMaxRetryCount() >= this.configuration.maxRetryCount) {
                client.disconnect()
            }
            const clientMessages = client.getAllMessagesToSend(
                this.configuration.inFlightWindow,
                this.configuration.replyTimeoutInMilliseconds)
            allMessages = [...allMessages, ...clientMessages]
        };
        return allMessages
    }
}
