/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:        Connections.js
 * Purpouse:    Manage connections to the broker
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * Version:     1.0
 * ---------------------------------------------------------------------------------------------------
 */

'use strict';

const Persist = require("@mangar2/persist");
const TopicMatch = require("@mangar2/topicmatch");
const errorLog = require("@mangar2/errorlog");
const CheckInput = require("@mangar2/checkinput");
const Client = require("./client.js");
var persistConnections = new Persist();

/**
 * Check valid configuration options
 */
const checkConfig = new CheckInput({
    type: 'object',
    properties: {
        fileName: {type: 'string'},
        directory: {type: 'string'},
        inFlightWindow: {type: 'number'},
        timeoutInMilliseconds: {type: 'number'},
        maxRetryCount: {type: 'number'},
        maxQueueSize: {type: 'number'}
    },
    required: ['fileName', 'directory']
});


module.exports = class Connections {

    constructor(configuration) {
        if (checkConfig.validate(configuration) !== true) {
            throw "error: " + JSON.stringify(checkConfig.messages, null, 2);
        }
        this.configuration = {
            fileName: configuration.fileName, 
            directory: configuration.directory,
            inFlightWindow: configuration.inFlightWindow || 1,
            timeoutInMilliseconds: configuration.timeoutInMilliseconds || (10 * 1000),
            maxRetryCount: configuration.maxRetryCount || 10
        };

        if (typeof(this.configuration.maxQueuSize) === 'number') {
            Client.setMaxQueueSize(this.configuration.maxQueuSize);
        }
        
        this.retainMessages = {};
        this.clients = {};
        this.tokenMap = {};
    }

    /**
     * Restores all clients from last valid saved file
     */
    async restoreFromFile() {
        let data = persistConnections.readData(
            this.configuration.directory, this.configuration.fileName);
        this.retainMessages = data.retainMessages;
        this.tokenMap = data.tokenMap;
        for (let clientId in data.clients) {
            let clientData = data.clients[clientId];
            this.clients[clientId] = new Client();
            this.clients[clientId].restoreFromJSON(clientData);
        }
    }

    /**
     * Persists all connections
     */
    async persist() {
        await persistConnections.saveObjectToFile(this.configuration.directory, this.configuration.fileName, this);
    }

    /**
     * Gets a client by id
     * @param {any} clientId id of the client
     * @param {boolean} create if true, a client is created, if no clientId available
     * @throws {Error} 
     */
    getClientById(clientId, create = false) {
        if (clientId === undefined) {
            throw Error("Connect without client id (clientId)");
        }

        if (this.clients[clientId] === undefined && create) {
            this.clients[clientId] = new Client(clientId);
        }

        if (this.clients[clientId] === undefined) {
            throw Error("Unknown clientId " + clientId);
        }

        return this.clients[clientId];
    }

    /**
     * Gets a client by token
     * @param {string} token client send token
     * @returns {Client|undefined} undefined, if client was not found
     */
    getClientByToken(token) {
        let client;
        if (token !== undefined) {
            let clientId = this.tokenMap[token];
            if (clientId !== undefined) {
                client = this.getClientById(clientId);
            }
        }
        return client;
    }

    /**
     * Connects a client (Stores a connection to a client)
     * @param {any} clientId id of the client
     * @param {string} host host name
     * @param {string} port port name
     * @param {bool} clean true, if the connection will be cleaned on disconnect
     * @param {string} version client interface version
     * @returns {object} {mqttcode, present} present == 1, if an old session is recovered
     * @throws {Error} 
     */
    connect(clientId, host, port, clean, version) {
        let sessionAvailable = (this.clients[clientId] !== undefined && this.clients[clientId] !== "clean");
        let present = !clean && sessionAvailable ? 1 : 0;
        let client = this.getClientById(clientId, true);
        let sendToken = client.getSendToken();
        if (sendToken !== undefined) {
            delete this.tokenMap[sendToken];
        }
        let token = client.connect(clientId, host, port, clean, version);
        sendToken = client.getSendToken();
        this.tokenMap[sendToken] = clientId;
        return {mqttcode: 0, present, token};
    }

    /**
     * Disconnects a client
     * @param {string} clientId id of the client
     * @throws {Error} 
     */
    disconnect(clientId) {
        let client = this.getClientById(clientId, false);
        client.disconnect(clientId);
    }

    /**
     * Subscribes to topics
     * @param {string} clientId id of the client
     * @param {object} topics {QoS, topics} or {topic1: QoS1, topic2: QoS2, ...}
     * @returns {array} array of QoS values
     */
    subscribe(clientId, topics) {
        let client = this.getClientById(clientId, false);
        // Retain messages are not supported for outdated style topics
        if (topics.topics === undefined) {
            let match = new TopicMatch(topics);
            for (let retainTopic in this.retainMessages) {
                let qos = this.retainMessages[retainTopic].qos;
                let message = this.retainMessages[retainTopic].message;
                client.publishMessage(message, qos, false, match);
            }
        }
        return client.subscribe(clientId, topics);
    }

    /**
     * Unsubsribes to topics
     * @param {string} clientId id of the client
     * @param {array} topics array of topics strings (topic with wildchars '+' and '#')
     */
    unsubscribe(clientId, topics) {
        let client = this.getClientById(clientId, false);
        client.unsubscribe(clientId, topics);
    }

    /**
     * Handles a pubrel message, deleting the entry from the qos2 queue
     * @param {string} token client send token
     * @param {number} packetid unique identifier of the corresponding publish packet
     */
    onPubrel(token, packetid) {
        let client = this.getClientByToken(token);
        if (client !== undefined) {
            client.deleteFromQos2Queue(packetid);
        }
    }

    /**
     * Checks, if a token corresponds to a client. Returns the client
     * @param {string} token 
     * @returns {string|undefined} clientId.
     * @throws {string} error message
     */
    checkToken(token) {
        let clientId = this.tokenMap[token];
        if (clientId !== undefined) {
            return clientId;
        }
        throw "publish message with unknown token";
    }

    /**
     * Checks and remembers a qos2 message. Returns true, if the message 
     * @param {string} clientId id of the client
     * @param {object} qos quality of service received from published headers
     * @param {boolean} dup true, if the message is a duplicate 
     * @param {string} packetid id of the sender package
     */
    isDuplicateQos2message(clientId, qos, dup, packetid) {
        let isDuplicate = false;
        if (qos === 2) {
            let sendClient = this.getClientById(clientId);
            isDuplicate = dup && sendClient.isInQos2Queue(packetid);
            sendClient.addToQos2Queue(packetid);
        }
        return isDuplicate;
    }
    
    /**
     * Adds messages that needs to be published
     * @param {object} message message to add to a publish storage
     * @param {object} qos quality of service received from published headers
     * @param {boolean} retain true, if the message should be retained for future subscribers
     */
    publishMessage(message, qos, retain) {
        for (var clientId in this.clients) {
            if (retain) {
                if (message.value === undefined || message.value === "") {
                    delete this.retainMessages[message.topic];
                } else {
                    this.retainMessages[message.topic] = { message, qos }
                }
            }
            let client = this.clients[clientId];
            client.publishMessage(message, qos);
        }

    }

    /**
     * Deletes a message from the message list
     * @param {object} messageList message list of current client
     * @param {string} topic message topic
     * @param {string} id id of the message to delete
     */
    deleteMessageFromList(messageList, topic, id) {
        let message = messageList[topic];
        let isMessageDefined = message !== undefined;
        if (isMessageDefined && message.id == id && message.QoS <= 1) {
            delete messageList[topic];
        }
    }

    /**
     * @param {string} host host to send message to
     * @param {string} port port to send message to
     * @param {object} messageQueueEntry message to send
     * @param {function} callback(options) function to call
     */
    async sendMessage(client, messageQueueEntry, callback) {
        let {host, port, version} = client;
        let token = client.token.receive;  // client view, they receive the "receive-token"
        let message = messageQueueEntry.getPayload();
        let qos = messageQueueEntry.getQoS();
        let dup = messageQueueEntry.getDup();
        let link = messageQueueEntry.isPubrel() ? "pubrel" : "publish";
        let topic = message.topic;
        let packetid = qos == 1 || qos == 2 ? messageQueueEntry.getId() : undefined;
        let options = { host, port, link, token, message, qos, dup, version, packetid }
        try {
            let result = await callback(options);

            let queuedMessageSent = result && (qos === 1 || (qos === 2 & messageQueueEntry.isPubrel()));
            let sendPubrel = result && qos === 2 && !messageQueueEntry.isPubrel();

            if (queuedMessageSent) {
                client.deleteMessageById(topic, packetid);
            } else if (sendPubrel) {
                // Directly send qos2 pubrel message to not wait until the next sendAllMessage loop
                messageQueueEntry.setPubrel();
                await this.sendMessage(client, messageQueueEntry, callback);
            }
        } catch (err) {
            errorLog(err);
        }

    }

    /**
     * Sends all messages to a client
     * @param {Client} client client structure
     * @param {function} callback callback sending messages
     * @returns {integer} amount of messages sent
     */
    sendClientMessages(client, callback) {
        let messagesSent = 0;
        client.processQoS0Messages(messageQueueEntry => {
            messagesSent++;
            this.sendMessage(client, messageQueueEntry, callback);
        })
        for (let topic in client.orderedTopicsQueue) {

            client.processOrderedTopicMessages(topic, this.configuration.inFlightWindow, this.configuration.timeoutInMilliseconds,
                messageQueueEntry => {
                    messagesSent++;
                    this.sendMessage(client, messageQueueEntry, callback);
            })
        }
        return messagesSent;
    }

    /**
     * Processes all messages needed to send
     * @param {function} callback(host, port, message, QoS, id, successCallback) 
     * function to be called for each message. The function has the parameter QoS and message
     * @returns {integer} amount of messages sent
     */
    sendAllMessages(callback) {
        let messagesSent = 0;
        for (var clientId in this.clients) {
            var client = this.clients[clientId];
            if (client.getMaxRetryCount() >= this.configuration.maxRetryCount) {
                client.disconnect(clientId);
            }
            if (client.isConnected()) {
                messagesSent += this.sendClientMessages(client, callback);
            }
        };
        return messagesSent;
    }

}

