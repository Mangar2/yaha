/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:        MessageQueueEntry.js
 * Purpouse:    Slot of a queue holding a message to transmit
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

'use strict'

const Message = require('@mangar2/message')

module.exports = class MessageQueueEntry {
    /**
     *
     * @param {object} param parameter object
     * @param {number} [param.qos=0] quality of service (0, 1 or 2)
     * @param {boolean} [param.retain=false] true, if the message is triggered by a retain message
     * @param {Message} [param.payload={}] payload of the entry
     * @param {number} param.packetid id of the transmit packet
     * @param {string} param.clientId id of the client
     * @param {string} param.host host name or ip address of the client
     * @param {number} param.port port number of the client
     * @param {string} [param.version='1.0'] version number of the client interface (x.y)
     * @param {string} param.token client receive token
     */
    constructor (param = {}) {
        // Quality of service to transmit the payload
        this.qos = param.qos || 0
        this.retain = param.retain || false
        // Any payload
        this.payload = param.payload || {}
        // Unique packetid to identify the entry (optional)
        this.packetid = param.packetid
        // Timestamp the payload was transmitted
        this.transmitTimestamp = 0
        // Status of the entry
        this.status = 'new'
        // Amount of retries to transmit the playload
        this.retryCount = 0

        this.clientId = param.clientId
        this.host = param.host
        this.port = param.port
        this.version = param.version || '1.0'
        this.token = param.token
    }

    /**
     * @type {Message|object} the payload of the message
     */
    get payload () { return this._payload }
    set payload (payload) { this._payload = payload }

    /**
     * @type {number} id of the transfer packet
     */
    get packetid () { return this._packetid }
    set packetid (packetid) { this._packetid = packetid }

    /**
     * @type {number} 0,1 or 2: mqtt quality of service, accepts string, default 0
     */
    get qos () { return this._qos }
    set qos (qos) {
        this._qos = Number(qos)
        if (this._qos !== 1 && this._qos !== 2) {
            this._qos = 0
        }
    }

    /**
     * @type {number} 1 signals that it is a duplicate (has been send before), accepts also
     * true/false or '1'/'0' instead of 1/0
     */
    get dup () { return this.retryCount > 1 ? 1 : 0 }
    set dup (dup) {
        this._dup = dup === true || dup === 'true' || dup === 1 || dup === '1' ? 1 : 0
    }

    /**
     * @type {0|1} 1 signals that a message is send due to a retain subscription
     */
    get retain () { return this._retain }
    set retain (retain) { this._retain = retain }

    /**
     * @type {string} id of the client
     */
    get clientId () { return this._clientId }
    set clientId (clientId) { this._clientId = clientId }

    /**
     * @type {string} status of the entry {new, duplicate, pubrel}
     */
    get status () { return this._status }
    set status (status) { this._status = status }

    /**
     * @type {string} version of the interface to use 'major.minor'
     */
    get version () { return this._version }
    set version (version) { this._version = version }

    /**
     * @returns {number} timestamp of the last message transmit
     */
    get transmitTimestamp () { return this._transmitTimestamp }
    set transmitTimestamp (transmitTimestamp) { this._transmitTimestamp = transmitTimestamp }

    /**
     * @type {number} amount of retries to send the package
     */
    get retryCount () { return this._retryCount }
    set retryCount (retryCount) { this._retryCount = retryCount }

    /**
     * @type {string} the client receive token
     */
    get token () { return this._token }
    set token (token) { this._token = token }

    /**
     * @type {string} link to use for sending
     */
    get link () { return this._link }
    set link (link) { this._link = link }

    /**
     * @type {string} host name of the client
     */
    get host () { return this._host }
    set host (host) { this._host = host }

    /**
     * @type {number} port number of the client
     */
    get port () { return this._port }
    set port (port) { this._port = port }

    /**
     * Creates a message object from a java script object
     * @param {object} payload payload
     * @param {string} payload.topic topic of the message
     * @param {(number|string)} payload.value value of the message
     * @param {{timestamp: number, message: string}[]} payload.reason array of reasons why the message occured
     */
    createMessage (payload) {
        let result
        try {
            result = new Message(payload.topic, payload.value, payload.reason)
        } catch (err) {
            result = payload
        }
        return result
    }

    /**
     * Restore the object by setting all properties (usually from a file)
     * @param {object} properties object with all needed properties of this class.
     */
    restoreFromObject (properties) {
        for (const property in this) {
            this[property] = properties[property]
        }
        this.payload = this.createMessage(this.payload)
    }

    /**
     * Sets infos of the client
     * @param {string} clientId id of the client
     * @param {string} host host name of the client
     * @param {number} port port number of the client
     * @param {string} version client interface version
     * @param {string} token token clients may check receiving published messages
     */
    setClientInfo (clientId, host, port, version, token) {
        this.clientId = clientId
        this.host = host
        this.port = port
        this.version = version
        this.token = token
    }

    /**
     * Sets the status to pubrel
     */
    setStatusToPubrel () {
        this.status = 'pubrel'
        this.retryCount = 0
    }

    /**
     * increases the retry counter and stores the actual timestamp
     */
    setTransmissionTimestamp () {
        const now = (new Date()).getTime()
        this._transmitTimestamp = now
        this.retryCount++
    }

    /**
     * Checks, if the status is pubrel
     * @returns {boolean}
     */
    isStatusPubrel () {
        return this.status === 'pubrel'
    }

    /**
     * Gets the link to send the message to (/publish or /pubrel)
     * @returns {string} link
     */
    get link () {
        if (this.status === 'pubrel') {
            return '/pubrel'
        } else {
            return '/publish'
        }
    }
}
