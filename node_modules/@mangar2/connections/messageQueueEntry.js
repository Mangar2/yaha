/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:        MessageQueueEntry.js
 * Purpouse:    Slot of a queue holding a message to transmit
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * Version:     1.0
 * ---------------------------------------------------------------------------------------------------
 */

'use strict'

const Message = require('@mangar2/message')

module.exports = class MessageQueueEntry {
    /**
     *
     * @param {Number} QoS quality of service (0, 1 or 2)
     * @param {any} payload
     */
    constructor (qos = 0, payload = {}) {
        // Quality of service to transmit the payload
        this.qos = qos
        // Any payload
        this.payload = payload
        // Unique packetid to identify the entry (optional)
        this.packetid = undefined
        // Timestamp the payload was transmitted
        this._transmitTimestamp = 0
        // Status of the entry
        this.status = 'new'
        // Amount of retries to transmit the playload
        this.retryCount = 0
    }

    /**
     * @returns {object} the payload of the message
     */
    get payload () { return this._payload }

    /**
     * @param {object} payload payload of the entry
     */
    set payload (payload) { this._payload = payload }

    /**
     * @returns {number} id of the transfer packet
     */
    get packetid () { return this._packetid }

    /**
     * @param {string} packetid id of the transfer packet
     */
    set packetid (packetid) { this._packetid = packetid }

    /**
     * @returns {number} 0,1 or 2: mqtt quality of service
     */
    get qos () { return this._qos }

    /**
     * @param {string|number} qos quality of service (0, 1, 2)
     */
    set qos (qos) {
        this._qos = Number(qos)
        if (this._qos !== 1 && this._qos !== 2) {
            this._qos = 0
        }
    }

    /**
     * @returns {0|1} 1 signals that it is a duplicate (has been send before)
     */
    get dup () { return this.retryCount > 1 ? 1 : 0 }

    /**
     * @param {boolean|string|number} dup duplicate flag (true/false or 1/0 or '1'/'0')
     */
    set dup (dup) {
        this._dup = dup === true || dup === 'true' || dup === 1 || dup === '1' ? 1 : 0
    }

    /**
     * @returns {string} id of the client
     */
    get clientId () { return this._clientId }

    /**
     * @param {string} clientId id of the client
     */
    set clientId (clientId) { this._clientId = clientId }

    /**
     * @returns {string} status of the entry {new, duplicate, pubrel}
     */
    get status () { return this._status }

    /**
     * @param {string} status new status {new, sent, duplicate, pubrel}
     */
    set status (status) { this._status = status }

    /**
     * @returns {string} interface version of the entry
     */
    get version () { return this._version }

    /**
     * @param {string} version of the interface to use 'major.minor'
     */
    set version (version) { this._version = version }

    /**
     * @returns {number} timestamp of the last message transmit
     */
    get transmitTimestamp () { return this._transmitTimestamp }

    /**
     * @returns {number} amount of retries to send the package
     */
    get retryCount () { return this._retryCount }

    /**
     * @param {number} amount of retries to send the package
     */
    set retryCount (retryCount) { this._retryCount = retryCount }

    /**
     * @returns {string} the client receive token
     */
    get token () { return this._token }

    /**
     * @param {string} token the client receive token
     */
    set token (token) { this._token = token }

    /**
     * Creates a message object from a java script object
     * @param {object} payload payload
     * @param {string} payload.topic topic of the message
     * @param {(number|string)} payload.value value of the message
     * @param {{timestamp: number, message: string}[]} payload.reason array of reasons why the message occured
     */
    createMessage (payload) {
        let result
        try {
            result = new Message(payload.topic, payload.value, payload.reason)
        } catch (err) {
            result = payload
        }
        return result
    }

    /**
     * Restore the object by setting all properties (usually from a file)
     * @param {object} properties object with all needed properties of this class.
     */
    restoreFromObject (properties) {
        for (const property in properties) {
            this[property] = properties[property]
        }
        this.payload = this.createMessage(this.payload)
    }

    /**
     * Sets infos of the client
     * @param {string} clientId id of the client
     * @param {string} host host name of the client
     * @param {number} port port number of the client
     * @param {string} version client interface version
     * @param {string} token token clients may check receiving published messages
     */
    setClientInfo (clientId, host, port, version, token) {
        this.clientId = clientId
        this.host = host
        this.port = port
        this.version = version
        this.token = token
    }

    /**
     * Sets the status to pubrel
     */
    setStatusToPubrel () {
        this.status = 'pubrel'
        this.retryCount = 0
    }

    /**
     * increases the retry counter and stores the actual timestamp
     */
    setTransmissionTimestamp () {
        const now = (new Date()).getTime()
        this._transmitTimestamp = now
        this.retryCount++
    }

    /**
     * Checks, if the status is pubrel
     * @returns {boolean}
     */
    isStatusPubrel () {
        return this.status === 'pubrel'
    }

    /**
     * Gets the link to send the message to (/publish or /pubrel)
     * @returns {string} link
     */
    get link () {
        if (this.status === 'pubrel') {
            return '/pubrel'
        } else {
            return '/publish'
        }
    }
}
