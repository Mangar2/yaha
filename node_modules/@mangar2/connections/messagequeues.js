/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const MessageQueueEntry = require('./messageQueueEntry')

/**
 * Creates an empty message queue
 */
class MessageQueues {
    constructor () {
        this.queues = {}
    }

    /**
     * Gets/sets the queues
     * @returns {{topic: queue, topic: queue, ...}} object of queues
     */
    get queues () { return this._queues }
    set queues (queues) { this._queues = queues }

    /**
     * Recreates the message queue from persistend data
     * @param {object} data format {topic: queue, topic: queue, ...}
     */
    rebuild (data) {
        this.queues = {}
        for (const topic in data._queues) {
            this.queues[topic] = []
            const queue = data._queues[topic]
            for (const index in queue) {
                const entry = queue[index]
                this.queues[topic][index] = new MessageQueueEntry()
                this.queues[topic][index].restoreFromObject(entry)
            }
        }
    }

    /**
     * Adds a message, cuts the queue to maxQueueSize, if too long
     * @param {MessageQueueEntry} entry entry of the message queue
     * @param {number} maxQueueSize maximal number of entries in queue
     */
    addMessage (entry, maxQueueSize) {
        const message = entry.payload
        const topic = message.topic

        if (!Array.isArray(this.queues[topic])) {
            this.queues[topic] = []
        }
        this.queues[topic].push(entry)
        if (this.queues[topic].length > maxQueueSize) {
            this.queues[topic].slice(0, 1)
        }
    }

    /**
     * Acknowledges a message, either delete it or set it to pubrel
     * @param {string} topic topic to delete message from
     * @param {Number} packetid id of the message
     */
    acknowledgeMessageById (topic, packetid) {
        const messageQueue = this.queues[topic]
        if (Array.isArray(messageQueue)) {
            for (const index in messageQueue) {
                const entry = messageQueue[index]
                if (entry.packetid === packetid) {
                    if (entry.qos === 2 && !entry.isStatusPubrel()) {
                        entry.setStatusToPubrel()
                    } else {
                        messageQueue.splice(index, 1)
                    }
                    break
                }
            }
        }
    }

    /**
     * @private
     * get messages to send for a topic
     * @param {string} topic topic of the messages
     * @param {number} inFlightWindow maximal amount of messages to process
     * @param {number} timeoutInMilliseconds timeout waiting for messages
     */
    _getTopicMessagesToSend (topic, inFlightWindow, timeoutInMilliseconds) {
        let count = 0
        const now = (new Date()).getTime()
        const result = []
        for (const entry of this.queues[topic]) {
            if (entry.status === 'new') {
                entry.status = 'sending'
            } else if (entry.status === 'pubrel') {
                // do nothing, keep status
            } else if (entry.transmitTimestamp + timeoutInMilliseconds < now) {
                entry.status = 'duplicate'
            } else {
                break
            }
            entry.setTransmissionTimestamp()
            result.push(entry)
            count++
            if (count === inFlightWindow) break
        }
        return result
    }

    /**
     * get messages to send for a topic
     * @param {number} inFlightWindow maximal amount of messages to process
     * @param {number} timeoutInMilliseconds timeout waiting for messages
     */
    getMessagesToSend (inFlightWindow, timeoutInMilliseconds) {
        let result = []
        for (const topic in this.queues) {
            const messages = this._getTopicMessagesToSend(
                topic, inFlightWindow, timeoutInMilliseconds)
            result = [...result, ...messages]
        }
        return result
    }

    /**
     * Gets the maximal retry count for a client
     * @returns the maximal retry count of the first elements of all topics
     */
    getMaxRetryCount () {
        let result = 0
        for (const topic in this.queues) {
            const queue = this.queues[topic]
            // We only check the first entry, as all following entries may not have a higher
            // retry count
            if (queue.length > 0) {
                const entry = queue[0]
                if (entry.retryCount > result) {
                    result = entry.retryCount
                }
            }
        }
        return result
    }

    /**
     * clears all retry counts
     * @returns undefined
     */
    clearRetryCount () {
        for (const topic in this.queues) {
            const queue = this.queues[topic]
            for (const entry of queue) {
                entry.retryCount = 0
            }
        }
    }
}

module.exports = MessageQueues
