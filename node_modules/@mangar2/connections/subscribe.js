/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

/**
 * Converts a QoS to a valid QoS. (0,1,2) by converting it to Number and setting it to
 * "0" on any invalid entry
 * @param {any} Qos QoS to transform
 * @return {Number} valid QoS
 */
function convertQoSToValidQoS (QoS) {
    var numberQoS = Number(QoS)
    if (numberQoS !== 1 && numberQoS !== 2) {
        numberQoS = 0
    }
    return numberQoS
}

/**
 * Adds a subscription to the connection
 * @param {object} subscribe {QoS:Qos, topics:[topic1, topic2, ...]}
 * @throws {Error} if clientId does not match or subscription is not given
 */
function subscribeOldFormat (subscribe) {
    const QoS = this.convertQoSToValidQoS(subscribe.QoS)
    const topics = subscribe.topics
    const result = []

    if (!Array.isArray(topics)) {
        this.subscribePattern.setPattern(topics, QoS)
        result.push(QoS)
    } else {
        for (const topic of topics) {
            this.subscribePattern.setPattern(topic, QoS)
            result.push(QoS)
        };
    }
    return result
}

/**
 * Adds a subscription to the connection
 * @param {any} clientId id of the client
 * @param {object} topics {topic1:QoS1, topic2:Qos2, ...}
 * @returns {number[]} subscribe quality of services array
 */
function subscribe (topics) {
    let result = []
    if (topics.topics === undefined) {
        for (const topic in topics) {
            const qos = convertQoSToValidQoS(topics[topic])
            result.push(qos)
            this.subscribePattern.setPattern(topic, qos)
        }
    } else {
        result = subscribeOldFormat(topics)
    }
    return result
}

module.exports = subscribe
