const Connections = require("@mangar2/connections");
const Message = require("@mangar2/message");
const UnitTest = require("@mangar2/unittest");
const Persist = require("@mangar2/persist");

connections = new Connections({
    fileName: "connectionData", 
    directory: ".", 
    timeoutInMilliseconds:10,
    maxRetryCount:10
});

async function cleanFiles() {
    await Persist.deleteOldFiles(".", "connectionData", 0);
}

var unitTest = new UnitTest(false);


Message0 = new Message("topic/0", "value0", "reason0");
Message1 = new Message("topic/1", "value1", "reason1");
Message2 = new Message("topic/2", "value2", "reason2");



function connect() {
    let connectResult = {};
    connectResult["client0"] = connections.connect("client0", "host0", "port0", false);
    connectResult["client1"] = connections.connect("client1", "host1", "port1", true);
    return connectResult;
}
function disconnect() {
    connections.disconnect("client0");
    connections.disconnect("client1");
}
function subscribe() {
    connections.subscribe("client0", {"topic/0": 0});
    connections.subscribe("client0", {"topic/1": 1});
    connections.subscribe("client0", {"topic/2": 2});
    connections.subscribe("client1", {"topic/0": 2, "topic/1": 0, "topic/2": 1});
}
function unsubscribe() {
    connections.unsubscribe("client0", "topic/1");
    connections.unsubscribe("client1", "#");
}
function queueMessages(retain) {
    connections.publishMessage(Message0, 0, retain);
    connections.publishMessage(Message1, 1, retain);
    connections.publishMessage(Message2, 2, retain);
}

let lastId = {};
async function sendAllMessages(expectedMessages, errorText) {
    let receivedMessages = 0;
    connections.sendAllMessages(async (options) => {
        let {host, port, token, message, qos, packetid} = options;
        if (unitTest.verbose) {
            console.log("host %s, port %s, message %s, QoS %s, id %s", host, port, JSON.stringify(message), qos, packetid);
        }
        unitTest.assertTrue(token === "receiveclient0" || token === "receiveclient1", "correct token");
        let topic = message.topic;
        if (lastId[host] === undefined) {
            lastId[host] = {};
        }
        let _lastId = lastId[host][topic];
        if (packetid != undefined && _lastId !== undefined) {
            unitTest.assertTrue(packetid >= _lastId, "topic: " + topic + " " + packetid + " >= " + _lastId, false);
        }
        lastId[host][topic] = packetid;
        receivedMessages++;
        return true;
    });
    unitTest.assertEqual(expectedMessages, receivedMessages, errorText);
}

/**
 * Sends all messages, but does not inform about the result
 */
function sendAllMessageNotReturningId() {
    connections.sendAllMessages(async (host, port, token, message, headers) => {});
}

(async () => {    
    /**
     * Test connecting, sending messages
     */
    let connectResult = connect();
    for (let client of ["client0", "client1"]) {
        unitTest.assertEqual(connectResult[client].mqttcode, 0, "connect 1 " + client);
        unitTest.assertEqual(connectResult[client].present, 0, "connect 2 " + client);
    }
    subscribe();
    queueMessages();
    await sendAllMessages(6, "test subscribed");
    await sendAllMessages(0, "test subscribed, messages sent")

    /**
     * Check qos2 functions
     */
    let clientid = connections.checkToken(connectResult["client0"].token.send);
    unitTest.assertEqual(clientid, "client0", "check token 1");
    clientid = connections.checkToken(connectResult["client1"].token.send);
    unitTest.assertEqual(clientid, "client1", "check token 2");
    unitTest.expectException(()=> {connections.checkToken("client2");}, "string", "String");

    unitTest.assertFalse(connections.isDuplicateQos2message("client0", 0, true, 1), "duplicateQos2 1"); 
    unitTest.assertFalse(connections.isDuplicateQos2message("client0", 1, false, 1), "duplicateQos2 2"); 
    // a qos1 message with dup flag is treated as duplicate message
    unitTest.assertFalse(connections.isDuplicateQos2message("client0", 1, true, 1), "duplicateQos2 3"); 
    // the first qos2 messag with dup flag is NOT a duplicate
    unitTest.assertFalse(connections.isDuplicateQos2message("client0", 2, true, 1), "duplicateQos2 4"); 
    unitTest.assertTrue(connections.isDuplicateQos2message("client0", 2, true, 1), "duplicateQos2 5"); 
    // Packet 2 is unknown
    unitTest.assertFalse(connections.isDuplicateQos2message("client0", 2, true, 2), "duplicateQos2 6"); 
    // Received without duplicate flag, it is not a duplicate message!
    unitTest.assertFalse(connections.isDuplicateQos2message("client0", 2, false, 2), "duplicateQos2 7");
    // Pubrel received, removes duplicate entries
    connections.onPubrel(connectResult["client0"].token.send, 1);
    connections.onPubrel(connectResult["client0"].token.send, 2);
    unitTest.assertFalse(connections.isDuplicateQos2message("client0", 2, true, 1), "duplicateQos2 8"); 
    unitTest.assertFalse(connections.isDuplicateQos2message("client0", 2, true, 2), "duplicateQos2 9"); 
    unitTest.assertTrue(connections.isDuplicateQos2message("client0", 2, true, 1), "duplicateQos2 10"); 
    unitTest.assertTrue(connections.isDuplicateQos2message("client0", 2, true, 2), "duplicateQos2 11"); 
    // The packet idÂ´s are client specific and thus it is not a duplicate for client1 even, if the packet id matches
    unitTest.assertFalse(connections.isDuplicateQos2message("client1", 2, true, 1), "duplicateQos2 12"); 
    unitTest.assertFalse(connections.isDuplicateQos2message("client1", 2, true, 2), "duplicateQos2 13"); 

    /**
     * Test disconnect
     */
    connectResult = connect();
    // not clean ...
    unitTest.assertEqual(connectResult["client0"].present, 1, "connect 3 ");
    unitTest.assertEqual(connectResult["client1"].present, 0, "connect 4 ");

    subscribe();
    queueMessages();
    disconnect();
    await sendAllMessages(0, "test disconnected");
    connect();
    await sendAllMessages(2, "test reconnect");

    /**
     * Test unsubscribe
     */
    connect();
    subscribe();
    unsubscribe();
    queueMessages();
    await sendAllMessages(2, "test unsubscribe");

    /**
     * Test unuccessful and successful sending messages
     */
    connect();
    subscribe();
    for (let i = 0; i < 10; i++) { 
        queueMessages(); 
    }
    // Send message is not successful
    sendAllMessageNotReturningId();
    // Send messages immediately will not do anything (test retry below timeout)
    await sendAllMessages(0, "in retry timeout");
    await unitTest.delay(15);
    // after a timeout delay sending messages works ...
    for (let i = 0; i < 10; i++) {
        await sendAllMessages(3, "after retry timeout");
    }
    // Check that all messages are processed
    await unitTest.delay(15);
    await sendAllMessages(0, "no message left");

    /**
     * Test auto disconnect
     */
    connect();
    subscribe();
    queueMessages();

    for (let i = 0; i <= 5; i++) {
        sendAllMessageNotReturningId();
        await unitTest.delay(15);
    }
    await sendAllMessages(3, "not yet disconnected");
    queueMessages();
    for (let i = 0; i <= 8; i++) {
        sendAllMessageNotReturningId();
        await unitTest.delay(15);
    }
    // 3 messages, because client0 has two messages and client0 one
    await sendAllMessages(3, "not yet disconnected");
    queueMessages();
    for (let i = 0; i <= 10; i++) {
        sendAllMessageNotReturningId();
        await unitTest.delay(15);
    }
    await sendAllMessages(0, "auto disconnected");
    connect();
    // Two messages, because client1 is clean after connect
    await sendAllMessages(2, "reconnect after auto disconnect");

    /**
     * Test retain messages
     */
    const RETAIN = true;
    connect();
    subscribe();
    connections.publishMessage(new Message("topic/0", "", "reason0"), 0, RETAIN);
    await sendAllMessages(2, "retain, receive message with empty value");
    queueMessages(RETAIN);
    await sendAllMessages(6, "retain, receive messages normally");
    await sendAllMessages(0, "retain, check no message left to send");
    subscribe();
    await sendAllMessages(6, "retain, message received due to retain");
    disconnect();
    connect();
    await sendAllMessages(0, "retain, no messages after reconnect");
    connections.publishMessage(new Message("topic/0", "", "reason0"), 0, RETAIN);
    connections.publishMessage(new Message("topic/1", "", "reason1"), 0, RETAIN);
    connections.publishMessage(new Message("topic/2", "", "reason2"), 0, RETAIN);
    await sendAllMessages(3, "retain, send empty retain messages, one client is clean");
    subscribe();
    await sendAllMessages(0, "retain, all retain messages deleted");

    /**
     * Test persistence
     */
    connect();
    subscribe();
    queueMessages();
    await connections.persist();
    await sendAllMessages(6, "persisted");
    await sendAllMessages(0, "all messages sent");
    disconnect();
    await connections.restoreFromFile();
    await sendAllMessages(6, "restored");
    
    await cleanFiles();

    unitTest.showResult(178);

})();


