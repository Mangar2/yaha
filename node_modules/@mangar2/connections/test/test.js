const Connections = require('@mangar2/connections')
const Message = require('@mangar2/message')
const UnitTest = require('@mangar2/unittest')
const Persist = require('@mangar2/persist')

const config = {
    fileName: 'connectionData',
    directory: '.',
    replyTimeoutInMilliseconds: 10,
    pubrelTimeoutInMilliseconds: 1000,
    maxRetryCount: 10
}

var connections = new Connections(config)

async function cleanFiles () {
    await Persist.deleteOldFiles('.', 'connectionData', 0)
}

var unitTest = new UnitTest(false)

var Message0 = new Message('topic/0', 'value0', 'reason0')
var Message1 = new Message('topic/1', 'value1', 'reason1')
var Message2 = new Message('topic/2', 'value2', 'reason2')

function connect (keepAlive) {
    const connectResult = {}
    connectResult.client0 = connections.connect('client0', 'host0', 'port0', false, '1.0', keepAlive)
    connectResult.client1 = connections.connect('client1', 'host1', 'port1', true, '1.0', keepAlive)
    return connectResult
}
function disconnect () {
    connections.disconnect('client0')
    connections.disconnect('client1')
}
function subscribe () {
    connections.subscribe('client0', { 'topic/0': 0 })
    connections.subscribe('client0', { 'topic/1': 1 })
    connections.subscribe('client0', { 'topic/2': 2 })
    return connections.subscribe('client1', { 'topic/0': 2, 'topic/1': 0, 'topic/2': 1 })
}
function unsubscribe () {
    connections.unsubscribe('client0', 'topic/1')
    connections.unsubscribe('client1', '#')
}
function queueMessages (retain) {
    connections.publishMessage(Message0, 0, retain)
    connections.publishMessage(Message1, 1, retain)
    connections.publishMessage(Message2, 2, retain)
}

function getAllMessages (publishExpected, pubrelExpected, errorText) {
    const messages = connections.getAllMessagesToSend()
    const receivedMessages = { '/publish': 0, '/pubrel': 0 }

    const lastId = {}
    for (const message of messages) {
        const { host, packetid, payload, qos, link } = message
        const topic = payload.topic

        lastId[host] = lastId[host] || {}
        // check for correct token
        unitTest.assertTrue(message.token === 'receiveclient0' || message.token === 'receiveclient1', 'correct token')

        if (qos === 0) {
            unitTest.assertEqual(packetid, undefined, 'qos0 packet id must be undefined')
        } else {
            unitTest.assertEqual(typeof (packetid), 'number', 'qos > 0 packet id´s must be numbers')
            // check for rising packetid´s
            const _lastId = lastId[host][topic]
            if (packetid !== undefined && _lastId !== undefined) {
                unitTest.assertTrue(packetid >= _lastId, 'topic: ' + topic + ' ' + packetid + ' >= ' + _lastId)
            }
            connections.acknowledgeMessage(message)
        }
        receivedMessages[link]++
        lastId[host][topic] = packetid
    }
    unitTest.assertEqual(publishExpected, receivedMessages['/publish'], errorText)
    unitTest.assertEqual(pubrelExpected, receivedMessages['/pubrel'], errorText)
}

/**
 * Sends all messages, but does not inform about the result
 */
function getAllMessagesNoAcknowledge () {
    connections.getAllMessagesToSend()
}

/**
 * Test subscribe when disconnected
 */
async function testActionsWhileDisconnected () {
    connect()
    disconnect()
    disconnect()
    const result = subscribe()
    unitTest.assertDeepEqual(result, [0x80], 'subscribe while beeing disconnected')
    unitTest.expectException(() => unsubscribe(), 'Error', 'unsubscribe beeing disconnected')
    queueMessages()
    getAllMessages(0, 0, 'tests beeing disconnected 1')
    connect()
    getAllMessages(2, 0, 'tests beeing disconnected 2')
    getAllMessages(0, 1, 'tests beeing disconnected 2')
    getAllMessages(0, 0, 'tests beeing disconnected 2')
    disconnect()
}

/**
 * Test connecting, sending messages, must be the first test case
 */
async function testSendMessages () {
    const connectResult = connect()
    for (const client of ['client0', 'client1']) {
        unitTest.assertEqual(connectResult[client].mqttcode, 0, 'connect 1 ' + client)
        unitTest.assertEqual(connectResult[client].present, 0, 'connect connection present flag ' + client)
    }
    subscribe()
    queueMessages()
    getAllMessages(6, 0, 'test subscribed')
    getAllMessages(0, 1, 'test subscribed')
    getAllMessages(0, 0, 'test subscribed, messages sent')
}

/**
 * Check qos2 functions
 */
async function testQos2Functions () {
    const connectResult = connect()
    let clientId = connections.checkToken(connectResult.client0.token.send)
    unitTest.assertEqual(clientId, 'client0', 'check token 1')
    clientId = connections.checkToken(connectResult.client1.token.send)
    unitTest.assertEqual(clientId, 'client1', 'check token 2')
    unitTest.expectException(() => { connections.checkToken('client2') }, 'Error')

    let clientAndTopic = ['client0', 'topic/2']
    let id = 1
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, true, 1), 'duplicateQos2 ' + id++)
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 1, false, 1), 'duplicateQos2 ' + id++)
    // a qos1 message with dup flag is not treated as duplicate message
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 1, true, 1), 'duplicateQos2 ' + id++)
    // the first qos2 messag is NOT a duplicate even, if it has a dup flag
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 1), 'duplicateQos2 ' + id++)
    // The second qos2 message with dup flag is a duplicate
    unitTest.assertTrue(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 1), 'duplicateQos2 ' + id++)
    // The third is still a duplicate ...
    unitTest.assertTrue(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 1), 'duplicateQos2 ' + id++)
    // But not after a timeout
    await unitTest.delay(config.pubrelTimeoutInMilliseconds + 100)
    connections.cleanup()
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 1), 'duplicateQos2 ' + id++)
    // Packet 2 is unknown
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 2), 'duplicateQos2 ' + id++)
    // Received without duplicate flag, it is not a duplicate message!
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 2, false, 2), 'duplicateQos2 ' + id++)
    // Pubrel received, removes duplicate entries
    connections.onPubrel(connectResult.client0.token.send, 1)
    connections.onPubrel(connectResult.client0.token.send, 2)
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 1), 'duplicateQos2 ' + id++)
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 2), 'duplicateQos2 ' + id++)
    unitTest.assertTrue(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 1), 'duplicateQos2 ' + id++)
    unitTest.assertTrue(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 2), 'duplicateQos2 ' + id++)
    // connection cleaned, remove duplicate entries
    connections.connect('client0', 'host0', 'port0', true)
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 1), 'duplicateQos2 ' + id++)
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 2), 'duplicateQos2 ' + id++)

    // The packet id´s are client specific and thus it is not a duplicate for client1 even, if the packet id matches
    clientAndTopic = ['client1', 'topic/2']
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 1), 'duplicateQos2 ' + id++)
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 2), 'duplicateQos2 ' + id++)
    // Clean client 0
    connections.connect('client0', 'host0', 'port0', true)
}

/**
 * Test disconnect
 */
function testDisconnect () {
    const connectResult = connect()
    // not clean ...
    unitTest.assertEqual(connectResult.client0.present, 1, 'connect 3 ')
    unitTest.assertEqual(connectResult.client1.present, 0, 'connect 4 ')

    subscribe()
    queueMessages()
    disconnect()
    // As everything is disconnected we should not send any message
    getAllMessages(0, 0, 'test disconnected')
    connect()
    // client2 is clean, ony client 1 packages will be received
    getAllMessages(2, 0, 'test reconnect, publish')
    getAllMessages(0, 1, 'test reconnect, pubrel')
}

/**
 * Test unsubscribe
 */
async function testUnsubscribe () {
    connect()
    subscribe()
    unsubscribe()
    queueMessages()
    // Client1 receives a qos0 and a qos2 message
    getAllMessages(2, 0, 'test unsubscribe, publish')
    getAllMessages(0, 1, 'test unsubscribe, pubrel')
}

/**
 * Test unuccessful and successful sending messages
 * @param {number} amount amount of queueMessage loop, must be a multiple of 2
 */
async function testUnsuccessfulSend (amount) {
    connect()
    subscribe()
    for (let i = 0; i < amount; i++) {
        queueMessages()
    }
    // Send message is not successful
    getAllMessagesNoAcknowledge()
    // Send messages immediately will not do anything (test retry below timeout)
    getAllMessages(0, 0, 'in retry timeout')
    await unitTest.delay(15)
    // after a timeout delay sending messages works ...
    for (let i = 0; i < amount / 2; i++) {
        // Publish 3 messages
        getAllMessages(3, 0, 'after retry timeout, publish')
        // Pubrel for the qos2 message, publish for the qos1 message
        getAllMessages(2, 1, 'after retry timeout, pubrel')
    }
    for (let i = 0; i < amount / 2; i++) {
        // now following pubrel messages
        getAllMessages(1, 0, 'after retry timeout, publish 2')
        getAllMessages(0, 1, 'after retry timeout, pubrel')
    }
    // Check that all messages are processed
    await unitTest.delay(15)
    getAllMessages(0, 0, 'no message left')
}

/**
 * Test auto disconnect
 */
async function testAutoDisconnect (loopAmount) {
    connect()
    subscribe()
    queueMessages()
    for (let i = 0; i <= loopAmount; i++) {
        getAllMessagesNoAcknowledge()
        await unitTest.delay(15)
    }
    if (loopAmount < config.maxRetryCount) {
        getAllMessages(3, 0, 'not yet disconnected, publish')
        getAllMessages(0, 1, 'not yet disconnected, pubrel')
    } else {
        getAllMessages(0, 0, 'auto disconnected')
        connect()
        // Two messages, because client1 is clean after connect
        getAllMessages(2, 0, 'reconnect after auto disconnect')
        getAllMessages(0, 1, 'reconnect after auto disconnect')
    }
    getAllMessages(0, 0, 'auto disconnect check no messages left')
}

/**
 * Checks the disconnect of inactive clients
 */
async function testKeepAlive () {
    const keepAlive = 500
    const mqttDisconnectFactor = 1.5
    for (const delay of [50, 200, 400, 600, 1000]) {
        connect(keepAlive)
        await unitTest.delay(delay)
        connections.cleanup()
        queueMessages()
        const messageStart = 'keepAlive delay ' + delay + ' '
        if (delay < keepAlive * mqttDisconnectFactor) {
            getAllMessages(3, 0, messageStart + 'not yet disconnected, publish')
            getAllMessages(0, 1, messageStart + 'not yet disconnected, pubrel')
        } else {
            getAllMessages(0, 0, messageStart + 'auto disconnected')
            connect()
            // Two messages, because client1 is clean after connect
            getAllMessages(2, 0, messageStart + 'reconnect after auto disconnect')
            getAllMessages(0, 1, messageStart + 'reconnect after auto disconnect')
        }
        getAllMessages(0, 0, messageStart + 'auto disconnect check no messages left')
    }
}

async function testWill () {
    const keepAlive = 100
    connect(keepAlive)
    connections.setWill('client1', { qos: 1, retain: false, topic: 'will/a', value: 1 })
    connections.unsubscribe('client0', ['#'])
    connections.subscribe('client0', { 'will/a': 1 })
    await unitTest.delay(200)
    connections.cleanup()
    connect()
    getAllMessages(1, 0, 'will message')
    getAllMessages(0, 0, 'will message')
}

/**
 * Test retain messages
 */
function testRetain () {
    const RETAIN = true
    connect()
    subscribe()
    connections.publishMessage(new Message('topic/0', '', 'reason0'), 0, RETAIN)
    getAllMessages(2, 0, 'retain, receive message with empty value')
    queueMessages(RETAIN)
    getAllMessages(6, 0, 'retain, receive messages normally')
    getAllMessages(0, 1, 'retain, receive messages normally')
    getAllMessages(0, 0, 'retain, check no message left to send')
    subscribe()
    getAllMessages(6, 0, 'retain, message received due to retain')
    getAllMessages(0, 1, 'retain, message received due to retain')
    disconnect()
    connect()
    getAllMessages(0, 0, 'retain, no messages after reconnect')
    connections.publishMessage(new Message('topic/0', '', 'reason0'), 0, RETAIN)
    connections.publishMessage(new Message('topic/1', '', 'reason1'), 0, RETAIN)
    connections.publishMessage(new Message('topic/2', '', 'reason2'), 0, RETAIN)
    getAllMessages(3, 0, 'retain, send empty retain messages, one client is clean')
    subscribe()
    getAllMessages(0, 0, 'retain, all retain messages deleted')
}

/**
 * Test persistence
 */
async function testPersistence () {
    connect()
    subscribe()
    queueMessages()
    await connections.persist()

    const restored = new Connections(config)
    await restored.restoreFromFile()

    unitTest.assertDeepEqual(connections, restored, 'test')

    getAllMessages(6, 0, 'restored')
    getAllMessages(0, 1, 'restored')

    await cleanFiles()
}

(async () => {
    await testSendMessages()
    await testActionsWhileDisconnected()

    await testQos2Functions()

    await testDisconnect()
    await testUnsubscribe()
    await testUnsuccessfulSend(10)

    await testAutoDisconnect(5)
    await testAutoDisconnect(8)
    await testAutoDisconnect(10)

    await testKeepAlive()
    await testWill()

    await testRetain()
    await testPersistence()

    unitTest.showResult(401)
})()
