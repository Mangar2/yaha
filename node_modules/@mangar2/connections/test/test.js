const Connections = require("@mangar2/connections")
const Message = require("@mangar2/message")
const UnitTest = require("@mangar2/unittest")
const Persist = require("@mangar2/persist")

let config = {
    fileName: "connectionData", 
    directory: ".", 
    timeoutInMilliseconds:10,
    maxRetryCount:10
}

connections = new Connections(config);

async function cleanFiles() {
    await Persist.deleteOldFiles(".", "connectionData", 0)
}

var unitTest = new UnitTest(false)


Message0 = new Message("topic/0", "value0", "reason0")
Message1 = new Message("topic/1", "value1", "reason1")
Message2 = new Message("topic/2", "value2", "reason2")



function connect() {
    let connectResult = {}
    connectResult["client0"] = connections.connect("client0", "host0", "port0", false)
    connectResult["client1"] = connections.connect("client1", "host1", "port1", true)
    return connectResult
}
function disconnect() {
    connections.disconnect("client0")
    connections.disconnect("client1")
}
function subscribe() {
    connections.subscribe("client0", {"topic/0": 0})
    connections.subscribe("client0", {"topic/1": 1})
    connections.subscribe("client0", {"topic/2": 2})
    connections.subscribe("client1", {"topic/0": 2, "topic/1": 0, "topic/2": 1})
}
function unsubscribe() {
    connections.unsubscribe("client0", "topic/1")
    connections.unsubscribe("client1", "#")
}
function queueMessages(retain) {
    connections.publishMessage(Message0, 0, retain)
    connections.publishMessage(Message1, 1, retain)
    connections.publishMessage(Message2, 2, retain)
}

function getAllMessages(publishExpected, pubrelExpected, errorText) {
    let messages = connections.getAllMessagesToSend();
    let receivedMessages = {"/publish":0, "/pubrel":0}
    
    let lastId = {};
    for (let message of messages) {
        let {host, clientId, packetid, payload, qos} = message;
        let topic = payload.topic;
        let link = message.getLink();
        lastId[host] = lastId[host] || {}
        // check for correct token
        unitTest.assertTrue(message.token === "receiveclient0" || message.token === "receiveclient1", "correct token")
        
        if (qos === 0) {
            unitTest.assertEqual(packetid, undefined, "qos0 packet id must be undefined");
        } else {
            unitTest.assertEqual(typeof(packetid), 'number', "qos > 0 packet id´s must be numbers");
            // check for rising packetid´s 
            let _lastId = lastId[host][topic]
            if (packetid != undefined && _lastId !== undefined) {
                unitTest.assertTrue(packetid >= _lastId, "topic: " + topic + " " + packetid + " >= " + _lastId);
            }
            connections.acknowledgeMessage(clientId, topic, packetid);
        }
        receivedMessages[link]++;
        lastId[host][topic] = packetid;
    }
    unitTest.assertEqual(publishExpected, receivedMessages["/publish"], errorText)
    unitTest.assertEqual(pubrelExpected, receivedMessages["/pubrel"], errorText)
}

/**
 * Sends all messages, but does not inform about the result
 */
function getAllMessagesNoAcknowledge() {
    connections.getAllMessagesToSend();
}

/**
 * Test connecting, sending messages
 */
async function testSendMessages() {
    let connectResult = connect()
    for (let client of ["client0", "client1"]) {
        unitTest.assertEqual(connectResult[client].mqttcode, 0, "connect 1 " + client)
        unitTest.assertEqual(connectResult[client].present, 0, "connect 2 " + client)
    }
    subscribe()
    queueMessages()
    getAllMessages(6, 0, "test subscribed")
    getAllMessages(0, 1, "test subscribed")
    getAllMessages(0, 0, "test subscribed, messages sent")
}

/**
 * Check qos2 functions
 */
function testQos2Functions() {
    
    let connectResult = connect()
    let clientId = connections.checkToken(connectResult["client0"].token.send)
    unitTest.assertEqual(clientId, "client0", "check token 1")
    clientId = connections.checkToken(connectResult["client1"].token.send)
    unitTest.assertEqual(clientId, "client1", "check token 2")
    unitTest.expectException(()=> {connections.checkToken("client2")}, "string", "String")
    
    let clientAndTopic = ["client0", "topic/2"];
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, true, 1), "duplicateQos2 1") 
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 1, false, 1), "duplicateQos2 2") 
    // a qos1 message with dup flag is treated as duplicate message
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 1, true, 1), "duplicateQos2 3") 
    // the first qos2 messag is NOT a duplicate even, if it has a dup flag
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 1), "duplicateQos2 4") 
    // The second qos2 message with dup flag is a duplicate
    unitTest.assertTrue(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 1), "duplicateQos2 5") 
    // Packet 2 is unknown
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 2), "duplicateQos2 6") 
    // Received without duplicate flag, it is not a duplicate message!
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 2, false, 2), "duplicateQos2 7")
    // Pubrel received, removes duplicate entries
    connections.onPubrel(connectResult["client0"].token.send, 1)
    connections.onPubrel(connectResult["client0"].token.send, 2)
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 1), "duplicateQos2 8") 
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 2), "duplicateQos2 9") 
    unitTest.assertTrue(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 1), "duplicateQos2 10") 
    unitTest.assertTrue(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 2), "duplicateQos2 11") 
    // connection cleaned, remove duplicate entries
    connections.connect("client0", "host0", "port0", true)
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 1), "duplicateQos2 12") 
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 2), "duplicateQos2 13") 

    // The packet id´s are client specific and thus it is not a duplicate for client1 even, if the packet id matches
    clientAndTopic = ["client1", "topic/2"];
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 1), "duplicateQos2 14") 
    unitTest.assertFalse(connections.isDuplicateQos2message(...clientAndTopic, 2, true, 2), "duplicateQos2 15") 
    // Clean client 0
    connections.connect("client0", "host0", "port0", true)
}

/**
 * Test disconnect
 */
function testDisconnect() {
    let connectResult = connect()
    // not clean ...
    unitTest.assertEqual(connectResult["client0"].present, 1, "connect 3 ")
    unitTest.assertEqual(connectResult["client1"].present, 0, "connect 4 ")

    subscribe()
    queueMessages()
    disconnect()
    // As everything is disconnected we should not send any message
    getAllMessages(0, 0, "test disconnected")
    connect()
    // client2 is clean, ony client 1 packages will be received
    getAllMessages(2, 0, "test reconnect, publish")
    getAllMessages(0, 1, "test reconnect, pubrel")
}

/**
 * Test unsubscribe
 */
async function testUnsubscribe() {
    connect()
    subscribe()
    unsubscribe()
    queueMessages()
    // Client1 receives a qos0 and a qos2 message
    getAllMessages(2, 0, "test unsubscribe, publish")
    getAllMessages(0, 1, "test unsubscribe, pubrel")
}

/**
 * Test unuccessful and successful sending messages
 * @param {number} amount amount of queueMessage loop, must be a multiple of 2
 */
async function testUnsuccessfulSend(amount) {
    connect()
    subscribe()
    for (let i = 0; i < amount; i++) { 
        queueMessages() 
    }
    // Send message is not successful
    getAllMessagesNoAcknowledge()
    // Send messages immediately will not do anything (test retry below timeout)
    getAllMessages(0, 0, "in retry timeout")
    await unitTest.delay(15)
    // after a timeout delay sending messages works ...
    for (let i = 0; i < amount / 2; i++) {
        // Publish 3 messages 
        getAllMessages(3, 0, "after retry timeout, publish")
        // Pubrel for the qos2 message, publish for the qos1 message
        getAllMessages(2, 1, "after retry timeout, pubrel")
    }
    for (let i = 0; i < amount / 2; i++) {
        // now following pubrel messages
        getAllMessages(1, 0, "after retry timeout, publish 2")
        getAllMessages(0, 1, "after retry timeout, pubrel")
    }
    // Check that all messages are processed
    await unitTest.delay(15)
    getAllMessages(0, 0, "no message left")
}

/**
 * Test auto disconnect
 */
async function testAutoDisconnect(loopAmount) {
    connect()
    subscribe()
    queueMessages()
    for (let i = 0; i <= loopAmount; i++) {
        getAllMessagesNoAcknowledge()
        await unitTest.delay(15)
    }
    if (loopAmount < config.maxRetryCount) {
        getAllMessages(3, 0, "not yet disconnected, publish")
        getAllMessages(0, 1, "not yet disconnected, pubrel")
    } else {
        getAllMessages(0, 0, "auto disconnected")
        connect()
        // Two messages, because client1 is clean after connect
        getAllMessages(2, 0, "reconnect after auto disconnect")
        getAllMessages(0, 1, "reconnect after auto disconnect")
    }
    getAllMessages(0, 0, "auto disconnect check no messages left")
}



/**
 * Test retain messages
 */
function testRetain() {    
    const RETAIN = true
    connect()
    subscribe()
    connections.publishMessage(new Message("topic/0", "", "reason0"), 0, RETAIN)
    getAllMessages(2, 0, "retain, receive message with empty value")
    queueMessages(RETAIN)
    getAllMessages(6, 0, "retain, receive messages normally")
    getAllMessages(0, 1, "retain, receive messages normally")
    getAllMessages(0, 0, "retain, check no message left to send")
    subscribe()
    getAllMessages(6, 0, "retain, message received due to retain")
    getAllMessages(0, 1, "retain, message received due to retain")
    disconnect()
    connect()
    getAllMessages(0, 0, "retain, no messages after reconnect")
    connections.publishMessage(new Message("topic/0", "", "reason0"), 0, RETAIN)
    connections.publishMessage(new Message("topic/1", "", "reason1"), 0, RETAIN)
    connections.publishMessage(new Message("topic/2", "", "reason2"), 0, RETAIN)
    getAllMessages(3, 0, "retain, send empty retain messages, one client is clean")
    subscribe()
    getAllMessages(0, 0, "retain, all retain messages deleted")
}


/**
 * Test persistence
 */
async function testPersistence() {
    connect()
    subscribe()
    queueMessages()
    await connections.persist()
    const connectionString = JSON.stringify(connections);
    getAllMessages(6, 0, "persisted")
    getAllMessages(0, 1, "persisted")
    getAllMessages(0, 0, "all messages sent")
    disconnect()
    await connections.restoreFromFile()
    const readString = JSON.stringify(connections);
    let old = JSON.parse(connectionString)
    unitTest.assertEqual(connectionString, readString, "persist identical");
    getAllMessages(6, 0, "restored")
    getAllMessages(0, 1, "restored")
    
    await cleanFiles()
}

(async () => {    

    await testSendMessages();

    testQos2Functions();

    await testDisconnect();
    await testUnsubscribe();
    await testUnsuccessfulSend(10);

    await testAutoDisconnect(5);
    await testAutoDisconnect(8);
    await testAutoDisconnect(10);

    await testRetain();
    await testPersistence();


    unitTest.showResult(327)

})()


