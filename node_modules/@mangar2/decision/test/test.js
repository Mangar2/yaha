/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const DEBUG = false
const types = require('@mangar2/types')
const Decision = require('@mangar2/decision')
const UnitTest = require('@mangar2/unittest')

const unitTest = new UnitTest(DEBUG, DEBUG)

const variables = {
    'a/b': 1,
    'b/c': 2,
    'system/presence': 'awake'
}

/**
 * Tests all kind of operators
 */
function testCompareOperators () {
    const decision = new Decision(variables)
    const tests = [
        { operators: ['equal', 'equals', '='], variables: { 'a/b': 1, 'b/c': 2 }, result: true },
        { operators: ['equal', 'equals', '='], variables: { 'a/b': 0, 'b/c': 1 }, result: false },
        { operators: ['not equal', 'not equals', '!=', '<>'], variables: { 'a/b': 1, 'b/c': 2 }, result: false },
        { operators: ['not equal', 'not equals', '!=', '<>'], variables: { 'a/b': 0, 'b/c': 1 }, result: true },
        { operators: ['below', 'less', '<'], variables: { 'a/b': 0, 'b/c': 1 }, result: false },
        { operators: ['below', 'less', '<'], variables: { 'a/b': 1, 'b/c': 2 }, result: false },
        { operators: ['below', 'less', '<'], variables: { 'a/b': 2, 'b/c': 3 }, result: true },
        { operators: ['above', 'greater', '>'], variables: { 'a/b': 0, 'b/c': 1 }, result: true },
        { operators: ['above', 'greater', '>'], variables: { 'a/b': 1, 'b/c': 2 }, result: false },
        { operators: ['above', 'greater', '>'], variables: { 'a/b': 2, 'b/c': 3 }, result: false },
        { operators: ['below or equal', 'less or equal', '<='], variables: { 'a/b': 0, 'b/c': 1 }, result: false },
        { operators: ['below or equal', 'less or equal', '<='], variables: { 'a/b': 1, 'b/c': 2 }, result: true },
        { operators: ['below or equal', 'less or equal', '<='], variables: { 'a/b': 2, 'b/c': 3 }, result: true },
        { operators: ['above or equal', 'greater or equal', '>='], variables: { 'a/b': 0, 'b/c': 1 }, result: true },
        { operators: ['above or equal', 'greater or equal', '>='], variables: { 'a/b': 1, 'b/c': 2 }, result: true },
        { operators: ['above or equal', 'greater or equal', '>='], variables: { 'a/b': 2, 'b/c': 3 }, result: false }
    ]
    for (const test of tests) {
        for (const operator of test.operators) {
            for (const variable in test.variables) {
                const value = test.variables[variable]
                const term = [operator, variable, value]
                const result = test.result
                const evalResult = decision.eval(term)
                unitTest.assertEqual(evalResult.value, result, evalResult.reason)
            }
        }
    }
}

/**
 * Runs a test configuration
 * @param {Object} testCase test case
 * @param {Object} testCase.varables test variables (name: value)
 * @param {Array} testCase.tests list of test
 */
function runTest (testCase) {
    const variables = testCase.variables
    for (const variable in variables) {
        const value = variables[variable]
        if (types.isString(value) && value.includes(':')) {
            const date = new Date()
            const chunks = value.split(':')
            date.setHours(chunks[0], chunks[1], 0, 0)
            variables[variable] = date
        }
    }
    const decision = new Decision(variables)
    decision.on('test', (param) => {
        return param
    })
    for (const test of testCase.tests) {
        let result
        try {
            result = decision.eval(test.tree)
        } catch (err) {
            result = { value: false, reason: err.message }
        }
        const value = types.getType(result.value) === 'Date' ? result.value.toLocaleTimeString() : result.value
        if (value !== test.result) {
            decision.eval(test.tree)
        }
        unitTest.assertEqual(value, test.result, test.name)
        if (test.reason !== undefined) {
            unitTest.assertEqual(result.reason, test.reason, test.name)
        } else {
            unitTest.log(result.reason)
        }
    }
}

try {
    // Simply test all supported operators
    testCompareOperators()
    const files = [
        'strings',
        'if',
        'and_or',
        'math',
        'switch',
        'complex',
        'callback'
    ]
    for (const file of files) {
        runTest(require('./' + file + '.json'))
    }
} catch (err) {
    console.log(err.stack)
    unitTest.fail(err.message)
}

unitTest.showResult(162)
