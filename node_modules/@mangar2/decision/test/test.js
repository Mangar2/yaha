/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const Decision = require('@mangar2/decision')
const UnitTest = require('@mangar2/unittest')

const unitTest = new UnitTest(true, true)

const variables = {
    'a/b': 1,
    'b/c': 2,
    'system/presence': 'awake'
}
const decision = new Decision(variables)
decision.on('test', (param) => { return param })

/**
 * Tests all kind of operators
 */
function testCompareOperators () {
    const tests = [
        { operators: ['equal', 'equals', '='], variables: { 'a/b': 1, 'b/c': 2 }, result: true },
        { operators: ['equal', 'equals', '='], variables: { 'a/b': 0, 'b/c': 1 }, result: false },
        { operators: ['not equal', 'not equals', '!=', '<>'], variables: { 'a/b': 1, 'b/c': 2 }, result: false },
        { operators: ['not equal', 'not equals', '!=', '<>'], variables: { 'a/b': 0, 'b/c': 1 }, result: true },
        { operators: ['below', 'less', '<'], variables: { 'a/b': 0, 'b/c': 1 }, result: false },
        { operators: ['below', 'less', '<'], variables: { 'a/b': 1, 'b/c': 2 }, result: false },
        { operators: ['below', 'less', '<'], variables: { 'a/b': 2, 'b/c': 3 }, result: true },
        { operators: ['above', 'greater', '>'], variables: { 'a/b': 0, 'b/c': 1 }, result: true },
        { operators: ['above', 'greater', '>'], variables: { 'a/b': 1, 'b/c': 2 }, result: false },
        { operators: ['above', 'greater', '>'], variables: { 'a/b': 2, 'b/c': 3 }, result: false },
        { operators: ['below or equal', 'less or equal', '<='], variables: { 'a/b': 0, 'b/c': 1 }, result: false },
        { operators: ['below or equal', 'less or equal', '<='], variables: { 'a/b': 1, 'b/c': 2 }, result: true },
        { operators: ['below or equal', 'less or equal', '<='], variables: { 'a/b': 2, 'b/c': 3 }, result: true },
        { operators: ['above or equal', 'greater or equal', '>='], variables: { 'a/b': 0, 'b/c': 1 }, result: true },
        { operators: ['above or equal', 'greater or equal', '>='], variables: { 'a/b': 1, 'b/c': 2 }, result: true },
        { operators: ['above or equal', 'greater or equal', '>='], variables: { 'a/b': 2, 'b/c': 3 }, result: false }
    ]
    for (const test of tests) {
        for (const operator of test.operators) {
            for (const variable in test.variables) {
                const value = test.variables[variable]
                const operands = [variable, value]
                const result = test.result
                const decisionResult = decision.decide({ operator, operands })
                unitTest.assertEqual(decisionResult.decision, result, decisionResult.reason)
            }
        }
    }
}

function testUnaryLogicalOperators () {
    let result
    const operators = ['and', 'or']
    for (const operator of operators) {
        for (const variable of ['a/b', 'b/c']) {
            // simple operator with unair and
            const tree = {}
            const value = variables[variable]
            tree[operator] = { operator: 'equal', operands: [variable, value] }
            result = decision.decide(tree)
            unitTest.assertTrue(result.decision, result.reason)
            unitTest.assertEqual(result.reason, 'Reason: ' + variable + ' (' + value + ') is equal to ' + value)
            tree[operator] = [{ operator: 'equal', operands: [variable, value] }]
            unitTest.assertTrue(result.decision, result.reason)
            unitTest.assertEqual(result.reason, 'Reason: ' + variable + ' (' + value + ') is equal to ' + value)
        }
    }
}

function testAnd () {
    let result
    for (const variable of ['a/b', 'b/c']) {
        // simple operator with unair and
        const tree = {}
        const value = variables[variable]
        tree.and = []
        for (let amount = 0; amount <= 5; amount++) {
            tree.and.push({ operator: 'equal', operands: [variable, value] })
            result = decision.decide(tree)
            unitTest.assertTrue(result.decision, result.reason)
            tree.and.push({ operator: 'equal', operands: [variable, value + 1] })
            result = decision.decide(tree)
            unitTest.assertFalse(result.decision, result.reason)
            tree.and.pop()
        }
    }
}

function testOr () {
    let result
    for (const variable of ['a/b', 'b/c']) {
        // simple operator with unair and
        const tree = {}
        const value = variables[variable]
        tree.or = []
        for (let amount = 0; amount <= 5; amount++) {
            tree.or.push({ operator: 'not equal', operands: [variable, value] })
            result = decision.decide(tree)
            unitTest.assertFalse(result.decision, result.reason)
            tree.or.push({ operator: 'not equal', operands: [variable, value + 1] })
            result = decision.decide(tree)
            unitTest.assertTrue(result.decision, result.reason)
            tree.or.pop()
        }
    }
}

try {
    // Simply test all supported operators
    testCompareOperators()
    testUnaryLogicalOperators()
    testAnd()
    testOr()
    let result = decision.decide({
        and: [{
            operator: 'below',
            operands: ['a/b', 18]
        },
        {
            operator: 'below',
            operands: ['b/c', 23]
        }]
    })
    unitTest.assertTrue(result.decision, result.reason)
    // correct decision with variable lookup table
    result = decision.decide({
        and: [{
            operator: 'below',
            operands: ['a/b', 16]
        },
        {
            operator: 'above',
            operands: [
                'b/c',
                {
                    variable: 'system/presence',
                    map: {
                        absent: 2,
                        awake: 1,
                        sleeping: 3
                    }
                }
            ]
        }]

    })
    unitTest.assertTrue(result.decision, result.reason)
    // wrong decision with variable lookup table
    result = decision.decide({
        and: [{
            operator: 'below',
            operands: ['a/b', 16]
        },
        {
            operator: 'above',
            operands: [
                'b/c',
                {
                    variable: 'system/presence',
                    map: {
                        absent: 1,
                        awake: 2,
                        sleeping: 3
                    }
                }
            ]
        }]

    })
    unitTest.assertFalse(result.decision, result.reason)
    // Recursive
    result = decision.decide({
        and: [{
            or: [{
                operator: 'below',
                operands: ['a/b', 10]
            },
            {
                operator: 'below',
                operands: ['b/c', 2]
            }]
        },
        {
            or: [{
                operator: 'above or equal',
                operands: ['a/b', 10]
            },
            {
                operator: 'above or equal',
                operands: ['b/c', 2]
            }]
        }]
    })
    unitTest.assertTrue(result.decision, result.reason)

    // Exceptions
    unitTest.expectException(() => decision.decide({ operator: 'unknown', operands: ['a/b', 10] }), 'Error')
    unitTest.expectException(() => decision.decide({ operator: 'above', operands: ['a/b/c', 10] }), 'Error')
    unitTest.expectException(() => decision.decide({ operator: 'above', operands: ['a/b'] }), 'Error')
    unitTest.expectException(() => decision.decide({ operator: 'above', operands: ['a/b', 'a'] }), 'Error')
    unitTest.expectException(() => decision.decide({ and: true, or: true }), 'Error')
    unitTest.expectException(() => decision.decide({ function: 'test', param: [true] }), 'Error')
    unitTest.expectException(() => decision.decide({ function: 'test', parameter: true }), 'Error')

    // Callbacks
    result = decision.decide({ function: 'test', parameter: [true] })
    unitTest.assertTrue(result.decision, result.reason)
} catch (err) {
    unitTest.fail(err.message)
    console.log(err)
}

unitTest.showResult(176)
