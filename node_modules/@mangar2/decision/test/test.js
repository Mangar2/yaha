/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const Decision = require('@mangar2/decision')
const UnitTest = require('@mangar2/unittest')

const unitTest = new UnitTest(true, true)

const variables = {
    'a/b': 1,
    'b/c': 2,
    'system/presence': 'awake'
}

/**
 * Tests all kind of operators
 */
function testCompareOperators () {
    const decision = new Decision(variables)
    const tests = [
        { operators: ['equal', 'equals', '='], variables: { 'a/b': 1, 'b/c': 2 }, result: true },
        { operators: ['equal', 'equals', '='], variables: { 'a/b': 0, 'b/c': 1 }, result: false },
        { operators: ['not equal', 'not equals', '!=', '<>'], variables: { 'a/b': 1, 'b/c': 2 }, result: false },
        { operators: ['not equal', 'not equals', '!=', '<>'], variables: { 'a/b': 0, 'b/c': 1 }, result: true },
        { operators: ['below', 'less', '<'], variables: { 'a/b': 0, 'b/c': 1 }, result: false },
        { operators: ['below', 'less', '<'], variables: { 'a/b': 1, 'b/c': 2 }, result: false },
        { operators: ['below', 'less', '<'], variables: { 'a/b': 2, 'b/c': 3 }, result: true },
        { operators: ['above', 'greater', '>'], variables: { 'a/b': 0, 'b/c': 1 }, result: true },
        { operators: ['above', 'greater', '>'], variables: { 'a/b': 1, 'b/c': 2 }, result: false },
        { operators: ['above', 'greater', '>'], variables: { 'a/b': 2, 'b/c': 3 }, result: false },
        { operators: ['below or equal', 'less or equal', '<='], variables: { 'a/b': 0, 'b/c': 1 }, result: false },
        { operators: ['below or equal', 'less or equal', '<='], variables: { 'a/b': 1, 'b/c': 2 }, result: true },
        { operators: ['below or equal', 'less or equal', '<='], variables: { 'a/b': 2, 'b/c': 3 }, result: true },
        { operators: ['above or equal', 'greater or equal', '>='], variables: { 'a/b': 0, 'b/c': 1 }, result: true },
        { operators: ['above or equal', 'greater or equal', '>='], variables: { 'a/b': 1, 'b/c': 2 }, result: true },
        { operators: ['above or equal', 'greater or equal', '>='], variables: { 'a/b': 2, 'b/c': 3 }, result: false }
    ]
    for (const test of tests) {
        for (const operator of test.operators) {
            for (const variable in test.variables) {
                const value = test.variables[variable]
                const term = [operator, variable, value]
                const result = test.result
                const evalResult = decision.eval(term)
                unitTest.assertEqual(evalResult.value, result, evalResult.reason)
            }
        }
    }
}

function testUnaryLogicalOperators () {
    const decision = new Decision(variables)
    let result
    const operators = ['and', 'or']
    for (const operator of operators) {
        for (const variable of ['a/b', 'b/c']) {
            // simple operator with unair and
            const value = variables[variable]
            let tree = [operator, ['equal', variable, value]]
            result = decision.eval(tree)
            unitTest.assertTrue(result.value, result.reason)
            unitTest.assertEqual(result.reason, variable + ' (' + value + ') is equal to ' + value)
            tree = [operator, ['equal', variable, value]]
            unitTest.assertTrue(result.value, result.reason)
            unitTest.assertEqual(result.reason, variable + ' (' + value + ') is equal to ' + value)
        }
    }
}

function testAnd () {
    const decision = new Decision(variables)
    let result
    for (const variable of ['a/b', 'b/c']) {
        // simple operator with unair and
        const tree = ['and']
        const value = variables[variable]
        for (let amount = 0; amount <= 5; amount++) {
            tree.push(['equal', variable, value])
            result = decision.eval(tree)
            unitTest.assertTrue(result.value, result.reason)
            tree.push(['equal', variable, value + 1])
            result = decision.eval(tree)
            unitTest.assertFalse(result.value, result.reason)
            tree.pop()
        }
    }
}

function testOr () {
    const decision = new Decision(variables)
    let result
    for (const variable of ['a/b', 'b/c']) {
        // simple operator with unair and
        const tree = ['or']
        const value = variables[variable]
        tree.or = []
        for (let amount = 0; amount <= 5; amount++) {
            tree.push(['not equal', variable, value])
            result = decision.eval(tree)
            unitTest.assertFalse(result.value, result.reason)
            tree.push(['not equal', variable, value + 1])
            result = decision.eval(tree)
            unitTest.assertTrue(result.value, result.reason)
            tree.pop()
        }
    }
}

function testMathOperators () {
    const decision = new Decision(variables)
    let result = decision.eval(['-', 5, 3])
    unitTest.assertEqual(result.value, 2, result.reason)
    unitTest.assertEqual(result.reason, '2 (5 - 3)', result.reason)

    result = decision.eval(['-', 'time', 10])
    unitTest.assertEqual(result.value, false, result.reason)
    unitTest.assertEqual(result.reason, 'false, undefined variables: time', result.reason)

    const time = new Date()
    time.setHours(10, 0, 0, 0)
    decision.variables = { time }
    result = decision.eval(['-', 'time', 10])
    time.setMinutes(time.getMinutes() - 10)
    unitTest.assertEqual(result.value, time, result.reason)
    unitTest.assertEqual(result.reason, '09:50:00 (time (10:00:00) - 10)', result.reason)
}

function testSwitch () {
    const decision = new Decision(variables)
    let result = decision.eval(
        ['switch', 'a/b', { 1: 'a', 2: 'b', default: 'c' }]
    )
    unitTest.assertEqual(result.value, 'a', result.reason)

    result = decision.eval(
        ['switch', 'a/b', { 2: 'a', 1: 'b', default: 'c' }]
    )
    unitTest.assertEqual(result.value, 'b', result.reason)

    result = decision.eval(
        ['switch', 'a/b', { 3: 'a', 4: 'b', default: 'c' }]
    )
    unitTest.assertEqual(result.value, 'c', result.reason)

    result = decision.eval(
        ['switch', ['=', 'a/b', 1], { true: 'on', false: 'off' }]
    )
    unitTest.assertEqual(result.value, 'on', result.reason)
}

function testComplexFunctions () {
    const decision = new Decision(variables)
    let result = decision.eval(
        ['and', ['below', 'a/b', 18], ['below', 'b/c', 23]]
    )
    unitTest.assertTrue(result.value, result.reason)
    // correct decision with case
    result = decision.eval(
        [
            'and',
            ['below', 'a/b', 16],
            ['above', 'b/c', ['switch', 'system/presence', { absent: 2, awake: 1, sleeping: 3 }]]
        ]

    )
    unitTest.assertTrue(result.value, result.reason)
    // wrong decision with case
    result = decision.eval(
        [
            'and',
            ['below', 'a/b', 16],
            ['above', 'b/c', ['switch', 'system/presence', { absent: 1, awake: 2, sleeping: 3 }]]
        ]

    )
    unitTest.assertFalse(result.value, result.reason)
    // Recursive
    result = decision.eval(
        [
            'and',
            ['or', ['below', 'a/b', 10], ['below', 'b/c', 2]],
            ['or', ['above or equal', 'a/b', 10], ['above or equal', 'b/c', 2]]
        ]
    )
    unitTest.assertTrue(result.value, result.reason)
}

function testErrors () {
    const decision = new Decision(variables)
    unitTest.expectException(() => decision.eval([undefined, 'a/b', 10]), 'Error')
    let result = decision.eval(['above', 'a/b/c', 10])
    unitTest.assertFalse(result.value)
    unitTest.assertEqual(result.reason, 'false, undefined variables: a/b/c', result.reason)
    unitTest.expectException(() => decision.eval(['above', 'a/b']), 'Error')
    result = decision.eval(['above', 'a/b', 'a'])
    unitTest.assertEqual(result.variables.a, undefined, result.reason)
    unitTest.expectException(() => decision.eval(['call', 'test', true]), 'Error')
}

function testCallbacks () {
    const decision = new Decision()
    decision.on('test', (param) => { return param })
    const result = decision.eval(['call', 'test', true])
    unitTest.assertTrue(result.value, result.reason)
}

try {
    // Simply test all supported operators
    testCompareOperators()
    testUnaryLogicalOperators()
    testAnd()
    testOr()
    testMathOperators()
    testComplexFunctions()
    testCallbacks()
    testErrors()
    testSwitch()
} catch (err) {
    console.log(err.stack)
    unitTest.fail(err.message)
}

unitTest.showResult(184)
