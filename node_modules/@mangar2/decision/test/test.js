/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const Decision = require('@mangar2/decision')
const UnitTest = require('@mangar2/unittest')

const unitTest = new UnitTest(true, true)

const variables = {
    'a/b': 1,
    'b/c': 2,
    'system/presence': 'awake'
}
const decision = new Decision(variables)
decision.on('test', (param) => { return param })

/**
 * Tests all kind of operators
 */
function testCompareOperators () {
    const tests = [
        { operators: ['equal', 'equals', '='], variables: { 'a/b': 1, 'b/c': 2 }, result: true },
        { operators: ['equal', 'equals', '='], variables: { 'a/b': 0, 'b/c': 1 }, result: false },
        { operators: ['not equal', 'not equals', '!=', '<>'], variables: { 'a/b': 1, 'b/c': 2 }, result: false },
        { operators: ['not equal', 'not equals', '!=', '<>'], variables: { 'a/b': 0, 'b/c': 1 }, result: true },
        { operators: ['below', 'less', '<'], variables: { 'a/b': 0, 'b/c': 1 }, result: false },
        { operators: ['below', 'less', '<'], variables: { 'a/b': 1, 'b/c': 2 }, result: false },
        { operators: ['below', 'less', '<'], variables: { 'a/b': 2, 'b/c': 3 }, result: true },
        { operators: ['above', 'greater', '>'], variables: { 'a/b': 0, 'b/c': 1 }, result: true },
        { operators: ['above', 'greater', '>'], variables: { 'a/b': 1, 'b/c': 2 }, result: false },
        { operators: ['above', 'greater', '>'], variables: { 'a/b': 2, 'b/c': 3 }, result: false },
        { operators: ['below or equal', 'less or equal', '<='], variables: { 'a/b': 0, 'b/c': 1 }, result: false },
        { operators: ['below or equal', 'less or equal', '<='], variables: { 'a/b': 1, 'b/c': 2 }, result: true },
        { operators: ['below or equal', 'less or equal', '<='], variables: { 'a/b': 2, 'b/c': 3 }, result: true },
        { operators: ['above or equal', 'greater or equal', '>='], variables: { 'a/b': 0, 'b/c': 1 }, result: true },
        { operators: ['above or equal', 'greater or equal', '>='], variables: { 'a/b': 1, 'b/c': 2 }, result: true },
        { operators: ['above or equal', 'greater or equal', '>='], variables: { 'a/b': 2, 'b/c': 3 }, result: false }
    ]
    for (const test of tests) {
        for (const operator of test.operators) {
            for (const variable in test.variables) {
                const value = test.variables[variable]
                const term = [operator, variable, value]
                const result = test.result
                const decisionResult = decision.decide(term)
                unitTest.assertEqual(decisionResult.decision, result, decisionResult.reason)
            }
        }
    }
}

function testUnaryLogicalOperators () {
    let result
    const operators = ['and', 'or']
    for (const operator of operators) {
        for (const variable of ['a/b', 'b/c']) {
            // simple operator with unair and
            const value = variables[variable]
            let tree = [operator, ['equal', variable, value]]
            result = decision.decide(tree)
            unitTest.assertTrue(result.decision, result.reason)
            unitTest.assertEqual(result.reason, variable + ' (' + value + ') is equal to ' + value)
            tree = [operator, ['equal', variable, value]]
            unitTest.assertTrue(result.decision, result.reason)
            unitTest.assertEqual(result.reason, variable + ' (' + value + ') is equal to ' + value)
        }
    }
}

function testAnd () {
    let result
    for (const variable of ['a/b', 'b/c']) {
        // simple operator with unair and
        const tree = ['and']
        const value = variables[variable]
        for (let amount = 0; amount <= 5; amount++) {
            tree.push(['equal', variable, value])
            result = decision.decide(tree)
            unitTest.assertTrue(result.decision, result.reason)
            tree.push(['equal', variable, value + 1])
            result = decision.decide(tree)
            unitTest.assertFalse(result.decision, result.reason)
            tree.pop()
        }
    }
}

function testOr () {
    let result
    for (const variable of ['a/b', 'b/c']) {
        // simple operator with unair and
        const tree = ['or']
        const value = variables[variable]
        tree.or = []
        for (let amount = 0; amount <= 5; amount++) {
            tree.push(['not equal', variable, value])
            result = decision.decide(tree)
            unitTest.assertFalse(result.decision, result.reason)
            tree.push(['not equal', variable, value + 1])
            result = decision.decide(tree)
            unitTest.assertTrue(result.decision, result.reason)
            tree.pop()
        }
    }
}

try {
    // Simply test all supported operators
    testCompareOperators()
    testUnaryLogicalOperators()
    testAnd()
    testOr()
    let result = decision.decide(
        ['and', ['below', 'a/b', 18], ['below', 'b/c', 23]]
    )
    unitTest.assertTrue(result.decision, result.reason)
    // correct decision with variable lookup table
    result = decision.decide(
        [
            'and',
            ['below', 'a/b', 16],
            ['above', 'b/c',
                {
                    variable: 'system/presence',
                    map: {
                        absent: 2,
                        awake: 1,
                        sleeping: 3
                    }
                }
            ]
        ]

    )
    unitTest.assertTrue(result.decision, result.reason)
    // wrong decision with variable lookup table
    result = decision.decide(
        [
            'and',
            ['below', 'a/b', 16],
            [
                'above',
                'b/c',
                {
                    variable: 'system/presence',
                    map: {
                        absent: 1,
                        awake: 2,
                        sleeping: 3
                    }
                }
            ]
        ]

    )
    unitTest.assertFalse(result.decision, result.reason)
    // Recursive
    result = decision.decide({
        and: [{
            or: [['below', 'a/b', 10], ['below', 'b/c', 2]]
        },
        {
            or: [['above or equal', 'a/b', 10], ['above or equal', 'b/c', 2]]
        }]
    })
    unitTest.assertTrue(result.decision, result.reason)

    // Exceptions
    unitTest.expectException(() => decision.decide([undefined, 'a/b', 10]), 'Error')
    result = decision.decide(['above', 'a/b/c', 10])
    unitTest.assertEqual(result.reason, 'a/b/c (undefined)', result.reason)
    unitTest.expectException(() => decision.decide(['above', 'a/b']), 'Error')
    result = decision.decide(['above', 'a/b', 'a'])
    unitTest.assertEqual(result.variables.a, undefined, result.reason)
    unitTest.expectException(() => decision.decide({ and: true, or: true }), 'Error')
    unitTest.expectException(() => decision.decide({ function: 'test', param: [true] }), 'Error')
    unitTest.expectException(() => decision.decide({ function: 'test', parameter: true }), 'Error')

    // Callbacks
    result = decision.decide({ function: 'test', parameter: [true] })
    unitTest.assertTrue(result.decision, result.reason)
} catch (err) {
    unitTest.fail(err.message)
    console.log(err)
}

unitTest.showResult(176)
