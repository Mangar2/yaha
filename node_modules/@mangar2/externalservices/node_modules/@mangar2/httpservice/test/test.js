/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const HttpClient = require('@mangar2/httpservice').HttpClient
const HttpServer = require('@mangar2/httpservice').HttpServer
const HttpsClient = require('@mangar2/httpservice').HttpsClient
const HttpsServer = require('@mangar2/httpservice').HttpsServer
const UnitTest = require('@mangar2/unittest')
const shutdown = require('@mangar2/shutdown')
const fs = require('fs')

const httpClient = new HttpClient('127.0.0.1', 9101)
const httpServer = new HttpServer(9101)

const httpsClient = new HttpsClient('127.0.0.1', 9102)
const httpsServer = new HttpsServer(9102)

const unitTest = new UnitTest(false)

process.env.NODE_TLS_REJECT_UNAUTHORIZED = 0
const methods = ['put', 'get', 'post', 'delete', 'patch']

async function testTimeout () {
    const httpTimeoutClient = new HttpClient('192.168.0.4', 9200)
    await httpTimeoutClient.send('get', 'GET', 'test', {})
}

/**
 * Registers a response function to be called, when the server receives data
 * @param {HttpServer} server server calling the method
 * @param {string} method http method (put, get, ...)
 */
const setResponseFunction = (server, method) => {
    const responseFunction = (payload, headers, path, res) => {
        res.writeHead(200, { 'Content-Type': 'application/json' })
        if (method === 'get') {
            payload = payload.toString()
        }
        const result = JSON.stringify({ method, payload, headers, path })
        res.end(result)
    }
    server.on(method, responseFunction)
}

/**
 * Sets listen functions to all http methods (get, put, ...)
 * @param {HttpServer} server server to listen for data
 * @param {Object} options http(s) options
 */
async function listen (server, options) {
    for (const method of methods) {
        setResponseFunction(server, method)
    }
    await server.listen(options)
}

const httpsOptions = {
    key: fs.readFileSync('key.pem'),
    cert: fs.readFileSync('cert.pem')
}

/**
 * Verifies the data returned
 * @param {Object} result returned data
 */
function verify (result, method) {
    const resultObject = JSON.parse(result.payload)
    const test1 = unitTest.assertEqual(result.statusCode, 200, method + ' statusCode')
    const test2 = unitTest.assertEqual(resultObject.method, method, method + ' payload')
    const test3 = method === 'get'
        ? unitTest.assertEqual(resultObject.payload, 'a=hello&b=world', method + ' payload')
        : unitTest.assertEqual(resultObject.payload, 'test data', method + ' payload')
    const test4 = unitTest.assertEqual(result.headers['content-type'], 'application/json', method + ' payload')
    const test5 = unitTest.assertEqual(resultObject.path, '/clients', method + ' payload')

    if (!test1 || !test2 || !test3 || !test4 || !test5) {
        console.log(JSON.stringify(result, null, 2))
    }
}

/**
 * Sets a http and a https server to listen
 */
async function prepare () {
    await listen(httpServer)
    console.log('you need to provide a key.pem and a cert.pem file for the test')
    await listen(httpsServer, httpsOptions)
}

// ich moechte gerne https benutzen
// Success, if http httpServer is started too
(async () => {
    await prepare()
    const header = { 'Content-Type': 'application/json', packetid: 1, packet: 'publish' }
    for (const method of methods) {
        let result = await httpClient.send('/clients?a=hello&b=world', method, 'test data', header).catch(err => {
            unitTest.fail(err)
        })
        verify(result, method)

        result = await httpsClient.send('/clients?a=hello&b=world', method, 'test data', header).catch(err => {
            unitTest.fail(err)
        })
        verify(result, method)
    }
    try {
        console.log('test timeout, please wait...')
        await testTimeout()
    } catch (error) {
        console.log(error)
        unitTest.success('timeout')
    }

    unitTest.showResult(51)
    process.exit(0)
})()

shutdown(async () => {
    await httpClient.close()
    await httpServer.close()
    await httpsClient.close()
    await httpsServer.close()
    process.exit(0)
})
