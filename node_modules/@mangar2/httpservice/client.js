/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

/**
 * @private
 * @description
 * Class simplifying access to the node http service for http clients
 * @param {string} host host name or ip address
 * @param {string|number} port port number
 * @example
 * const client = new HttpClient('myhost', 10000);
 * client.send('info/getdata/1', 'GET', {}, {'Content-Type': 'text/plain'})
 */
class Client {
    constructor (host, port) {
        this.setConnection(host, port)
        this.requests = {}
        this.nextRequestId = 0
    }

    /**
     * Sets host name and port number
     * @param {string} host host name
     * @param {string} port port number
     */
    setConnection (host, port) {
        if (host === undefined) {
            throw Error('No host specified')
        }
        if (port === undefined) {
            throw Error('No port specified')
        }

        this.host = host
        this.port = port
    }

    /**
     * Calculate the length of a string in bytes, handling utf8-characters
     * @private
     * @param {string} s string to calculate its length for
     * @returns {number} 
     */
    _calculateStringLengthInBytes(s) {
        return (new TextEncoder().encode(s)).length
    }

    /**
     * Sends data. Adds a content-type element to the header and stringifies the boy based on the type
     * @param {object} sendOptions all information required for sending
     * @param {string} sendOptions.path http path
     * @param {string} sendOptions.method http send method PUT, GET, ...
     * @param {object} [sendOptions.payload] payload to send
     * @param {object} [sendOptions.headers={}] header to send
     * @param {http|https} service http(s) service to use for sending data
     * @param {string} [type] type of the payload data: html, text, json, form, xml
     *      * @param {http|https} service http(s) service to use for sending data
     * @returns {Promise<{statusCode, headers, payload}>} Promise; resolve = {statusCode, headers, payload}
     */
    sendv2 (sendOptions, service) {
        let { path, method, payload, headers,  type } = sendOptions
        if (!headers) {
            headers = {}
        }
        if (payload && type) {
            switch (type.toLowerCase()) {
            case 'html': headers['Content-Type'] = 'text/html'; break
            case 'text': headers['Content-Type'] = 'text/plain'; break
            case 'xml': headers['Content-Type'] = 'application/xml'; break
            case 'form': 
                payload = (new URLSearchParams(payload)).toString()
                headers['Content-Type'] = 'application/x-www-form-urlencoded'
                break
            case 'json': 
                payload = JSON.stringify(payload)
                headers['Content-Type'] = 'application/json'
                break
            }
        }
        return this.send(path, method, payload, headers, service)
    }

    /**
     * Sends data. A payload of type "object" is automatically stringified, a string is not
     * @param {string} path http path
     * @param {string} method http send method PUT, GET, ...
     * @param {string|object} payload payload to send
     * @param {object} headers header to send
     * @param {http|https} service http(s) service to use for sending data
     * @returns {object} Promise; resolve = {statusCode, headers, payload}
     */
    send (path, method, payload, headers, service) {
        const stringPayload = typeof (payload) === 'string' ? payload : JSON.stringify(payload)
        headers['content-length'] = this._calculateStringLengthInBytes(stringPayload)

        const options = {
            host: this.host,
            port: this.port,
            path,
            method,
            headers
        }
        const result = new Promise((resolve, reject) => {
            const requestId = this.nextRequestId
            this.nextRequestId++
            const request = service.request(options, res => {
                let resultPayload = ''
                res.setEncoding('utf8')
                res.on('data', chunk => { resultPayload += chunk })

                res.on('end', () => {
                    resolve({
                        statusCode: res.statusCode,
                        headers: res.headers,
                        payload: resultPayload
                    })
                    delete this.requests[requestId]
                })
            })
            this.requests[requestId] = request
            request.write(stringPayload)
            request.end()
            request.on('error', err => {
                if (this.requests[requestId] !== undefined) {
                    delete this.requests[requestId]
                }
                reject(err)
            })
        })

        return result
    }

    /**
     * Aborts all open requests
     * @returns promise, resolved once all connections are closed
     */
    close () {
        const result = new Promise((resolve) => {
            for (const requestId in this.requests) {
                this.requests[requestId].abort()
            }
            resolve()
        })
        return result
    }
}

module.exports = Client
