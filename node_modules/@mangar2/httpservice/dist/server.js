"use strict";
/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const http = __importStar(require("http"));
const https = __importStar(require("https"));
const utils_1 = require("@mangar2/utils");
/**
 * @private
 * @description
 * Creates a http/https server listening to a certain port for
 * simplifying access to the node http(s) service
 * Register your callbacks according to the http(s) functions you need.
 * @param {number} port port to listen to
 */
class Server {
    constructor(port) {
        this.port = port;
        this.sockets = {};
        this.nextSocketId = 0;
        this.server = undefined;
        this.callbacks = new utils_1.Callbacks(['get', 'put', 'post', 'patch', 'delete', 'options', 'listen', 'closed']);
        this.on('listen', () => {
            var _a;
            const address = (_a = this.server) === null || _a === void 0 ? void 0 : _a.address();
            const port = typeof address === 'string' ? null : address === null || address === void 0 ? void 0 : address.port;
            console.log('Server listening on: http://localhost:%s', port);
        });
        this.on('closed', () => {
            console.log('Server closed');
        });
    }
    /**
     * Sets a callback
     * @param {string} event RESTful http verb (POST, GET, PUT, PATCH, DELETE) and 'listen' (called once listening) and 'closed' (called once closed)
     * @param {HttpGetCallback|HttpCallback} callback(payload, headers, path, res)
     * where payload is the http payload, headers the http headers, res the result structure and path is
     * is the http path as string
     */
    on(event, callback) {
        this.callbacks.on(event.toLowerCase(), callback);
    }
    /**
     * @private
     * @description
     * Handles an error situation
     * @param {string|Error} err error message
     * @param {res} object http result structure
     */
    onError(err, res) {
        res.writeHead(400, { 'Content-Type': 'text/plain' });
        res.end(typeof err === 'object' ? err.message : err);
        console.error(err);
    }
    /**
     * dispatches a http request
     * @param {string} method name of the method
     * @param {Object} req request information
     * @param {Object} res http result structure
     * @param {Array} url parsed URI
     * @param {Object} body body data
     */
    dispatch(method, payload, req, res) {
        if (!this.callbacks.hasCallback(method)) {
            res.writeHead(404, { 'Content-Type': 'text/plain' });
            res.end(`unknown method ${method}`);
            return;
        }
        const url = new URL(req.url, `http://${req.headers.host}`);
        const path = url.pathname;
        if (method === 'get') {
            this.callbacks.invokeCallback(method, url.searchParams, req.headers, path, res);
        }
        else {
            this.callbacks.invokeCallback(method, payload, req.headers, path, res);
        }
    }
    /**
     * Handles incoming Http requests and dispatches them.
     * @param {http.IncomingMessage} request The incoming Http request.
     * @param {http.ServerResponse} response The server response object.
     */
    requestHandler(req, res) {
        var _a;
        try {
            const method = ((_a = req.method) === null || _a === void 0 ? void 0 : _a.toLowerCase()) || '';
            let payload = '';
            req.on('data', (chunk) => {
                payload += chunk.toString();
            });
            req.on('end', () => {
                try {
                    this.dispatch(method, payload, req, res);
                }
                catch (err) {
                    this.onError(err, res);
                }
            });
        }
        catch (err) {
            this.onError(err, res);
        }
    }
    /**
     * Creates a http server listening
     * @param {boolean} [useHttpS] true, if we use https
     * @param {Object} options additional options
     */
    listen(useHttpS = false, options) {
        if (!useHttpS) {
            this.server = http.createServer((req, res) => this.requestHandler(req, res)).listen(this.port, () => {
                this.callbacks.invokeCallback('listen');
            });
        }
        else {
            this.server = https.createServer(options, (req, res) => this.requestHandler(req, res)).listen(this.port, () => {
                this.callbacks.invokeCallback('listen');
            });
        }
        this.server.on('connection', (socket) => {
            const socketId = this.nextSocketId++;
            this.sockets[socketId] = socket;
            socket.on('close', () => {
                delete this.sockets[socketId];
            });
        });
    }
    /**
     * Stops the server from accepting new connections and closes existing connections.
     * Calls the callback "close", once the server is closed.
     * @returns {promise} resolved, once the connection is closed
     */
    close() {
        return new Promise((resolve) => {
            if (this.server) {
                this.server.close(() => {
                    this.callbacks.invokeCallback('closed');
                    resolve();
                });
                Object.values(this.sockets).forEach(socket => socket.destroy());
            }
        });
    }
}
exports.default = Server;
//# sourceMappingURL=server.js.map