/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @description
 * Class simplifying access to the node https service for https server
 * constuct the server with new Server(port number).
 * register your callbacks according to the http functions you need.
 * @example
 * const server = new HTTPSServer(10000)
 * server.on('GET', (payload, headers, path, res) => console.log(path))
 * server.listen()
 * server.close()
 */

'use strict'

const https = require('https')
const Callbacks = require('@mangar2/callbacks')
const URL = require('url')
const errorLog = require('@mangar2/errorlog')

/**
 * @private
 * Extracts the path from the https request structure and returns it as array
 * @param {object} req https reqest structure
 * @returns {array} path elements without host name
 */
function getPath (req) {
    // const url2 = new URL.URL(req.url)
    const url = URL.parse(req.url)
    const path = decodeURI(url.path)
    return path
}

module.exports = class HTTPSServer {
    /**
     * creates a https server listening to a certain port
     * @param {number} port port to listen to
     * @param {string} key public key (from pem file)
     * @param {string} cert private key (from pem file)
     */
    constructor (port, key, cert) {
        this.port = port
        this.sockets = {}
        this.nextSocketId = 0
        this.server = undefined
        this.callbacks = new Callbacks(['get', 'put', 'post', 'patch', 'delete', 'listen', 'closed'])
        this.options = { key, cert }

        this.on('listen', () => {
            console.log('Intranet server listening on: https://localhost:%s', this.port)
        })
        this.on('closed', () => {
            console.log('Server closed')
        })
    }

    /**
     * Sets a callback
     * @param {string} event RESTful http verb (POST, GET, PUT, PATCH, DELETE) and 'listen' (called once listening) and 'closed' (called once closed)
     * @param {function} callback(payload, headers, path, res)
     * where payload is the http payload, headers the http headers, res the result structure and path is
     * is the http path as string
     */
    on (event, callback) {
        this.callbacks.on(event, callback)
    }

    /**
     * @private
     * Handles an error situation
     * @param {string|Error} err error message
     * @param {res} object http result structure
     */
    onError (err, res) {
        res.writeHead(400, { 'Content-Type': 'text/plain' })
        res.end(typeof (err) === 'object' ? err.message : err)
        errorLog(err)
    }

    /**
     * Creates a http server listening
     * * @param {object} options https options
     */
    listen (options) {
        this.server = https.createServer(options, (req, res) => {
            try {
                const method = req.method.toLowerCase()
                const path = getPath(req)
                let payload = ''

                req.on('data', (chunk) => {
                    payload += chunk
                })
                req.on('end', () => {
                    try {
                        this.callbacks.invokeCallback(method, payload, req.headers, path, res)
                    } catch (err) {
                        this.onError(err, res)
                    }
                })
            } catch (err) {
                this.onError(err, res)
            }
        }).listen(this.port, () => {
            this.callbacks.invokeCallback('listen')
        })

        this.server.on('connection', (socket) => {
            const socketId = this.nextSocketId
            this.nextSocketId++
            this.sockets[socketId] = socket

            socket.on('close', () => {
                delete this.sockets[socketId]
            })
        })
    }

    /**
     * Stops the server from accepting new connections and closes existing connections.
     * Calls the callback "close", once the server is closed.
     * @returns {promise} resolved, once the connection is closed
     */
    close () {
        const result = new Promise((resolve, reject) => {
            if (this.server !== undefined) {
                this.server.close(() => {
                    this.callbacks.invokeCallback('closed')
                    resolve()
                })

                // destroy all open connections. The server only closes, if all socket connections are destroyed
                for (const socketId in this.sockets) {
                    this.sockets[socketId].destroy()
                }
            }
        })
        return result
    }
}
