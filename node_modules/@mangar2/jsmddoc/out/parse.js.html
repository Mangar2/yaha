<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: parse.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: parse.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview This module provides a parser and a generator to parse JSDOC tags in
 * JavaScript files and generates a markdown based on a user-defined template
 */
'use strict'

const parseJS = require('./parsejs')

/**
 * @description
 * Creates a java script document parser extracting documentation from a JavaScript file
 * @param {Tokenizer} tokenizer tokenizer class to read file and provide its content in tokens
 */
class Parse {
    constructor (tokenizer) {
        this._tokenizer = tokenizer
        this._indent = 0
        this._tagMap = {
            fileoverview: 'overview',
            file: 'overview',
            return: 'returns'
        }
    }

    /**
     * @private
     * @description
     * Checks, if a token is a tag beginning with @
     * @param {string} tk token to check
     * @returns {boolean} true, if the token is a "doc-tag"
     */
    _isDocTag (tk) {
        return tk.charAt(0) === '@' &amp;&amp; tk.length > 1
    }

    /**
     * @private
     * @description
     * Checks, if a token is a documentation begin tag
     * @param {string} tk token to check
     * @returns {boolean}
     */
    _isDocBeginTag (tk) {
        return tk === '/**'
    }

    /**
     * @private
     * @description
     * Checks, if a token is a documentation end tag
     * @param {string} tk token to check
     * @returns {boolean}
     */
    _isDocEndTag (tk) {
        return tk === '*/' || tk === ''
    }

    /**
     * @private
     * @description
     * Checks, it the tag is a text end tag
     * @param {string} tk current token
     * @returns {boolean} true, if the current token ends the text part of a description component
     */
    _isTextEndTag (tk) {
        return this._isDocTag(tk) || this._isDocEndTag(tk)
    }

    /**
     * @private
     * @description
     * Skips the line break of a documentation line block including the \n and the starting '*'
     */
    _scipDocLineBreak () {
        let tk = this._tokenizer.curToken()
        while (tk === '\n') {
            tk = this._tokenizer.nextToken()
            if (tk === '*') {
                tk = this._tokenizer.nextToken()
            }
        }
    }

    /**
     * @private
     * @description
     * Gets the text of a jsdoc comment
     * @returns {string} the documentation text
     */
    _getText () {
        let result = ''
        this._scipDocLineBreak()
        while (!this._isTextEndTag(this._tokenizer.curToken())) {
            if (result !== '') {
                result += ' '
            }
            result += this._tokenizer.curToken()
            this._tokenizer.nextToken()
            this._scipDocLineBreak()
        }
        return result
    }

    /**
     * @private
     * @description
     * Parses the description part of a comment
     * @param {string} [curDescription] current description entry
     */
    _parseDescription (curDescription) {
        if (curDescription !== undefined) {
            this._tokenizer.printMessage('Warning', 'Duplicate description entry')
        }
        const description = this._getText()
        return description
    }

    /**
     * @private
     * @description
     * Extracts the type from a parameter description
     * @param {string} paramLine text after a param tag
     * @returns {Object} with properties types and paramLine
     */
    _extractType (paramLine) {
        const result = { paramLine }
        if (paramLine.charAt(0) === '{') {
            const paramChunks = paramLine.substr(1).split('}')
            const paramType = paramChunks.shift()
            result.description = paramChunks.join('}').trim()
            result.types = paramType.split('|')
            result.types.map(param => param.trim())
            result.types = result.types.join(', ')
        }
        return result
    }

    /**
     * @private
     * @description
     * Parses a 'param' tag
     * @param {Object[]} curParam parameters found so far
     */
    _parseParam (curParam) {
        if (curParam === undefined) {
            curParam = []
        }
        const newParamLine = this._getText()
        const newParam = {}
        const typeExtracted = this._extractType(newParamLine)
        newParam.types = typeExtracted.types
        const nameExtracted = typeExtracted.description.split(' ')
        newParam.name = nameExtracted.shift()
        newParam.description = nameExtracted.join(' ')

        curParam.push(newParam)
        return curParam
    }

    /**
     * @private
     * @description
     * Parses a 'returns' tag
     */
    _parseReturns () {
        const returnLine = this._getText()
        const typeExtracted = this._extractType(returnLine)
        return typeExtracted
    }

    /**
     * @private
     * @description
     * Gets/maps the tag
     * @param {string} token current tag token
     */
    _getTag (token) {
        let tag = token.substr(1)
        const mapped = this._tagMap[tag]
        if (mapped !== undefined) {
            tag = mapped
        }
        return tag
    }

    /**
     * @private
     * @description
     * Parses the comment section
     * @returns {Object} object with properties of each comment section
     */
    _parseComment () {
        const result = {}
        const description = this._parseDescription()
        if (description !== '') {
            result.description = description
        }
        this._scipDocLineBreak()
        while (!this._isDocEndTag(this._tokenizer.curToken())) {
            const tk = this._tokenizer.curToken()
            if (this._isDocTag(tk)) {
                this._tokenizer.nextToken()
                switch (tk) {
                case '@param': result.param = this._parseParam(result.param); break
                case '@return':
                case '@returns': result.returns = [this._parseReturns()]; break
                case '@descripton': result.description = this._parseDescription(result.description); break
                default:
                    result[this._getTag(tk)] = this._getText()
                    break
                }
            }
            this._scipDocLineBreak()
        }
        this._tokenizer.nextToken()
        return result
    }

    /**
     * @description
     * Creates a JSON structure of the file comments
     * @returns {Object} file comments
     */
    getJSON () {
        let global = { class: [], function: [] }
        let curClass = null
        while (this._tokenizer.nextToken() !== '') {
            if (this._isDocBeginTag(this._tokenizer.curToken())) {
                this._tokenizer.nextToken()
                const comment = this._parseComment()
                const jsInfo = parseJS(this._tokenizer, curClass !== null)
                const fullInfo = { ...comment, ...jsInfo }
                if (fullInfo.class) {
                    fullInfo.details = []
                    global.class.push(fullInfo)
                    curClass = fullInfo
                } else if (curClass === null) {
                    global = { ...global, ...fullInfo }
                } else {
                    curClass.details.push(fullInfo)
                }
            }
        }
        return global
    }
}

module.exports = Parse
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Generate.html">Generate</a></li><li><a href="Parse.html">Parse</a></li><li><a href="Tokenizer.html">Tokenizer</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Wed Mar 25 2020 17:51:52 GMT+0100 (GMT+01:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
