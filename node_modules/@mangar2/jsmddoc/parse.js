/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */
'use strict'

const types = require('@mangar2/types')
const { parseJS, addString } = require('./parsejs')
const { parseThrows, parseReturns, parseParamLine } = require('./parseparam')
const { parseType } = require('./parseType')
const { getTextWithNewline, getText, nextDocToken, isDocBeginTag, isDocTag, isDocEndTag, isTextEndTag } = require('./tags')
const { reportError } = require('./reporterror')

const tagsWithoutValue = ['private']

/**
 * @description
 * Creates a java script document parser extracting documentation from a JavaScript file
 * @param {Tokenizer} tokenizer tokenizer class to read file and provide its content in tokens
 */
class Parse {
    constructor (tokenizer) {
        this._tokenizer = tokenizer
        this._indent = 0
        this._tagMap = {
            fileoverview: 'overview',
            file: 'overview',
            return: 'returns',
            exception: 'throws',
            arg: 'param',
            argument: 'param'
        }
    }

    /**
     * @private
     * @description
     * Parses an example section
     * @returns {string} example section
     */
    _parseExample () {
        const example = getTextWithNewline(this._tokenizer)
        return example
    }

    /**
     * @private
     * @description
     * Parses the description part of a comment
     * @param {string} [curDescription] current description entry
     */
    _parseDescription (curDescription) {
        if (curDescription !== undefined) {
            reportError(this._tokenizer, 'Duplicate description entry')
        }
        const description = getText(this._tokenizer)
        return description
    }

    /**
     * @private
     * @description
     * Parses a 'param' tag
     * @param {Object[]} curParam parameters found so far
     * @returns {Object[]} curParam combined with current parameter
     */
    _parseParam (curParam) {
        if (curParam === undefined) {
            curParam = []
        }
        curParam = parseParamLine(this._tokenizer, curParam)
        return curParam
    }

    /**
     * @private
     * @description
     * Parses a 'throws' tag
     * @param {Object[]} cur throw commands found so far
     * @returns {Object[]} combined list of throw commands
     */
    _parseThrows (cur) {
        if (cur === undefined) {
            cur = []
        }
        const newThrows = parseThrows(this._tokenizer)
        cur.push(newThrows)
        return cur
    }

    /**
     * @private
     * @description
     * Parses all "simple" tags
     * @param {string} tag current tag
     * @returns {string} tag content
     */
    _parseTag (tag) {
        let text = getText(this._tokenizer)
        if (text !== '' && tagsWithoutValue.includes(tag)) {
            reportError(this._tokenizer, 'The @' + tag + ' tag does not permit a value; the value will be ignored')
            text = ''
        }
        return text
    }

    /**
     * @private
     * @description
     * Gets/maps the tag
     * @param {string} token current tag token
     */
    _getTag (token) {
        let tag = token.substr(1)
        const mapped = this._tagMap[tag]
        if (mapped !== undefined) {
            tag = mapped
        }
        return tag
    }

    /**
     * @private
     * @description
     * Extracts the type from a parameter description
     * @param {Tokenizer} tokenizer provides token
     * @param {Object} [curInfo={}] attributes found so far
     * @returns {Object} with property types
     */
    _parseTypeTag (tokenizer, curInfo = {}) {
        const result = parseType(tokenizer, curInfo)
        if (!isTextEndTag(tokenizer.token)) {
            reportError(tokenizer, 'The @type tag does not permit a description; the description will be ignored.')
        }
        return result
    }

    /**
     * @private
     * @description
     * Parses the comment section
     * @returns {Object} object with properties of each comment section
     */
    _parseComment () {
        let result = {}
        const description = this._parseDescription()
        if (description !== '') {
            result.description = description
        }
        while (!isDocEndTag(this._tokenizer.token)) {
            const tk = this._tokenizer.token
            if (isDocTag(tk)) {
                nextDocToken(this._tokenizer)
                const tag = this._getTag(tk)
                switch (tag) {
                case 'param': result.param = this._parseParam(result.param); break
                case 'returns': result.returns = [parseReturns(this._tokenizer)]; break
                case 'throws': result.throws = this._parseThrows(result.throws); break
                case 'descripton': result.description = this._parseDescription(result.description); break
                case 'type': result = this._parseTypeTag(this._tokenizer, result); break
                case 'example': result.example = this._parseExample(); break
                case 'readonly': result.attributes = addString(result.attributes, 'readonly'); break
                default: result[tag] = this._parseTag(tag, this._tokenizer); break
                }
            } else {
                nextDocToken(this._tokenizer)
            }
        }
        nextDocToken(this._tokenizer)
        return result
    }

    /**
     * @private
     * @description
     * Adds an element to the parent object and returns the new parent
     * @param {Object} element object to add
     * @param {Object} parent parent object
     * @param {string[]} types array of properties to look for
     * @returns {Object} modified parent
     */
    _addToParent (element, parent, types) {
        for (const type of types) {
            if (element[type] !== undefined) {
                if (parent[type] === undefined) {
                    parent[type] = []
                }
                parent[type].push(element)
                parent[type].sort((child1, child2) => {
                    if (child1[type] < child2[type]) return -1
                    if (child1[type] > child2[type]) return 1
                    return 0
                })
            }
        }
        return parent
    }

    /**
     * Unifies the string properties of a list of objects by adding
     * empty string properties to any object missing any property that any other
     * object has
     * @param {Object[]} objectList list of objects
     */
    _unifyProperties (objectList) {
        const existingProperties = {}
        if (objectList !== undefined) {
            for (const parameter of objectList) {
                for (const property in parameter) {
                    if (types.isString(parameter[property])) {
                        existingProperties[property] = true
                    }
                }
            }
            for (const parameter of objectList) {
                for (const property in existingProperties) {
                    if (parameter[property] === undefined) {
                        parameter[property] = ''
                    }
                }
            }
        }
    }

    /**
     * Unifies the string properties of a list of objects by adding
     * empty string properties to any object missing any property that any other
     * object has
     * @param {Object[]} classList list of class definitions
     */
    _unifyClassProperties (classList) {
        if (classList !== undefined) {
            for (const classDef of classList) {
                this._unifyProperties(classDef.member)
            }
        }
    }

    /**
     * Joins the properties of object2 to object1, if both have a string property
     * with the same name, the strings are concatenated
     * @param {Object} object1 first object to join
     * @param {Object} object2 second object to join
     * @returns {Object} object1 with added properties
     */
    _joinObjects (object1, object2) {
        for (const property in object2) {
            const value = object2[property]
            if (types.isString(object1[property]) && types.isString(value)) {
                object1[property] += ' ' + value
            } else {
                object1[property] = value
            }
        }
        return object1
    }

    /**
     * @description
     * Creates a JSON structure of the file comments
     * @param {Object} parseResult result of the former files
     * @returns {Object} file comments
     */
    getJSON (parseResult) {
        if (parseResult === undefined) {
            parseResult = { file: [] }
        }

        let parent = null
        while (this._tokenizer.nextToken() !== '') {
            if (isDocBeginTag(this._tokenizer.token)) {
                nextDocToken(this._tokenizer)
                const comment = this._parseComment()
                const jsInfo = parseJS(this._tokenizer, parent !== null)
                const fullInfo = this._joinObjects(comment, jsInfo)
                if (fullInfo.class) {
                    parseResult = this._addToParent(fullInfo, parseResult, ['class'])
                    parent = fullInfo
                } else if (fullInfo.function) {
                    parseResult = this._addToParent(fullInfo, parseResult, ['function'])
                } else if (parent === null) {
                    fullInfo.filename = this._tokenizer.filename
                    parseResult.file.push(fullInfo)
                } else {
                    parent = this._addToParent(fullInfo, parent, ['method', 'member'])
                }
            }
        }
        this._unifyClassProperties(parseResult.class)
        return parseResult
    }
}

module.exports = Parse
