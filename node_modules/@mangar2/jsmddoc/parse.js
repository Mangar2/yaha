/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview This module provides a parser and a generator to parse JSDOC tags in
 * JavaScript files and generates a markdown based on a user-defined template
 */
'use strict'

const parseJS = require('./parsejs')
const { parseThrows, parseReturns, parseParamLine } = require('./parseparam')
const { parseType } = require('./parseType')
const { getTextWithNewline, getText, nextDocToken, isDocBeginTag, isDocTag, isDocEndTag } = require('./tags')
const { reportError } = require('./reporterror')

const tagsWithoutValue = ['private']

/**
 * @description
 * Creates a java script document parser extracting documentation from a JavaScript file
 * @param {Tokenizer} tokenizer tokenizer class to read file and provide its content in tokens
 */
class Parse {
    constructor (tokenizer) {
        this._tokenizer = tokenizer
        this._indent = 0
        this._tagMap = {
            fileoverview: 'overview',
            file: 'overview',
            return: 'returns',
            exception: 'throws',
            arg: 'param',
            argument: 'param'
        }
    }

    /**
     * @private
     * @description
     * Parses an example section
     * @returns {string} example section
     */
    _parseExample () {
        const example = getTextWithNewline(this._tokenizer)
        return example
    }

    /**
     * @private
     * @description
     * Parses the description part of a comment
     * @param {string} [curDescription] current description entry
     */
    _parseDescription (curDescription) {
        if (curDescription !== undefined) {
            reportError(this._tokenizer, 'Duplicate description entry')
        }
        const description = getText(this._tokenizer)
        return description
    }

    /**
     * @private
     * @description
     * Parses a 'param' tag
     * @param {Object[]} curParam parameters found so far
     * @returns {Object[]} curParam combined with current parameter
     */
    _parseParam (curParam) {
        if (curParam === undefined) {
            curParam = []
        }
        curParam = parseParamLine(this._tokenizer, curParam)
        return curParam
    }

    /**
     * @private
     * @description
     * Parses a 'throws' tag
     * @param {Object[]} cur throw commands found so far
     * @returns {Object[]} combined list of throw commands
     */
    _parseThrows (cur) {
        if (cur === undefined) {
            cur = []
        }
        const newThrows = parseThrows(this._tokenizer)
        cur.push(newThrows)
        return cur
    }

    /**
     * @private
     * @description
     * Parses all "simple" tags
     * @param {string} tag current tag
     * @returns {string} tag content
     */
    _parseTag (tag) {
        let text = getText(this._tokenizer)
        if (text !== '' && tagsWithoutValue.includes(tag)) {
            reportError(this._tokenizer, 'The @' + tag + ' tag does not permit a value; the value will be ignored')
            text = ''
        }
        return text
    }

    /**
     * @private
     * @description
     * Gets/maps the tag
     * @param {string} token current tag token
     */
    _getTag (token) {
        let tag = token.substr(1)
        const mapped = this._tagMap[tag]
        if (mapped !== undefined) {
            tag = mapped
        }
        return tag
    }

    /**
     * @private
     * @description
     * Parses the comment section
     * @returns {Object} object with properties of each comment section
     */
    _parseComment () {
        let result = {}
        const description = this._parseDescription()
        if (description !== '') {
            result.description = description
        }
        while (!isDocEndTag(this._tokenizer.token)) {
            const tk = this._tokenizer.token
            if (isDocTag(tk)) {
                nextDocToken(this._tokenizer)
                const tag = this._getTag(tk)
                switch (tag) {
                case 'param': result.param = this._parseParam(result.param); break
                case 'returns': result.returns = [parseReturns(this._tokenizer)]; break
                case 'throws': result.throws = this._parseThrows(result.throws); break
                case 'descripton': result.description = this._parseDescription(result.description); break
                case 'type': result = parseType(this._tokenizer, result); break
                case 'example': result.example = this._parseExample(); break
                default: result[tag] = this._parseTag(tag, this._tokenizer); break
                }
            } else {
                nextDocToken(this._tokenizer)
            }
        }
        nextDocToken(this._tokenizer)
        return result
    }

    /**
     * @description
     * Creates a JSON structure of the file comments
     * @param {Object} parseResult result of the former files
     * @returns {Object} file comments
     */
    getJSON (parseResult) {
        if (parseResult === undefined) {
            parseResult = { file: [], class: [], function: [] }
        }
        parseResult.file.push(this._tokenizer.filename)

        let parent = null
        while (this._tokenizer.nextToken() !== '') {
            if (isDocBeginTag(this._tokenizer.token)) {
                nextDocToken(this._tokenizer)
                const comment = this._parseComment()
                const jsInfo = parseJS(this._tokenizer, parent !== null)
                const fullInfo = { ...comment, ...jsInfo }
                if (fullInfo.class) {
                    fullInfo.details = []
                    parseResult.class.push(fullInfo)
                    parent = fullInfo
                } else if (fullInfo.function) {
                    fullInfo.details = []
                    parseResult.function.push(fullInfo)
                    parent = fullInfo
                } else if (parent === null) {
                    parseResult = { ...parseResult, ...fullInfo }
                } else {
                    parent.details.push(fullInfo)
                }
            }
        }
        return parseResult
    }
}

module.exports = Parse
