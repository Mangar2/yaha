/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */
'use strict'

/**
 * @private
 * @description
 * Parses a class tag
 * @param {Tokenizer} tokenizier class providing tokens
 */
function _parseClass (tokenizer) {
    const className = tokenizer.nextToken()
    return { class: className }
}

/**
 * @private
 * @description Adds one string to another
 * @param {string|undefined} curText current string
 * @param {string} addText string to add
 */
function addString (curText, addText) {
    let result = curText
    if (curText === undefined) {
        result = addText
    } else if (!curText.includes(addText)) {
        result = curText + ' ' + addText
    }
    return result
}

/**
 * @private
 * @description
 * Parses and skips all kind of prefixes
 * @param {Tokenizer} tokenizier class providing tokens
 */
function _parsePrefixes (tokenizer) {
    const result = {}
    const prefixes = ['static', 'async', 'const', 'var', 'let', '=', 'module', 'exports', '.', '\n']
    while (prefixes.includes(tokenizer.token)) {
        switch (tokenizer.token) {
        case 'async': result.attributes = addString(result.attributes, 'async'); break
        case 'static': result.attributes = addString(result.attributes, 'static'); break
        case 'const': result.attributes = addString(result.attributes, 'readonly'); break
        }
        tokenizer.nextToken()
    }
    return result
}

/**
 * @private
 * @description
 * Parses a method tag
 * @param {Tokenizer} tokenizier class providing tokens
 * @param {string} attribute attribute to use for storing the name
 * @returns {object} information about the function/method
 */
function _parseFunction (tokenizer, attribute) {
    const result = { }
    const prefixes = ['function', 'get', 'set']
    while (prefixes.includes(tokenizer.token)) {
        tokenizer.nextToken()
    }
    const name = tokenizer.token
    tokenizer.nextToken()
    while (['='].includes(tokenizer.token)) {
        tokenizer.nextToken()
    }
    if (tokenizer.token === '(' && name !== '') {
        result[attribute] = name
    }
    return result
}

/**
 * @private
 * @description
 * Parses a member tag
 * @param {Tokenizer} tokenizier class providing tokens
 */
function _parseMember (tokenizer) {
    tokenizer.nextToken()
    return _parseFunction(tokenizer, 'member')
}

/**
 * @private
 * @description
 * Parses the JavaScript elements of a file to document
 * @param {Tokenizer} tokenizier class providing tokens
 * @param {boolean} inClass true, if we are inside a class definition
 */
function parseJS (tokenizer, inClass) {
    let result = _parsePrefixes(tokenizer)
    let nameAndType = {}

    switch (tokenizer.token) {
    case 'class': nameAndType = _parseClass(tokenizer); break
    case 'function': nameAndType = _parseFunction(tokenizer, 'function'); break
    case 'set':
    case 'get': nameAndType = _parseMember(tokenizer); break
    default:
        if (inClass) {
            nameAndType = _parseFunction(tokenizer, 'method'); break
        } else {
            nameAndType = _parseFunction(tokenizer, 'function'); break
        }
    }
    result = { ...result, ...nameAndType }
    return result
}

module.exports = { parseJS, addString }
