/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const shutdown = require('@mangar2/shutdown')
const { HttpServer } = require('@mangar2/httpservice')
const Persist = require('@mangar2/persist')
const { readConfiguration } = require('@mangar2/config')
const sanitizeConfiguration = require('./configuration')
const errorLog = require('@mangar2/errorlog')

const DEBUG = true

function pathToFilename(path) {
    let result = ''
    for (let i = 0; i < path.length; i++) {
        result += path.charCodeAt(i)
    }
    return result
}

class KeyValueStore {

    constructor(configuration) {
        this._configuration = sanitizeConfiguration(configuration)
        this._server = new HttpServer(this._configuration.port)
        this._persist = new Persist({ keepFiles: this._configuration.keepFiles })
    }

    /**
     * Handles a post request
     * @param {string} payload object payload
     * @param {string} path path of the request
     * @param {object} res result object
     */
    onOptions(res) {
        console.log('Reply to options request:')
        res.writeHead(200, { 
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',
            'Access-Control-Allow-Headers': 'content-type'
        })
        res.end('')
    }

    /**
     * Handles a post request
     * @param {string} payload object payload
     * @param {string} path path of the request
     * @param {object} res result object
     */
    async onPost(payload, path, res) {
        try {
            if (path.length > 100) {
                res.writeHead(400, {})
                res.end('Error: Key too long, a maximum of 100 characters are supported')
            } else {
                const filename = pathToFilename(path)
                console.log('POST, path:%s', path)
                const parsedData = JSON.parse(payload)
                await this._persist.saveObjectToFile(this._configuration.directory, filename, parsedData)
                console.log('File %s written', filename)
                res.writeHead(200,  { 'Access-Control-Allow-Origin': '*' })
                res.end('')
            }
        }
        catch (err) {
            errorLog(err, DEBUG)
            res.writeHead(400, {})
            res.end('Error in request')
        }
    }

    /**
     * Handles a get request
     * @param {string} path get request path
     * @param {object} res get request result object
     */
    async onGet(path, res) {
        try {
            if (path.length > 100) {
                res.writeHead(400, {})
                res.end('Error: Key too long, a maximum of 100 characters are suported')
            } else {
                const filename = pathToFilename(path)
                console.log('GET, path:%s', path)
                const payload = await this._persist.readData(this._configuration.directory, filename)
                console.log('File %s read', filename)
                res.writeHead(200,  { 'Access-Control-Allow-Origin': '*' })
                res.end(JSON.stringify(payload))
            }
        } catch (err) {
            errorLog(err, DEBUG)
            res.writeHead(400, {})
            res.end('Error in request')
        }
    }

    /**
     * Closes the server, stops listening
     */
    async close() {
        this.running = false
        await this.server.close()
        if (this._configuration.persistInterval !== 0) {
            await this.mqtt.connections.persist()
        }
    }


    /**
     * Starts the server
     */
    run() {
        shutdown(async () => {
            await this._server.close()
            process.exit(0)
        })
        this._server.on('POST', async (payload, headers, path, res) => { this.onPost(payload, path, res) })
        this._server.on('GET', async (searchParams, headers, path, res) => { this.onGet(path, res) })
        this._server.on('OPTIONS', (payload, headers, path, res) => { this.onOptions(res) })
        this._server.listen()
    }
}

const configuration = readConfiguration('yahakvstore.json')
const keyValueStore = new KeyValueStore(configuration)
keyValueStore.run()
