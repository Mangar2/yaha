/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @description
 * Provides a simple filter for logging topic based messages
 * @example
 * const logfilter = new LogFilter()
 * logfilter.changePattern([{ topic: 'input/%', module: 'receive', level: 1 }])
 * logfilter.condLogMessage('receive', new Message('hello world', 1), 1)
 */

'use strict'

const TopicMatch = require('@mangar2/topicmatch')
const CheckInput = require('@mangar2/checkinput')

const checkTopicList = new CheckInput({
    type: 'array',
    items: {
        type: 'object',
        properties: {
            topic: { type: 'string' },
            module: { type: 'string' },
            level: { type: 'number', minimum: '0' }
        },
        required: ['topic', 'module']
    }
})

/**
 * @typedef {object} LogPattern
 * @property {string} pattern log topic pattern
 * @property {string} module module to log, "send", "receive" or "all" (for all modules)
 * @property {number} level log level for the pattern
 */

module.exports = class LogFilter {
    constructor () {
        this.moduleFilter = {}
    }

    /**
     * Replaces the log filter patterns, deleting the current patterns and replace them with the new patterns
     * @param {LogPattern[]} patternList
     * @throws error, if the parameter is badly formatted
     */
    changePattern (patternList) {
        this.moduleFilter = {}
        checkTopicList.throwOnValidationError(patternList, 'log filter error')
        for (const pattern in patternList) {
            const filter = patternList[pattern]
            const module = filter.module
            const level = filter.level !== undefined ? filter.level : 0
            if (this.moduleFilter[module] === undefined) {
                this.moduleFilter[module] = new TopicMatch()
            }
            this.moduleFilter[module].setPattern(filter.topic, level)
        }
    }

    /**
     * Gets the log level
     * @param {string} module name of the module to check for
     * @param {string} topic topic to check
     * @returns {undefined | number} returns a log level or undefine, if logging is false
     */
    getLogLevel (module, topic) {
        let result
        if (typeof (this.moduleFilter[module]) === 'object') {
            result = this.moduleFilter[module].getBestMatch(topic)
        }
        if (typeof (this.moduleFilter.all) === 'object') {
            const match = this.moduleFilter.all.getBestMatch(topic)
            if (result === undefined || match > result) {
                result = match
            }
        }
        return result
    }

    /**
     * Logs a message
     * @param {string} moduleStr name of the "module" for logging
     * @param {Message} message message structure
     * @param {number} qos quality of service of message delivery
     * @param {boolean|number} dup duplicate flag (true/false, 0/1)
     */
    condLogMessage (moduleStr, message, qos, dup) {
        if (this.getLogLevel(moduleStr, message.topic) !== undefined) {
            let reasonStr = ''
            const reason = message.reason
            if (Array.isArray(reason)) {
                const length = reason.length
                reasonStr = moduleStr === 'received' ? reason[0].message : reason[length - 1].message
            }
            const valueStr = message.value === '' || message.value === undefined ? '' : '=' + message.value
            const dupStr = dup ? ',dup' : ''
            console.log('%s (qos%s%s) %s %s%s [%s]', new Date().toLocaleString(), qos, dupStr, moduleStr, message.topic, valueStr, reasonStr)
        }
    }
}
