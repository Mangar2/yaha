/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * Stores messages and checks, if a new message (usually a reply) matches one of the send messages
 * It only matches "action messages", i.e. messages whose topic ends on '/set', '/get', '/temporary', or '/blink'
 */

'use strict'

const ActionList = ['set', 'get', 'temporary', 'blink']

/**
 * @description Matches incoming "set" messages and outgoing messages to fill up the reason info
 * @example
 * const match = new MatchMessages()
 * match.addReceivedMessage(new Message('a/b', 'on', 'just a reason'))
 * const replyMessage = new Message('a/b', 'on', 'reply')
 * replyMessage = match.matchAndUpdateReplyMessage(replyMessage)
 */
class MatchMessages {
    /**
     * Constructs a new MatchMessage
     */
    constructor () {
        this._messageList = {}
    }

    /**
     * Adds a message to the received message list to match it with a reply
     * @param {Message} message message to store in the "received message list"
     */
    addReceivedMessage (message) {
        const topic = message.topic
        const topicArray = topic.split('/')
        const lastPartOfTopic = topicArray.pop()
        if (ActionList.includes(lastPartOfTopic)) {
            const replyTopic = topicArray.join('/')
            this._messageList[replyTopic] = message
        }
    }

    /**
     * Checks, if two values are matching
     * @param {string|number} value1 first value to match
     * @param {string|number} value2 second value to match
     * @returns {boolean}
     * @private
     */
    _isValueMatching (value1, value2) {
        const identical = value1 === value2
        const sameNumber = !isNaN(value1) && Number(value1) === Number(value2)
        return identical || sameNumber
    }

    /**
     * Checks, if a reply message matches any message received lately (in the last 30 seconds)
     * @param {Message} message message to match
     * @returns {boolean} true, if the message has a matching message with the same topic
     */
    hasMatchingMessage (message, maxTimespan = 30 * 1000) {
        let result = false
        const { topic, reason } = message
        if (this._messageList[topic]) {
            const receiveReason = this._messageList[topic].reason
            const valueMatches = this._isValueMatching(this._messageList[topic].value, message.value)
            if (valueMatches && Array.isArray(receiveReason) && Array.isArray(reason)) {
                const receiveTimestamp = new Date(receiveReason[0].timestamp).getTime()
                const replyTimestamp = new Date(reason[0].timestamp).getTime()
                const timeBetweenReplyAndReceive = replyTimestamp - receiveTimestamp
                result = (timeBetweenReplyAndReceive >= 0 && timeBetweenReplyAndReceive <= maxTimespan)
            }
        }
        return result
    }

    /**
     * Matches a reply message with a received message, updates the reasons and removes
     * the received message from the message list
     * The messages matches, if the have the save core topic (topic without action, 'set', 'get', 'temporary', 'blink') and the same value
     * @param {Message} message message to match
     * @returns {Message} matched message with updated reason or unchanged message, if the message do not match with a stored message
     */
    matchAndUpdateReplyMessage (message) {
        const { topic, reason } = message
        if (this.hasMatchingMessage(message)) {
            const receivedReason = this._messageList[topic].reason
            message.reason = [...receivedReason, ...reason]
        }
        // Delete the incoming message with the same topic even, if the message values are not matching
        if (this._messageList[topic]) {
            delete this._messageList[topic]
        }
        return message
    }
}

module.exports = MatchMessages
