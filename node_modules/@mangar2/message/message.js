/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * This is the basic class holding MQTT message information
 * The yaha home automation is based on messages. Nothing happens without a message.
 * The message runs from creator to broker and then to the receiver.
 * On every step, a reason will added to the mesage including a timestamp to get a full trace.
 */

'use strict'

const CheckInput = require('@mangar2/checkinput')

const checkMessage = new CheckInput({
    type: 'object',
    properties: {
        topic: { type: 'string' },
        reason: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    message: { type: 'string' },
                    timestamp: { type: 'string' }
                },
                required: ['message']
            }
        }
    },
    required: ['topic', 'value']
})

/**
 * @typedef {Object} ReasonEntry
 * @property {string} timestamp Timestamp of the event in ISO format
 * @property {string} message Event message
 */

/**
 * @typedef {ReasonEntry[]} Reason
 * @property {test} tst
 */

/**
 * @description
 * Creates a message for MQTT
 * @param {string} topic topic string
 * @param {(string|number)} [value=''] value to set topic to
 * @param {string|Reason} [reason=null] explaining, why the topic will be set to value
 * @param {Date} [now= new Date()] current time
 * @example
 * const message = new Message('this/is/a/topic', 'a value', 'a reason')
 */
class Message {
    constructor (topic, value = '', reason = null, now = new Date()) {
        this.topic = topic
        this.value = value
        if (reason !== undefined && reason !== null) {
            if (!Array.isArray(reason)) {
                this.addReason(reason, now)
            } else {
                this.reason = [...reason]
            }
        }
        Message.validate(this)
    }

    /**
     * Value of the message
     * @type {string|bool|number}
     */
    set value (value) { this._value = value }
    get value () { return this._value }

    /**
     * @description returns true, if the value is "on" (1, 'on', 'true', true)
     * @readonly
     * @type {boolean}
     */
    isOn () {
        return (this._value === 'on' || this._value === 'ON' || this._value === 'true' || this._value === true || this._value === 1)
    }

    /**
     * @description Quality of service (0, 1 or 2) the message shall be delivered
     * @type {integer}
     */
    set qos (qos) { this._qos = qos }
    get qos () { return this._qos }

    /**
     * @description True, if the message shall be retained
     * @type {boolean}
     */
    set retain (retain) { this._retain = retain }
    get retain () { return this._retain }

    /**
     * @description Adds a reason to the reason array
     * @param {string} reason explaining, why the topic will be set to value
     * @param {Date|undefined} now current time. If not provided, it will be calculated.
     *                         usually only passed for debugging reasons.
     */
    addReason (reason, now = new Date()) {
        if (!Array.isArray(this.reason)) {
            this.reason = []
        }
        this.reason.push({
            message: reason,
            timestamp: now.toISOString()
        })
    }

    /**
     * @description Gets the latest Date of the message by browsing the reasons
     * @returns {Date}
     */
    getDateOfNewestChange () {
        var time
        if (this.reason !== undefined) {
            for (const element of this.reason) {
                const timestamp = element.timestamp
                if (timestamp !== undefined) {
                    time = new Date(timestamp)
                    break
                }
            }
        }
        return time
    }

    /**
     * @description Checks the consistence of a message object
     * @param {Object} object object to check or this
     * @throws {error}
     */
    static validate (object) {
        if (checkMessage.validate(object) !== true) {
            throw Error(JSON.stringify(checkMessage.messages, null, 2))
        }
        return true
    }

    /**
     * @description ensures that the JSON format is well formatted (value instead of _value)
     */
    toJSON () {
        return {
            topic: this.topic,
            value: this._value,
            reason: this.reason,
            qos: this._qos,
            retain: this._retain
        }
    }
}

module.exports = Message
