
/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */
'use strict'

const CheckInput = require('@mangar2/checkinput')

const checkMessage = new CheckInput({
    type: 'object',
    properties: {
        topic: { type: 'string' },
        reason: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    message: { type: 'string' },
                    timestamp: { type: 'string' }
                },
                required: ['message']
            }
        }
    },
    required: ['topic', 'value']
})

/**
 * @typedef {Object} ReasonEntry
 * @property {string} timestamp of the event in ISO format
 * @property {string} message event message
 */

/**
 * @typedef {ReasonEntry[]} Reason
 */

/**
 * @description
 * Basic class holding MQTT messages.
 * The yaha home automation is based on messages. Nothing happens without a message. The message runs from creator to broker and then to the receiver. On every step, a reason will added including a timestamp to get a full trace.
 * Some values are automatically converted ('on'/'off' to 1/0, same for 'true'/'false' and true/false, Number strings are converted to numbers)
 * @param {string} topic topic string
 * @param {(string|number)} [value=''] value to set topic to
 * @param {string|Reason} [reason=null] explaining, why the topic will be set to value
 * @param {Date} [now= new Date()] current time
 * @example
 * const message = new Message('this/is/a/topic', 'a value', 'a reason')
 */
class Message {
    constructor (topic, value = '', reason = null, now = new Date()) {
        this.topic = topic
        this.value = value
        if (reason !== undefined && reason !== null) {
            if (!Array.isArray(reason)) {
                this.addReason(reason, now)
            } else {
                this.reason = [...reason]
            }
        }
        Message.validate(this)
    }

    /**
     * Sets value as an uniform value
     * @param {string|bool|number} value
     */
    set value (value) {
        if (value === '') {
            // keep value unchanged
        } else if (value === 'on' || value === 'true' || value === true) {
            value = 1
        } else if (value === 'off' || value === 'false' || value === false) {
            value = 0
        } else if (!isNaN(value)) {
            value = Number(value)
        }
        this._value = value
    }

    /**
     * gets the value of the message
     * booleans or strings 'true'/'false' are transformed to 0/1
     * number strings are transfored to numbers
     * 'on'/'off' are transformed to 1/0
     * @return {string|number} value in a uniform format
     */
    get value () { return this._value }

    /**
     * Adds a reason to the reason array
     * @param {string} reason explaining, why the topic will be set to value
     * @param {Date|undefined} now current time. If not provided, it will be calculated.
     *                         usually only passed for debugging reasons.
     */
    addReason (reason, now = new Date()) {
        if (!Array.isArray(this.reason)) {
            this.reason = []
        }
        this.reason.push({
            message: reason,
            timestamp: now.toISOString()
        })
    }

    /**
     * Gets the latest Date of the message by browsing the reasons
     * @returns {Date}
     */
    getDateOfNewestChange () {
        var time
        if (this.reason !== undefined) {
            for (const element of this.reason) {
                const timestamp = element.timestamp
                if (timestamp !== undefined) {
                    time = new Date(timestamp)
                    break
                }
            }
        }
        return time
    }

    /**
     * Checks the consistence of a message object
     * @param {Object} object object to check or this
     * @throws {error}
     */
    static validate (object) {
        if (checkMessage.validate(object) !== true) {
            throw Error(JSON.stringify(checkMessage.messages, null, 2))
        }
        return true
    }

    /**
     * ensures that the JSON format is well formatted (value instead of _value)
     */
    toJSON () {
        return {
            topic: this.topic,
            value: this.value,
            reason: this.reason
        }
    }
}

module.exports = Message
