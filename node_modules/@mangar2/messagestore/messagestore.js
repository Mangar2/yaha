/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      messagestore.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

'use strict';

const Persist = require("@mangar2/persist");
var persist = new Persist();

/**
 * Checks, if a function is a string
 * @param {any} x 
 */
function isString(x) {
    return Object.prototype.toString.call(x) === "[object String]"
}

/**
 * Savely gets a property from an object. Sets the property, if it is not defined
 * @param {object} object to get entry from
 * @param {string} propertyName name of the property to retrieve
 * @param {any} propertyValue value to set to the property, if the property is undefined
 * @result property of the object or undefined, if the property is not retrievable
 */
function getFromObject(object, propertyName, propertyValue) {
    var result;
    if (object !== undefined && propertyName !== undefined && isString(propertyName)) {
        if (!object.hasOwnProperty(propertyName) && propertyValue !== undefined) {
            object[propertyName] = propertyValue;
        }
        result = object[propertyName];
    }
    return result;
}

module.exports = class MessageStore {

    /**
     * Safely sets a configuration option, if the option is included in configuration and it is a number
     * Strings with numbers are converted to integer
     * @param {string} propertyName name of the property to set
     * @param {object} configuration object with property propertyName
     */
    setFromConfiguration(propertyName, configuration) {
        if (configuration !== undefined && !isNaN(configuration[propertyName])) {
            if (typeof(configuration[propertyName]) === 'string') {
                this.configuration[propertyName] = parseInt(configuration[propertyName]);
            }
        }
    }

    /**
     * Sets the property values of the class
     * @param {object} configuration configuration for the tree
     */
    constructor(configuration)  {
        this.configuration = {
            maxHistoryLength: 120,
            historyHysterese: 20
        }
        this.setFromConfiguration('maxHistoryLength', configuration);
        this.setFromConfiguration('historyHysterese', configuration);
        this.tree = {childs: {}};
    }

    /**
     * Persists all connections
     */
    async persist(directory, fileName) {
        await persist.saveObjectToFile(directory, fileName, this.tree);
    }

    /**
     * Checks if a node is a leaf node
     * @param {object} node node of the message tree
     */
    static isDataNode(node) {
        return node.hasOwnProperty("history");
    }

    /**
     * Initializes a leaf node
     * @param {object} node 
     */
    static initDataNode(node) {
        if (!node.hasOwnProperty("history")) {
            node.history = [];
        }
        if (!node.hasOwnProperty("series")) {
            node.series = [];
        }
    }

    /**
     * Gets the payload (time, data and history) of the node
     * @param {object} node tree node
     */
    static getPayload(node) {
        let result = {};
        for (let property in node) {
            if (property !== "childs") {
                result[property] = node[property];
            }
        }
        return result;
    }


    /**
     * Searches a node in the message tree corresponding to the topic. 
     * @param {string} topic topic to store the data
     * @returns {any} data to store
     */
    getNode(topic) {
        let topicChunks = topic.split("/");
        if (topicChunks[0] === "") {
            topicChunks.shift();
        }
        let childNode = this.tree;
        for (let topicChunk of topicChunks) {
            childNode = getFromObject(childNode.childs, topicChunk);
            if (childNode === undefined) {
                break;
            }
        }
        return childNode;
    }

    /**
     * Searches a node in the message tree corresponding to the topic. Creates empty nodes along the topic if 
     * the nodes are not yet available.
     * @param {string} topic topic to store the data
     * @returns {object} node in the tree
     */
    getAndCreateDataNode(topic) {
        let topicChunks = topic.split("/");
        if (topicChunks[0] === "") {
            topicChunks.shift();
        }
        let node = this.tree;
        for (let topicChunk of topicChunks) {
            node = getFromObject(node.childs, topicChunk, {childs:{}});
        }
        MessageStore.initDataNode(node);
        return node;
    }

    /**
     * Checks, if a value is at least twice unchanged
     * @param {array} series array of data values
     * @param {any} value value that is checked to be unchanged
     * @returns {boolean}
     */
    static isValueUnchanged(series, value) {
        let valueUnchanged = false;
        if (series.length > 1) {
            let lastValue = series[series.length-1][1];
            let secondLastValue = series[series.length - 2][1];
            if (value == lastValue && value === secondLastValue) {
                valueUnchanged = true;
            }
        } 
        return valueUnchanged;
    }

    /**
     * Updates the data entry (array of value/date) of the node
     * @param {*} node 
     */
    static updateData(node) {
        let value = node.value;
        if (typeof(value) !== 'object') {
            if (node.series.length === 0) {
                node.series.push([]);
            }
            let series = node.series[node.series.length - 1];
            if (MessageStore.isValueUnchanged(series, value)) {
                series[series.length-1][0] = node.time;
            } else {
                series.push([node.time, value]);
            }
        }
    }

    /**
     * Updates the data of a node and stores the old data to a history array.
     * The new history entry is added to the beginning of the queue. If the history length exceeds the 
     * maximal length, it will be reduces by "historyHysterese" amount of elements
     * @param {object} node node to update
     * @param {object} content new content of the node
     * @param {number} maxHistoryLength maximal amount of entries in the history
     * @param {number} historyHysterese amount of entries to delete, if history exeeds max length
     */
    static updateContent(node, content, maxHistoryLength, historyHysterese) {

        if (node.hasOwnProperty("value")) {
            let entry = {time: node.time, value: node.value, reason: node.reason};
            node.history = [entry, ...node.history];
        }
        for (let property in content) {
            node[property] = content[property];
        }
        MessageStore.updateData(node);
        if (node.history.length >= maxHistoryLength) {
            var newLength = maxHistoryLength - historyHysterese;
            if (newLength <= 0) {
                newLength = 1;
            }
            node.history = node.history.slice(0, newLength);
        }
    }

    /**
     * Adds data to the three node matching to the topic path. 
     * It will store the current time, data and descrition to the node and
     * the former time and data entry is copied to the history array property.
     * @param {Message} message {topic, value, reason}
     */
    addData(message) {
        let node = this.getAndCreateDataNode(message.topic);
        let time = new Date().getTime();
        let content = {time, topic: message.topic, value: message.value, reason: message.reason};

        MessageStore.updateContent(node, content, 
            this.configuration.maxHistoryLength, this.configuration.historyHysterese);
    };

    /**
     * Gets several levels of child nodes in one flat object structure
     * @param {object} node node of the message tree
     * @param {string} topic current topic
     * @param {Number} level amount of child levels to include
     */
    static getSectionRec(node, topic, levelAmount) {
        let result = {topics:[], payload:{}};

        if (topic === undefined || topic === "" || !isString(topic)) {
            topic = "/";
        }
        result.topics.push(topic);
        
        if (MessageStore.isDataNode(node)) {
            result.payload[topic] = MessageStore.getPayload(node);
            result.payload[topic].time = new Date(result.payload[topic].time).toISOString();
        }

        if (levelAmount > 0) {
            for(let childName in node.childs) {
                let childNode = node.childs[childName];
                let childTopic = topic === "/" ? "/" + childName : topic + "/" + childName;
                let subChildNodes = this.getSectionRec(childNode, childTopic, levelAmount - 1);
                result = {
                    topics: [...result.topics, ...subChildNodes.topics],
                    payload: {...result.payload, ...subChildNodes.payload}
                }
            }
        }
        return result;
    }

    /**
     * Gets several levels of child nodes in one flat object structure
     * @param {string} topic start topic of the section
     * @param {number} levelAmount amount of levels to get
     */
    getSection(topic, levelAmount) {
        let node = this.getNode(topic);
        let result = MessageStore.getSectionRec(node, topic, levelAmount);
        return result;
    }

}

