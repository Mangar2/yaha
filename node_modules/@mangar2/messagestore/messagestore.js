/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      messagestore.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

'use strict'

const Persist = require('@mangar2/persist')
const MessageTree = require('@mangar2/messagetree')
const HttpServer = require('@mangar2/httpservice').HttpServer

class MessageStore {
    /**
     * Creates a message store object and configures it. Adds a listener for get requests
     * @param {object} options message store parameters
     * @param {object} persist persistence configuraiton
     * @param {string} options.persist.directory directory to persist data
     * @param {string} options.persist.filename (base) filename to persist data (a timestamp is added)
     * @param {number} options.persist.keepFiles amount of file versions to keep (including the recently written file)
     * @param {number} options.persist.interval interval between file savings
     * @param {object} options.tree options of the message tree
     * @param {number} options.tree.maxHistoryLength maximum amount of entries in the history array
     * @param {number} options.tree.maxValuesLength maximum amount of values per history entry
     * @param {number} options.tree.historyHysterese hysterese to cut history length
     * @param {number} options.tree.upperBoundFactor upper bound to compare time spans (for inteval based compression)
     * @param {number} options.tree.upperBoundAddInMilliseconds upper bound add to compare time spans
     * @param {number} options.tree.lowerBoundFactor0.8, lower bound factor to compare time spans
     * @param {number} options.tree.lowerBoundSubInMilliseconds lower bound sub to compare time spans
     * @param {object} options.server
     * @param {number} options.server.port port to listen for get sensor data request
     * @param {string} options.server.path path to use to listen for sensor data (without leading '/')
     */
    constructor (options) {
        this.options = options
        this.persist = new Persist(options.persist)
        this.tree = new MessageTree(options.tree)
        this.tree.readTreeFromPersistedFile(options.persist.directory, options.persist.filename)
        this.httpServer = new HttpServer(options.server.port)
        this.isRunning = false
    }

    /**
     * Persists the data
     */
    async _persist () {
        while (this.isRunning) {
            await this.tree.persist(this.options.persist.directory, this.options.persist.fileName)
            await this.persist.delay(this.options.persist.interval)
        }
    }

    /**
     * Listens to a configures port
     */
    run () {
        this.httpServer.on('GET', (payload, headers, path, res) => {
            const pathArray = path.split('/')
            if (pathArray[1] === this.options.server.path) {
                const levelAmount = isNaN(headers.levelamount) ? 1 : Number(headers.levelamount)
                const topic = pathArray.slice(2).join('/')
                const addHistory = headers.history === 'true'
                payload = this.tree.getSection(topic, levelAmount, addHistory)
                const resultHeaders = {
                    'content-type': 'application/json; charset=UTF-8'
                }
                res.writeHead(200, resultHeaders)
                res.end(JSON.stringify(payload))
            } else {
                throw Error('unknown path ' + path)
            }
        })

        this.httpServer.listen()
        this.isRunning = true
        if (this.options.persist.interval !== 0) {
            this._persist()
        }
    }

    /**
     * Closes the broker, stops listening
     */
    async close () {
        this.isRunning = false
        await this.httpServer.close()
        if (this.options.persistInterval !== 0) {
            await this._persist()
        }
    }

    /**
     * Adds a message to the three node matching to the topic path.
     * @param {Message} message {topic, value, reason}
     * @param {string} message.topic topic string
     * @param {object} message.value value of the topic
     * @param {object[]} message.reason list of reasons
     */
    addMessage (message) {
        this.tree.addData(message)
    }

    /**
     * @type {MessageTree} tree of messages
     */
    get messages () { return this._messages }
    set messages (messages) { this._messages = messages }
}

module.exports = MessageStore
