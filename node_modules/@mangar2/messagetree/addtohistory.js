/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

/**
 * @private
 * @description Length of history entry array (time/value pairs) until the algorithm will try to compress it
 * to a shorter notation (remove values, if they are always equal or even store one the amount of equal values)
 * @type {number}
 */
const LENGTH_TO_CHECK_FOR_SHORTER_NOTATION = 10

/**
 * @private
 * @param {Reason} reason1
 * @param {Reason} reason2
 * @description Checks, if two reasons are similar
 */
function isReasonSimilar (reason1, reason2) {
    const sameAmountOfReasons = Array.isArray(reason1) && Array.isArray(reason2) && reason1.length === reason2.length
    let isSimilar = sameAmountOfReasons
    if (sameAmountOfReasons) {
        for (const index in reason1) {
            const message1 = reason1[index].message
            const message2 = reason2[index].message
            isSimilar = message1 === message2
            if (!isSimilar) break
        }
    }
    return isSimilar
}

/**
 * @private
 * @description Checks, if two entries are similar. They are similar, if the reasons are similar and the values are
 * identical
 */
function isEntrySimilar (entry1, entry2) {
    const entriesAreValid = entry1 !== undefined && entry1 !== null & entry2 !== undefined && entry2 !== null
    const reasonsAreSimilar = entriesAreValid && isReasonSimilar(entry1.reason, entry2.reason)
    return reasonsAreSimilar
}

/**
 * @private
 * @description Decides, if a new interval matches the former intervals by calculating an upper and a lower
 * bound
 * @param {number} newInterval time interval between the last two entries
 * @param {number} joinedInterval time interval of already joined entries
 * @param {Object} options options to calculate the bounds
 * @param {number} options.upperBoundFactor factor to multiply the joined interval for the upper bound
 * @param {number} options.upperBoundAddInMilliseconds constant to add to the joined interval for the upper bound
 * @param {number} options.lowerBoundFactor factor to multiply the joined interval for the lower bound
 * @param {number} options.lowerBoundSubInMilliseconds constant to sub from the joined interval for the lower bound
 */
function isMatchingInterval (newInterval, joinedInterval, options) {
    const belowUpperBound = newInterval < joinedInterval * options.upperBoundFactor + options.upperBoundAddInMilliseconds
    const aboveLowerBound = newInterval > joinedInterval * options.lowerBoundFactor - options.lowerBoundSubInMilliseconds
    return belowUpperBound && aboveLowerBound
}

/**
 * @private
 * @description checks if a new entry matches the interval entry (has same interval)
 * @param {Object} joinedEntry first entry
 * @param {Object} joinedEntry.value value of the entry
 * @param {number} joinedEntry.amount amount of messages with same value and time interval
 * @param {number} joinedEntry.firstTime timestamp the value was encountered first
 * @param {number} joinedEntry.lastTime timestamp the value was encoutered last
 * @param {Object} entryToAdd entry to add to the first entry
 * @param {number} entryToAdd.time timestamp of the entry to add
 * @param {Object} entryToAdd.value value of the entry to add entry
 * @param {Object} options options to calculate the bounds
 * @param {number} options.upperBoundFactor factor to multiply the joined interval for the upper bound
 * @param {number} options.upperBoundAddInMilliseconds constant to add to the joined interval for the upper bound
 * @param {number} options.lowerBoundFactor factor to multiply the joined interval for the lower bound
 * @param {number} options.lowerBoundSubInMilliseconds constant to sub from the joined interval for the lower bound
 * @returns {{type, values, reason}} firstEntry with one more element pushed to its timestamps array
 */
function isMatchingIntervaleEntry (joinedEntry, entryToAdd, options) {
    const sameValue = joinedEntry.value === entryToAdd.value
    let result = false
    if (sameValue) {
        const joinedInterval = (joinedEntry.lastTime - joinedEntry.firstTime) / (joinedEntry.amount - 1)
        const newInterval = entryToAdd.time - joinedEntry.lastTime
        result = isMatchingInterval(newInterval, joinedInterval, options)
    }
    return result
}

/**
 * @private
 * @description Creates a time/value entry for the history
 * @param {Object} firstEntry first entry
 * @param {number} firstEntry.time timestamp of the first entry
 * @param {Object} firstEntry.value value of the first entry
 * @param {Object} entryToAdd entry to add to the first entry
 * @param {number} entryToAdd.time timestamp of the entry to add
 * @param {Object} entryToAdd.value value of the entry to add entry
 * @returns {{values, reason}} Object with array of values[[time, value], [time, value]] and reason
 */
function createTimeValueEntry (firstEntry, entryToAdd) {
    const result = {
        type: 'timeValue',
        values: [[firstEntry.time, firstEntry.value], [entryToAdd.time, entryToAdd.value]],
        reason: firstEntry.reason
    }
    return result
}

/**
 * @private
 * @description adds an element to a time/value entry
 * @param {Object} timeValueEntry first entry
 * @param {Array} timeValueEntry.values array of time/value pairs
 * @param {string} timeValueEntry.type type of the entry ('timeValue')
 * @returns {{type, values, reason}} firstEntry with one more element pushed to its values entry
 */
function tryConvertToTimeEntry (timeValueEntry) {
    const TIME_INDEX = 0
    const VALUE_INDEX = 1
    let result = timeValueEntry
    let isValueIdentical = true
    const value = timeValueEntry.values[0][VALUE_INDEX]
    const timestamps = []
    for (const entry of timeValueEntry.values) {
        timestamps.push(entry[TIME_INDEX])
        if (entry[VALUE_INDEX] !== value) {
            isValueIdentical = false
            break
        }
    }
    if (isValueIdentical) {
        result = { type: 'time', value, timestamps, reason: timeValueEntry.reason }
    }
    return result
}

/**
 * @private
 * @description adds an element to a time entry
 * @param {Object} timeEntry first entry
 * @param {number[]} timeEntry.timestamps array of timestamps pairs
 * @param {string} timeEntry.type type of the entry ('time')
 * @param {Object} options options to calculate the bounds
 * @param {number} options.upperBoundFactor factor to multiply the joined interval for the upper bound
 * @param {number} options.upperBoundAddInMilliseconds constant to add to the joined interval for the upper bound
 * @param {number} options.lowerBoundFactor factor to multiply the joined interval for the lower bound
 * @param {number} options.lowerBoundSubInMilliseconds constant to sub from the joined interval for the lower bound
 * @returns {{type, values, reason}} entry with one more element pushed to its values entry
 */
function tryConvertToIntervalEntry (timeEntry, options) {
    let result = timeEntry
    const firstTime = timeEntry.timestamps[0]
    const amount = timeEntry.timestamps.length
    const lastTime = timeEntry.timestamps[amount - 1]
    const joinedInterval = (lastTime - firstTime) / (amount - 1)
    let allIntervalsMatch = true
    for (let index = 1; index < amount; index++) {
        const newInterval = timeEntry.timestamps[index] - timeEntry.timestamps[index - 1]
        if (!isMatchingInterval(newInterval, joinedInterval, options)) {
            allIntervalsMatch = false
            break
        }
    }
    if (allIntervalsMatch) {
        result = { type: 'interval', firstTime, lastTime, amount, value: timeEntry.value, reason: timeEntry.reason }
    }
    return result
}

/**
 * @private
 * @description tries to compress a time/value entry either to a "time only array" or a "just interval" entry
 * @param {Object} timeValueEntry first entry
 * @param {Array} timeValueEntry.values array of time/value pairs
 * @param {string} timeValueEntry.type type of the entry ('timeValue')
 * @param {Object} options options to calculate the bounds
 * @param {number} options.upperBoundFactor factor to multiply the joined interval for the upper bound
 * @param {number} options.upperBoundAddInMilliseconds constant to add to the joined interval for the upper bound
 * @param {number} options.lowerBoundFactor factor to multiply the joined interval for the lower bound
 * @param {number} options.lowerBoundSubInMilliseconds constant to sub from the joined interval for the lower bound
 * @returns {{type, values, reason}} timeValueEntry or timeEntry or intervalEntry
 */
function tryToCompress (timeValueEntry, options) {
    let result = timeValueEntry
    if (timeValueEntry.values.length === LENGTH_TO_CHECK_FOR_SHORTER_NOTATION) {
        result = tryConvertToTimeEntry(timeValueEntry)
        if (result.type === 'time') {
            result = tryConvertToIntervalEntry(result, options)
        }
    }
    return result
}

/**
 * @private
 * @description Adds an element to the history array. It will be added as first element
 * @param {Object[]} history array of elements
 * @param {Object} entryToAdd entry to add to the history entry
 * @returns {Object[]} new history with added element
 */
function addNewElementToHistory (history, entryToAdd) {
    entryToAdd.type = 'single'
    history.unshift(entryToAdd)
    return history
}

/**
 * @private
 * @description adds an element to a time/value entry
 * @param {Object} firstEntry first entry
 * @param {number} firstEntry.values array of values
 * @param {Object} entryToAdd entry to add to the first entry
 * @param {number} entryToAdd.time timestamp of the entry to add
 * @param {Object} entryToAdd.value value of the entry to add entry
 * @returns {{type, values, reason}} firstEntry with one more element pushed to its values entry
 */
function addToTimeValueEntry (firstEntry, entryToAdd) {
    firstEntry.values.push([entryToAdd.time, entryToAdd.value])
    return firstEntry
}

/**
 * @private
 * @description adds an element to a time entry
 * @param {Object} joinedEntry first entry
 * @param {Object} joinedEntry.value value of the entry
 * @param {number} joinedEntry.timestamps array of timestamps
 * @param {Object} entryToAdd entry to add to the first entry
 * @param {number} entryToAdd.time timestamp of the entry to add
 * @param {Object} entryToAdd.value value of the entry to add entry
 * @returns {{type, values, reason}} firstEntry with one more element pushed to its timestamps array
 */
function addToTimeEntry (joinedEntry, entryToAdd) {
    joinedEntry.timestamps.push(entryToAdd.time)
    return joinedEntry
}

/**
 * @private
 * @description adds an element to an interval entry
 * @param {Object} joinedEntry first entry
 * @param {Object} joinedEntry.value value of the entry
 * @param {number} joinedEntry.amount amount of messages with same value and time interval
 * @param {number} joinedEntry.firstTime timestamp the value was encountered first
 * @param {number} joinedEntry.lastTime timestamp the value was encoutered last
 * @param {Object} entryToAdd entry to add to the first entry
 * @param {number} entryToAdd.time timestamp of the entry to add
 * @param {Object} entryToAdd.value value of the entry to add entry
 * @returns {{type, values, reason}} firstEntry with one more element pushed to its timestamps array
 */
function addToIntervalEntry (joinedEntry, entryToAdd) {
    joinedEntry.lastTime = entryToAdd.time
    joinedEntry.amount++
    return joinedEntry
}

/**
 * @private
 * @description Truncates the history array, if it is too large.
 * @param {Object[]} history array of elements
 * @param {Object} options options
 * @param {number} options.maxHistoryLength maximal amount of entries in the history
 * @param {number} options.historyHysterese amount of entries to delete, if history exeeds max length
 * @returns {Object[]} possible truncated history
 */
function truncateHistoryIfTooLarge (history, options) {
    if (history.length >= options.maxHistoryLength) {
        let newLength = options.maxHistoryLength - options.historyHysterese
        if (newLength <= 0) {
            newLength = 1
        }
        history = history.slice(0, newLength)
    }
    return history
}

/**
 * @description Adds an entry to the history and possible add it or join it with the latest history entry
 * @param {Object[]} history history list
 * @param {string} [history[].type] type of the entry ('single', 'timeValue', 'time', 'interval)
 * @param {number} [history[].time] timestamp of the second entry (only type 'single')
 * @param {number} [history[].value] value of the first entry (only types 'single', 'time', 'interval')
 * @param {Object[]} history[].reason list of reasons
 * @param {Object[]} [history[].timeValue] array of [time, value] (only type 'timeValue')
 * @param {number[]} [history[].timestamps] array of timestamps (only type 'time')
 * @param {number} [history[].amount] amount of entries joined before (only type 'interval')
 * @param {number} [history[].firstTime] timestamp the value was encountered first (only type 'interval')
 * @param {number} [history[].lastTime] timestamp the value was encoutered last (only type 'interval')
 * @param {Object} entryToAdd first entry
 * @param {number} entryToAdd.time timestamp of the first entry
 * @param {Object} entryToAdd.value value of the first entry
 * @param {Object[]} entryToAdd.reason list of reasons
 * @param {Object} options options to calculate the bounds
 * @param {number} options.upperBoundFactor factor to multiply the joined interval for the upper bound
 * @param {number} options.upperBoundAddInMilliseconds constant to add to the joined interval for the upper bound
 * @param {number} options.lowerBoundFactor factor to multiply the joined interval for the lower bound
 * @param {number} options.lowerBoundSubInMilliseconds constant to sub from the joined interval for the lower bound
 * @param {number} options.maxHistoryLength maximal amount of entries in the history
 * @param {number} options.historyHysterese amount of entries to delete, if history exeeds max length
 * @returns {Object[]} new history (array of entries)
 */
function addToHistory (history, entryToAdd, options) {
    if (history.length === 0) {
        history = addNewElementToHistory(history, entryToAdd)
    } else if (!isEntrySimilar(entryToAdd, history[0])) {
        history = addNewElementToHistory(history, entryToAdd)
    } else {
        switch (history[0].type) {
        case 'single':
            history[0] = createTimeValueEntry(history[0], entryToAdd)
            break
        case 'timeValue':
            history[0] = addToTimeValueEntry(history[0], entryToAdd)
            history[0] = tryToCompress(history[0], options)
            break
        case 'time':
            if (history[0].value === entryToAdd.value) {
                history[0] = addToTimeEntry(history[0], entryToAdd)
            } else {
                history = addNewElementToHistory(history, entryToAdd)
            }
            break
        case 'interval':
            if (isMatchingIntervaleEntry(history[0], entryToAdd, options)) {
                history[0] = addToIntervalEntry(history[0], entryToAdd)
            } else {
                history = addNewElementToHistory(history, entryToAdd)
            }
            break
        }
    }
    history = truncateHistoryIfTooLarge(history, options)

    return history
}

module.exports = addToHistory
