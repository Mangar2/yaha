/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      addToHistory.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

'use strict'

/**
 * Checks, if two reasons are similar
 */
function isReasonSimilar (reason1, reason2) {
    const sameAmountOfReasons = Array.isArray(reason1) && Array.isArray(reason2) && reason1.length === reason2.length
    let isSimilar = sameAmountOfReasons
    if (sameAmountOfReasons) {
        for (const index in reason1) {
            const message1 = reason1[index].message
            const message2 = reason2[index].message
            isSimilar = message1 === message2
            if (!isSimilar) break
        }
    }
    return isSimilar
}

/**
 * Checks, if two entries are similar. They are similar, if the reasons are similar and the values are
 * identical
 */
function isEntrySimilar (entry1, entry2) {
    const entriesAreValid = entry1 !== undefined && entry1 !== null & entry2 !== undefined && entry2 !== null
    const reasonsAreSimilar = entriesAreValid && isReasonSimilar(entry1.reason, entry2.reason)
    return reasonsAreSimilar
}

/**
 * Decides, if a new interval matches the former intervals by calculating an upper and a lower
 * bound
 * @param {number} newInterval time interval between the last two entries
 * @param {number} joinedInterval time interval of already joined entries
 * @param {object} options options to calculate the bounds
 * @param {number} options.upperBoundFactor factor to multiply the joined interval for the upper bound
 * @param {number} options.upperBoundAddInMilliseconds constant to add to the joined interval for the upper bound
 * @param {number} options.lowerBoundFactor factor to multiply the joined interval for the lower bound
 * @param {number} options.lowerBoundSubInMilliseconds constant to sub from the joined interval for the lower bound
 */
function isMatchingInterval (newInterval, joinedInterval, options) {
    const belowUpperBound = newInterval < joinedInterval * options.upperBoundFactor + options.upperBoundAddInMilliseconds
    const aboveLowerBound = newInterval > joinedInterval * options.lowerBoundFactor - options.lowerBoundSubInMilliseconds
    return belowUpperBound && aboveLowerBound
}

/**
 * Joins entry1 to entry2 or return undefined
 * @param {object} entryToAdd first entry
 * @param {number} entryToAdd.time timestamp of the first entry
 * @param {object} entryToAdd.value value of the first entry
 * @param {[reason]} entryToAdd.reason list of reasons
 * @param {object} entryJoined second entry
 * @param {number} entryJoined.time timestamp of the second entry
 * @param {object} entryJoined.value value of the first entry
 * @param {[reason]} entryJoined.reason list of reasons
 * @param {number|undefined} entryJoined.amount amount of entries joined before
 * @param {number|undefined} entryJoined.interval interval between entries
 * @param {object} options options to calculate the bounds
 * @param {number} options.upperBoundFactor factor to multiply the joined interval for the upper bound
 * @param {number} options.upperBoundAddInMilliseconds constant to add to the joined interval for the upper bound
 * @param {number} options.lowerBoundFactor factor to multiply the joined interval for the lower bound
 * @param {number} options.lowerBoundSubInMilliseconds constant to sub from the joined interval for the lower bound
 * @returns{entry|undefined} either the joined entry or undefined if the entries shall not be joined
 */
function joinMatchingEntries (entryToAdd, entryJoined, options) {
    let result
    const tooManyEntries = Array.isArray(entryJoined.values) && entryJoined.values.length >= options.maxValuesLength

    if (!tooManyEntries && isEntrySimilar(entryToAdd, entryJoined)) {
        // Check, if we have an amount of at least two to identify a joined entry
        if (!Array.isArray(entryJoined.values)) {
            entryJoined.values = []
            entryJoined.values.push([entryJoined.time, entryJoined.Value])
            delete entryJoined.time
            delete entryJoined.value
        }
        entryJoined.values.push([entryToAdd.time, entryToAdd.value])
        result = true
    }

    return result
}

/**
 * Adds an entry to the history and possible add it or join it with the latest history entry
 * @param {object} entryToAdd first entry
 * @param {number} entryToAdd.time timestamp of the first entry
 * @param {object} entryToAdd.value value of the first entry
 * @param {object[]} entryToAdd.reason list of reasons
 * @param {[object]} history history list
 * @param {number} history[].time timestamp of the second entry
 * @param {object} history[].value value of the first entry
 * @param {object[]]} history[].reason list of reasons
 * @param {number|undefined} history[].amount amount of entries joined before
 * @param {number|undefined} history[].interval interval between entries
 * @param {object} options options to calculate the bounds
 * @param {number} options.upperBoundFactor factor to multiply the joined interval for the upper bound
 * @param {number} options.upperBoundAddInMilliseconds constant to add to the joined interval for the upper bound
 * @param {number} options.lowerBoundFactor factor to multiply the joined interval for the lower bound
 * @param {number} options.lowerBoundSubInMilliseconds constant to sub from the joined interval for the lower bound
 * @param {number} options.maxHistoryLength maximal amount of entries in the history
 * @param {number} options.historyHysterese amount of entries to delete, if history exeeds max length
 * @returns {[object]]} new history (array of entries)
 */
function addToHistory (entryToAdd, history, options) {
    if (history.length === 0) {
        history = [entryToAdd]
    } else {
        const joined = joinMatchingEntries(entryToAdd, history[0], options)
        if (joined === undefined) {
            history = [entryToAdd, ...history]
        } else {
            // nothing to do. joinMatchingEntries already joined the first entry of the history
        }
    }

    if (history.length >= options.maxHistoryLength) {
        let newLength = options.maxHistoryLength - options.historyHysterese
        if (newLength <= 0) {
            newLength = 1
        }
        history = history.slice(0, newLength)
    }

    return history
}

module.exports = addToHistory
