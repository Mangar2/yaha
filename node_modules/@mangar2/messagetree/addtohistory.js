/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      addToHistory.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

'use strict'

// the value used here is flexible. It may not be smaller than 2 and not too large
// @type {number}
/**
 * Length of history entry array (time/value pairs) until the algorithm will try to compress it
 * to a shorter notation (remove values, if they are always equal or even store one the amount of equal values)
 * @type {number}
 */
const LENGTH_TO_CHECK_FOR_SHORTER_NOTATION = 10

/**
 * @private
 * Checks, if two reasons are similar
 */
function isReasonSimilar (reason1, reason2) {
    const sameAmountOfReasons = Array.isArray(reason1) && Array.isArray(reason2) && reason1.length === reason2.length
    let isSimilar = sameAmountOfReasons
    if (sameAmountOfReasons) {
        for (const index in reason1) {
            const message1 = reason1[index].message
            const message2 = reason2[index].message
            isSimilar = message1 === message2
            if (!isSimilar) break
        }
    }
    return isSimilar
}

/**
 * Checks, if two entries are similar. They are similar, if the reasons are similar and the values are
 * identical
 */
function isEntrySimilar (entry1, entry2) {
    const entriesAreValid = entry1 !== undefined && entry1 !== null & entry2 !== undefined && entry2 !== null
    const reasonsAreSimilar = entriesAreValid && isReasonSimilar(entry1.reason, entry2.reason)
    return reasonsAreSimilar
}

/**
 * @private
 * Decides, if a new interval matches the former intervals by calculating an upper and a lower
 * bound
 * @param {number} newInterval time interval between the last two entries
 * @param {number} joinedInterval time interval of already joined entries
 * @param {object} options options to calculate the bounds
 * @param {number} options.upperBoundFactor factor to multiply the joined interval for the upper bound
 * @param {number} options.upperBoundAddInMilliseconds constant to add to the joined interval for the upper bound
 * @param {number} options.lowerBoundFactor factor to multiply the joined interval for the lower bound
 * @param {number} options.lowerBoundSubInMilliseconds constant to sub from the joined interval for the lower bound
 */
function isMatchingInterval (newInterval, joinedInterval, options) {
    const belowUpperBound = newInterval < joinedInterval * options.upperBoundFactor + options.upperBoundAddInMilliseconds
    const aboveLowerBound = newInterval > joinedInterval * options.lowerBoundFactor - options.lowerBoundSubInMilliseconds
    return belowUpperBound && aboveLowerBound
}

/**
 * @private
 * checks if a new entry matches the interval entry (has same interval)
 * @param {object} joinedEntry first entry
 * @param {object} joinedEntry.value value of the entry
 * @param {number} joinedEntry.amount amount of messages with same value and time interval
 * @param {number} joinedEntry.firstTime timestamp the value was encountered first
 * @param {number} joinedEntry.lastTime timestamp the value was encoutered last
 * @param {object} entryToAdd entry to add to the first entry
 * @param {number} entryToAdd.time timestamp of the entry to add
 * @param {object} entryToAdd.value value of the entry to add entry
 * @param {object} options options to calculate the bounds
 * @param {number} options.upperBoundFactor factor to multiply the joined interval for the upper bound
 * @param {number} options.upperBoundAddInMilliseconds constant to add to the joined interval for the upper bound
 * @param {number} options.lowerBoundFactor factor to multiply the joined interval for the lower bound
 * @param {number} options.lowerBoundSubInMilliseconds constant to sub from the joined interval for the lower bound
 * @returns {{type, values, reason}} firstEntry with one more element pushed to its timestamps array
 */
function isMatchingIntervaleEntry (joinedEntry, entryToAdd, options) {
    const sameValue = joinedEntry.value === entryToAdd.value
    let result = false
    if (sameValue) {
        const joinedInterval = (joinedEntry.lastTime - joinedEntry.firstTime) / (joinedEntry.amount - 1)
        const newInterval = entryToAdd.time - joinedEntry.lastTime
        result = isMatchingInterval(newInterval, joinedInterval, options)
    }
    return result
}

/**
 * @private
 * Creates a time/value entry for the history
 * @param {object} firstEntry first entry
 * @param {number} firstEntry.time timestamp of the first entry
 * @param {object} firstEntry.value value of the first entry
 * @param {object} entryToAdd entry to add to the first entry
 * @param {number} entryToAdd.time timestamp of the entry to add
 * @param {object} entryToAdd.value value of the entry to add entry
 * @returns {{values, reason}} Object with array of values[[time, value], [time, value]] and reason
 */
function createTimeValueEntry (firstEntry, entryToAdd) {
    const result = {
        type: 'timeValue',
        values: [[firstEntry.time, firstEntry.value], [entryToAdd.time, entryToAdd.value]],
        reason: firstEntry.reason
    }
    return result
}

/**
 * @private
 * adds an element to a time/value entry
 * @param {object} timeValueEntry first entry
 * @param {[number, object]} timeValueEntry.values array of time/value pairs
 * @param {string} timeValueEntry.type type of the entry ('timeValue')
 * @returns {{type, values, reason}} firstEntry with one more element pushed to its values entry
 */
function tryConvertToTimeEntry (timeValueEntry) {
    const TIME_INDEX = 0
    const VALUE_INDEX = 1
    let result = timeValueEntry
    if (timeValueEntry.values.length === LENGTH_TO_CHECK_FOR_SHORTER_NOTATION) {
        let isValueIdentical = true
        const value = timeValueEntry.values[0][VALUE_INDEX]
        const timestamps = []
        for (const entry of timeValueEntry.values) {
            timestamps.push(entry[TIME_INDEX])
            if (entry[VALUE_INDEX] !== value) {
                isValueIdentical = false
                break
            }
        }
        if (isValueIdentical) {
            result = { type: 'time', value, timestamps, reason: timeValueEntry.reason }
        }
    }
    return result
}

/**
 * @private
 * adds an element to a time entry
 * @param {object} timeEntry first entry
 * @param {[number]} timeValueEntry.timestamps array of timestamps pairs
 * @param {string} timeValueEntry.type type of the entry ('time')
 * @param {object} options options to calculate the bounds
 * @param {number} options.upperBoundFactor factor to multiply the joined interval for the upper bound
 * @param {number} options.upperBoundAddInMilliseconds constant to add to the joined interval for the upper bound
 * @param {number} options.lowerBoundFactor factor to multiply the joined interval for the lower bound
 * @param {number} options.lowerBoundSubInMilliseconds constant to sub from the joined interval for the lower bound
 * @returns {{type, values, reason}} entry with one more element pushed to its values entry
 */
function tryConvertToIntervalEntry (timeEntry, options) {
    let result = timeEntry
    if (timeEntry.timestamps.length === LENGTH_TO_CHECK_FOR_SHORTER_NOTATION + 1) {
        const firstTime = timeEntry.timestamps[0]
        const amount = timeEntry.timestamps.length
        const lastTime = timeEntry.timestamps[amount - 1]
        const joinedInterval = (lastTime - firstTime) / (amount - 1)
        let allIntervalsMatch = true
        for (let index = 1; index < amount; index++) {
            const newInterval = timeEntry.timestamps[index] - timeEntry.timestamps[index - 1]
            if (!isMatchingInterval(newInterval, joinedInterval, options)) {
                allIntervalsMatch = false
                break
            }
        }
        if (allIntervalsMatch) {
            result = { type: 'interval', firstTime, lastTime, amount, value: timeEntry.value, reason: timeEntry.reason }
        }
    }
    return result
}

/**
 * @private
 * tries to compress a time/value entry either to a "time only array" or a "just interval" entry
 * @param {object} timeValueEntry first entry
 * @param {[number, object]} timeValueEntry.values array of time/value pairs
 * @param {string} timeValueEntry.type type of the entry ('timeValue')
 * @param {object} options options to calculate the bounds
 * @param {number} options.upperBoundFactor factor to multiply the joined interval for the upper bound
 * @param {number} options.upperBoundAddInMilliseconds constant to add to the joined interval for the upper bound
 * @param {number} options.lowerBoundFactor factor to multiply the joined interval for the lower bound
 * @param {number} options.lowerBoundSubInMilliseconds constant to sub from the joined interval for the lower bound
 * @returns {{type, values, reason}} timeValueEntry or timeEntry or intervalEntry
 */
function tryToCompress (timeValueEntry, options) {
    let result = timeValueEntry
    if (timeValueEntry.timestamps.length === LENGTH_TO_CHECK_FOR_SHORTER_NOTATION) {
        result = tryConvertToTimeEntry(timeValueEntry)
        if (result.type === 'time') {
            result = tryConvertToIntervalEntry(result, options)
        }
    }
    return result
}

/**
 * @private
 * Adds an element to the history array. It will be added as first element
 * @param {object[]} histoy array of elements
 * @param {object} entryToAdd entry to add to the history entry
 */
function addNewElementToHistory (history, entryToAdd) {
    entryToAdd.type = 'new'
    history.unshift(entryToAdd)
    return history
}

/**
 * @private
 * adds an element to a time/value entry
 * @param {object} firstEntry first entry
 * @param {number} firstEntry.values array of values
 * @param {object} entryToAdd entry to add to the first entry
 * @param {number} entryToAdd.time timestamp of the entry to add
 * @param {object} entryToAdd.value value of the entry to add entry
 * @returns {{type, values, reason}} firstEntry with one more element pushed to its values entry
 */
function addToTimeValueEntry (firstEntry, entryToAdd) {
    firstEntry.values.push([entryToAdd.time, entryToAdd.value])
    return firstEntry
}

/**
 * @private
 * adds an element to a time entry
 * @param {object} joinedEntry first entry
 * @param {object} joinedEntry.value value of the entry
 * @param {number} joinedEntry.timestamps array of timestamps
 * @param {object} entryToAdd entry to add to the first entry
 * @param {number} entryToAdd.time timestamp of the entry to add
 * @param {object} entryToAdd.value value of the entry to add entry
 * @returns {{type, values, reason}} firstEntry with one more element pushed to its timestamps array
 */
function addToTimeEntry (joinedEntry, entryToAdd) {
    joinedEntry.timestamps.push(entryToAdd.time)
    return joinedEntry
}

/**
 * @private
 * adds an element to an interval entry
 * @param {object} joinedEntry first entry
 * @param {object} joinedEntry.value value of the entry
 * @param {number} joinedEntry.amount amount of messages with same value and time interval
 * @param {number} joinedEntry.firstTime timestamp the value was encountered first
 * @param {number} joinedEntry.lastTime timestamp the value was encoutered last
 * @param {object} entryToAdd entry to add to the first entry
 * @param {number} entryToAdd.time timestamp of the entry to add
 * @param {object} entryToAdd.value value of the entry to add entry
 * @returns {{type, values, reason}} firstEntry with one more element pushed to its timestamps array
 */
function addToIntervalEntry (joinedEntry, entryToAdd) {
    joinedEntry.lastTime = entryToAdd.time
    joinedEntry.amount++
    return joinedEntry
}

/**
 * @private
 * Truncates the history array, if it is too large.
 * @param {object[]} histoy array of elements
 * @param {object} options options
 * @param {number} options.maxHistoryLength maximal amount of entries in the history
 * @param {number} options.historyHysterese amount of entries to delete, if history exeeds max length
 * @returns {object[]} possible truncated history
 */
function truncateHistoryIfTooLarge (history, options) {
    if (history.length >= options.maxHistoryLength) {
        let newLength = options.maxHistoryLength - options.historyHysterese
        if (newLength <= 0) {
            newLength = 1
        }
        history = history.slice(0, newLength)
    }
    return history
}

/**
 * @public
 * Adds an entry to the history and possible add it or join it with the latest history entry
 * @param {[object]} history history list
 * @param {number} history[].time timestamp of the second entry
 * @param {object} history[].value value of the first entry
 * @param {object[]]} history[].reason list of reasons
 * @param {number|undefined} history[].amount amount of entries joined before
 * @param {number|undefined} history[].interval interval between entries
 * @param {object} entryToAdd first entry
 * @param {number} entryToAdd.time timestamp of the first entry
 * @param {object} entryToAdd.value value of the first entry
 * @param {object[]} entryToAdd.reason list of reasons
 * @param {object} options options to calculate the bounds
 * @param {number} options.upperBoundFactor factor to multiply the joined interval for the upper bound
 * @param {number} options.upperBoundAddInMilliseconds constant to add to the joined interval for the upper bound
 * @param {number} options.lowerBoundFactor factor to multiply the joined interval for the lower bound
 * @param {number} options.lowerBoundSubInMilliseconds constant to sub from the joined interval for the lower bound
 * @param {number} options.maxHistoryLength maximal amount of entries in the history
 * @param {number} options.historyHysterese amount of entries to delete, if history exeeds max length
 * @returns {[object]]} new history (array of entries)
 */
function addToHistory (history, entryToAdd, options) {
    if (history.length === 0) {
        history = addNewElementToHistory(history, entryToAdd)
    } else if (!isEntrySimilar(entryToAdd, history[0])) {
        history = addNewElementToHistory(history, entryToAdd)
    } else {
        switch (history[0].type) {
        case 'new':
            history[0] = createTimeValueEntry(history[0], entryToAdd)
            break
        case 'timeValue':
            history[0] = addToTimeValueEntry(history[0], entryToAdd)
            history[0] = tryToCompress(history[0])
            break
        case 'time':
            if (history[0].value === entryToAdd.value) {
                history[0] = addToTimeEntry(history[0], entryToAdd)
            } else {
                history = addNewElementToHistory(history, entryToAdd)
            }
            break
        case 'interval':
            if (isMatchingIntervaleEntry(history[0], entryToAdd)) {
                history[0] = addToIntervalEntry(history[0], entryToAdd)
            } else {
                history = addNewElementToHistory(history, entryToAdd)
            }
            break
        }
    }
    history = truncateHistoryIfTooLarge(history, options)

    return history
}

module.exports = addToHistory
