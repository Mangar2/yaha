/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */
'use strict'

const MessageTree = require('@mangar2/messagetree')
const TestRun = require('@mangar2/testrun')
const Message = require('@mangar2/message')
const { types } = require('@mangar2/utils')
const burst = require('./burst')
const VERBOSE = true

const testRun = new TestRun(VERBOSE)
const testStart = new Date().getTime()

/**
 * Delays a test for a while
 * @param {number} milliseconds amount of milliseconds
 */
const delaySync = (milliseconds) => {
    const waitTill = new Date(new Date().getTime() + milliseconds)
    while (waitTill > new Date()) {}
}

/**
 * Prepare a test case
 */
testRun.on('prepare', (testCase) => {
    const config = testCase.config !== undefined ? testCase.config : {}
    const messageTree = new MessageTree(config)
    for (const index in testCase.add) {
        if (testCase.delay) {
            delaySync(testCase.delay[index])
        }
        const messageData = testCase.add[index]
        const message = new Message(...messageData)
        messageTree.addData(message)
    }
    return messageTree
})

/**
 * Reruns a failed test for debugging
 */
testRun.on('break', (test, messageTree) => {
    const node = messageTree.getNode(test.getNode)
    console.log(node)
})

/**
 * Runs the test
 */
testRun.on('run', (test, messageTree) => {
    const node = messageTree.getNode(test.getNode)
    return node
})

/**
 * Check if a timestamp is valid (between test start and current time)
 * @param {number} timestamp timestamp to check
 */
const checkTimestamp = (timestamp) => {
    const now = new Date().getTime()
    return (timestamp >= testStart && timestamp <= now)
}

/**
 * Checks a property
 * @param {string|number|Array} expected expected value
 * @param {string|number|Array} valueToTest
 * @param {string} property name of the property
 * @param {string} path test description
 * @returns {boolean} true, if the property is as expected
 */
const checkProperty = (expected, valueToTest, property, path) => {
    let result = true
    if (types.isArray(expected)) {
        result = testRun.unitTest.assertEqual(expected.length, valueToTest.length, path)
        for (const index in expected) {
            result = result && checkProperty(expected[index], valueToTest[index], property, path)
        }
    } else if (property === 'reason') {
        result = testRun.unitTest.assertEqual(expected, valueToTest[0].message, path)
    } else if (expected === 'timestamp') {
        result = testRun.unitTest.assertTrue(checkTimestamp(valueToTest), path)
    } else {
        result = testRun.unitTest.assertEqual(expected, valueToTest, path)
    }
    return result
}

/**
 * Checks if the history matches the expected result
 * @param {Object} expected expected history structure
 * @param {Object} history found history structure
 * @param {string} path test path information
 */
const checkHistory = (expected, history, path) => {
    let result = true
    result = testRun.unitTest.assertEqual(expected.length, history.length, path)
    for (const index in history) {
        const entry = history[index]
        const expectedHistory = expected[index]
        for (const property in expectedHistory) {
            result = result &&
                checkProperty(expectedHistory[property], entry[property], property, path)
        }
    }
    return result
}

/**
 * Validates the test result
 */
testRun.on('validate', (test, node, path) => {
    let isCorrect = true
    if (test.expected === 'undefined') {
        isCorrect = testRun.unitTest.assertEqual(node, undefined, path)
    } else {
        for (const property in test.expected) {
            let testResult
            const expected = test.expected[property]
            if (property === 'history') {
                testResult = checkHistory(expected, node.history, path)
            } else {
                testResult = checkProperty(expected, node[property], property, path)
            }
            isCorrect = isCorrect && testResult
        }
        if (!isCorrect) {
            console.log(JSON.stringify(node, null, 2))
            testRun.runAgain()
        }
    }
})

function testMessageTree () {
    testRun.run([
        'addmessage',
        'errorcases',
        'history',
        'timevalue',
        'time',
        'interval',
        'historyoverflow'
    ], __dirname)
}

testMessageTree()

async function testLargeTree () {
    testRun.unitTest.log('creating large tree, takes a while')
    const tree = burst(1000000)
    testRun.unitTest.log('transforming tree to JSON')
    const jsonTree = JSON.stringify(tree.getSection('', 6))
    testRun.unitTest.log('Length of tree: ' + jsonTree.length)
    // Check that the tree does not grow too large
    testRun.unitTest.assertTrue(jsonTree.length < 50000000)

    await tree.persist(__dirname, 'message')
    const newTree = new MessageTree(tree.options)
    newTree.readTreeFromPersistedFile(__dirname, 'message')
    testRun.unitTest.log('Deep equal compare of loaded tree, takes a while')
    testRun.unitTest.assertDeepEqual(tree, newTree, 'persist ok')
    testRun.unitTest.showResult(255)
}

testLargeTree()
