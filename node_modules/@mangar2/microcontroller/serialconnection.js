/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const SerialPort = require('serialport')
const errorLog = require('@mangar2/errorlog')
const Callbacks = require('@mangar2/callbacks')
const CheckInput = require('@mangar2/checkinput')
const sanitize = require('@mangar2/configuration')

/**
 * @private
 * Check configuration input
 */
const checkConfig = new CheckInput({
    type: 'object',
    properties: {
        serialPort: { type: 'string', maxLength: 50 },
        baudRate: { type: 'number', maximum: 2000000 },
        keepAliveMessage: { type: 'string', maxLength: 50 },
        keepAliveInMilliseconds: { type: 'number', minumum: 0, maximum: 24 * 3600 * 1000 }
    },
    required: ['serialPort', 'baudRate', 'keepAliveMessage', 'keepAliveInMilliseconds']
})

/**
 * @private
 * Default configuration values
 */
const defaultValues = {
    keepAliveMessage: 'at',
    keepAliveInMilliseconds: 60 * 1000
}

/**
 * Communicates with a microcontroller of serial funtions
 * @param {Object} configuration configuration options
 * @param {string} configuration.serialPort name/id of the serial port (os specific)
 * @param {number} configuration.baudRate baud rate of the serial port
 * @param {string} [configuration.keepAliveMessage='at'] message to send to the serial port to signal "alive"
 * @throws {Error} if the configuration does not match the requirements
 */
class SerialConnection {
    constructor (configuration) {
        sanitize(configuration, defaultValues, checkConfig)
        this._openSerialPort()
        this._data = ''
        this._callbacks = new Callbacks(['open', 'data'])

        this._serialPort.on('open', () => {
            this._isOpenHandler(configuration.serialPortName)
        })
    }

    /**
     * Sets a callback.
     * @param {string} event event name (not case sensitive) for the callback; supported 'open', 'data'
     * @param {function} callback(parameter)
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on (event, callback) {
        this._callbacks.on(event, callback)
    }

    /**
     * @private
     * parses received data
     * @returns {Object} object extracted from the received data
     */
    _parseData () {
        let start = 0
        let closingBracket
        let receivedObject

        for (let index = 0; index < this._data.length; index++) {
            const curChar = this._data.charAt(index)
            if (curChar === '[') {
                start = index
                closingBracket = ']'
            } else if (curChar === '{') {
                start = index
                closingBracket = '}'
            } else if (curChar === closingBracket) {
                const substring = this._data.substr(start, index + 1 - start)
                this._data = this._data.substr(index + 1)
                try {
                    receivedObject = JSON.parse(substring)
                    break
                } catch (err) {
                    receivedObject = undefined
                    errorLog(err)
                }
            }
        }
        return receivedObject
    }

    /**
     * @private
     * Reads serial data, transforms it to objects and calls the "data" callback with the objects
     * @param {string} stream stream containing the data
     */
    _processData (stream) {
        this._data += stream.toString()
        let receivedObject = this._getObjectFromData()
        while (receivedObject !== undefined) {
            if (this.onFunctions.data !== undefined) {
                this.onFunctions.data(receivedObject)
            }
            receivedObject = this._getObjectFromData()
        }
    }

    /**
     * @private
     * Sends keep alive messages to the serial port
     */
    _sendKeepAlive () {
        const message = this.configuration.keepAliveMessage
        for (const c of message) {
            this._serialPort.write(c)
        }
    }

    /**
     * @private
     * called, once the serial port is open
     */
    _isOpenHandler () {
        console.log('Serial Port ' + this.configuration.serialPortName + ' opened')

        this._serialPort.on('close', function () {
            console.log('Serial port closed')
        })

        this._serialPort.on('error', function (err) {
            errorLog('Serial port error ' + err)
        })

        setInterval(() => {
            this.sendKeepAlive()
        }, this.configuration.keepAliveInterval)

        this._serialPort.on('data', (stream) => {
            try {
                while (this.processData(stream)) {};
            } catch (err) {
                errorLog(err)
            }
        })
    }

    /**
     * @private
     * Lists details of all available ports to console for debugging
     */
    listSerialPorts () {
        SerialPort.list((err, ports) => {
            if (err) {
                errorLog(err)
            }
            ports.forEach((port) => {
                console.log(port.comName)
                console.log(' - pnpId: ' + port.pnpId)
                console.log(' - manufacturer: ' + port.manufacturer)
                console.log(' - serialNumber: ' + port.serialNumber)
                console.log(' - vendorId: ' + port.vendorId)
                console.log(' - productId: ' + port.productId)
            })
        })
    }

    /**
     * @private
     * Opens the serial port
     */
    _openSerialPort () {
        const { serialPortName, baudRate } = this.configuration
        this._serialPort = new SerialPort(serialPortName, { baudRate: baudRate }, (err) => {
            if (err) {
                errorLog('Error: ', err.message)
                this.listSerialPorts()
            }
        })
    }

    /**
     * Sends data over the serial port
     * @param {string} data command string to send to the serial port
     */
    send (data) {
        this._serialPort.write(data, (err) => {
            if (err) {
                errorLog('Error while sending message : ' + err)
            }
        })
    }

    /**
     * Closes the serial connection
     */
    async close () {

    }
}

module.exports = SerialConnection
