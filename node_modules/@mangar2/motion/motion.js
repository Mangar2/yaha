/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */
'use strict'

const MotionHistory = require('./motionhistory')
const CheckInput = require('@mangar2/checkinput')
const Rules = require('@mangar2/rules')

const checkRule = new CheckInput({
    type: 'object',
    properties: {
        name: { type: 'string' },
        current: { type: 'string' },
        durationWithoutMovementInMinutes: { type: 'number' },
        require: {
            type: 'array',
            items: { type: 'string' }
        },
        allow: {
            type: 'array',
            items: { type: 'string' }
        },
        deny: {
            type: 'array',
            items: { type: 'string' }
        },
        topic: {
            anyOf: [
                { type: 'string' },
                {
                    type: 'array',
                    items: { type: 'string' }
                }
            ]
        },
        value: {
            anyOf: [
                { type: 'string' },
                { type: 'number' }
            ]
        },
        time: { type: 'string' },
        duration: { type: 'number' }
    },
    required: ['current', 'durationWithoutMovementInMinutes', 'topic', 'value'],
    strict: true

})


function timeOfDayHHMM (date) {
    return date.getHours().toString().padStart(2, '0') + ':' +
        date.getMinutes().toString().padStart(2, '0')
}

/**
 * Checks if the weekday of date is in the weekday array
 * @param {Date} date date to check
 * @param {Array} weekDays array of weekdays as string ("sunday", "monday", "tuesday", ...)
 * @returns {boolean} true, if the week day of date is in the weekday array
 */
function isMatchingWeekday (date, weekDays) {
    const weekdayArray = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday']
    const weekday = weekdayArray[date.getDay()]
    const result = weekDays.find(element => {
        return element === weekday
    })
    return result !== undefined
}

class Motion {
    constructor () {
        this._history = new MotionHistory()
    }

    /**
     *
     * @param {object} roomSetting json formatted string containing settings for rooms
     * @param {object} timeSetting time exception settings where movement is ignored
     */
    setConfiguration (roomSetting, timeSetting) {
        this.roomSetting = roomSetting
        this.timeSetting = timeSetting
    }

    /**
     * Checks if a timestamp must be ignored due to a rule
     * @param {timestamp} timestamp timestamp to check
     * @returns {boolean} true, if the timestamp must be ignored
     */
    isIgnoreTimestamp (timestamp) {
        const date = new Date(timestamp)
        const timeOfDay = timeOfDayHHMM(date)
        let ignore = false
        for (const timeRuleName in this.timeSetting) {
            const timeRule = this.timeSetting[timeRuleName]
            if (timeRule.type === 'ignore') {
                const isInTimespan = timeOfDay >= timeRule.time.start && timeOfDay <= timeRule.time.stop
                if (isInTimespan && isMatchingWeekday(date, timeRule.weekdays)) {
                    ignore = true
                    break
                }
            }
        }
        return ignore
    }

    /**
     * Checks, if a motion list matches the matchList
     * @param {object} motionList list of rooms with motion
     * @param {object} matchList list to check, if it matches the required list
     * @returns {boolean} true, if the room lists matches the match list
     */
    isMatchingRoomList (motionList, matchList) {
        let allMotionsInAllowedRooms = true
        let allRequiredRoomsIncluded = true
        let noDeniedRoomIncluded = true
        let anyDenyFound = false

        for (const roomName in matchList) {
            const required = matchList[roomName] === 'require'
            const deny = matchList[roomName] === 'deny'
            anyDenyFound = anyDenyFound || deny
            if (required && motionList[roomName] === undefined) {
                allRequiredRoomsIncluded = false
            }
            if (deny && motionList[roomName] !== undefined) {
                noDeniedRoomIncluded = false
            }
        }

        if (!anyDenyFound) {
            // if no rooms are denied, every non mentionned room is denied
            for (const roomName in motionList) {
                if (matchList[roomName] === undefined) {
                    allMotionsInAllowedRooms = false
                }
            }
        }

        return allMotionsInAllowedRooms && allRequiredRoomsIncluded && noDeniedRoomIncluded
    }

    /**
     * Checks, if the room motions signals an activating state (having recent moves) defined by a state match list
     * @param {Date} now current time, passed as parameter to support unit tests
     * @param {object} stateMatchList list of allowed, denied or required rooms to signal a state
     * @returns {boolean} true, if the current room motions signaling a state
     */
    isActivatingState (now, stateMatchList) {
        let result = false
        const latestMovementRoomList = this.roomList.getLatestMovementRoomList()
        if (this.isMatchingRoomList(latestMovementRoomList, stateMatchList)) {
            const anyRoomName = Object.keys(latestMovementRoomList)[0]
            const anyRoom = latestMovementRoomList[anyRoomName]
            const recentMove = anyRoom.lastMotion + RECENT_MOVE > now
            result = recentMove
        }
        return result
    }

    /**
     * Gets an array of strings for rooms with moves
     * @returns array list of strings with room names
     */
    getLatestMovementRoomList () {
        return this.roomList.getLatestMovementRoomList()
    }

    /**
     * Checks, if the room motions signals a deactivating state (not having moves for a long time) defined by a state match list
     * @param {Date} now current time, passed as parameter to support unit tests
     * @param {object} stateMatchList list of allowed, denied or required rooms to signal a state
     * @returns {boolean} true, if the current room motions signaling a state
     */
    isDeactivatingState (now, stateMatchList) {
        let result = false
        const latestMovementRoomList = this.getLatestMovementRoomList()
        if (this.isMatchingRoomList(latestMovementRoomList, stateMatchList)) {
            const anyRoomName = Object.keys(latestMovementRoomList)[0]
            const anyRoom = latestMovementRoomList[anyRoomName]
            const noMoveForLongTime = anyRoom.lastMotion + LONG_TIME < now
            result = noMoveForLongTime
        }
        return result
    }

    /**
     * Checks if we are sleeping. Logic: we are sleeping, if no move has been
     * detected for a long time and the floor adjacent to the sleeping room
     * was in the recent moves list
     * @param {Date} now current time, passed as parameter to support unit tests
     * @returns {boolean} true, if sleeping is detected
     */

    isSleeping (now) {
        const result = this.isDeactivatingState(now, this.roomSetting.sleeping)
        return result
    }

    /**
     * Checks if we are awake. Logic: we are awake, if a move has been detected
     * and the bathroom is not in the recent moves list.
     * @param {Date} now current time, passed as parameter to support unit tests
     * @returns {boolean} true, if awake is detected
     */
    isAwake (now) {
        const result = this.isActivatingState(now, this.roomSetting.awake)
        return result
    }

    /**
     * Checks if we are coming home. Logic: we are coming home, if a move has been detected
     * in the entry area.
     * @param {Date} now current time, passed as parameter to support unit tests
     * @returns {boolean} true, if homecoming is detected
     */
    isHomecoming (now) {
        const result = this.isActivatingState(now, this.roomSetting.homecoming)
        return result
    }

    /**
     * Checks if we are absent. Logic: we are absent, if no move has been found for
     * a long time and the last moves where in the wardrobe and in the ground floor
     * @param {Date} now current time, passed as parameter to support unit tests
     * @returns {boolean} true, if absent is detected
     */
    isAbsent (now) {
        const result = this.isDeactivatingState(now, this.roomSetting.absent)
        return result
    }

    /**
     * Checks for a state change
     * @param {Date} now current time, passed as parameter to support unit tests
     * @returns {boolean} true, if state has been changed
     */
    checkStateChange (now) {
        let stateChange = false
        switch (this.state) {
        case 'awake':
            if (this.isSleeping(now)) {
                this.state = 'sleeping'
                stateChange = true
            } else if (this.isAbsent(now)) {
                this.state = 'absent'
                stateChange = true
            }
            break
        case 'sleeping':
            if (this.isAwake(now)) {
                this.state = 'awake'
                stateChange = true
            }
            break
        case 'absent':
            if (this.isHomecoming(now)) {
                this.state = 'awake'
                stateChange = true
            }
            break
        }
        return stateChange
    }
}

module.exports = new Motion()
