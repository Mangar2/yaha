/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */
'use strict'

const DEBUG = false

const MotionHistory = require('./motionhistory')
const CheckInput = require('@mangar2/checkinput')
const TopicMatch = require('@mangar2/topicmatch')
const { Rules, ProcessRule } = require('@mangar2/rules')
const types = require('@mangar2/types')

const errorLog = (err) => { require('@mangar2/errorlog')(err, DEBUG) }

const checkRule = new CheckInput({
    type: 'object',
    properties: {
        name: { type: 'string' },
        durationWithoutMovementInMinutes: { type: 'number' },
        require: {
            type: 'array',
            minItems: 1,
            items: { type: 'string' }
        },
        allow: {
            type: 'array',
            minItems: 1,
            items: { type: 'string' }
        },
        deny: {
            type: 'array',
            minItems: 1,
            items: { type: 'string' }
        },
        topic: {
            type: ['string', 'array'],
            minItems: 1,
            items: { type: 'string' }
        },
        check: {
            type: ['number', 'string', 'array'],
            minItems: 2,
            maxItems: 3,
            anyOf: [
                {
                    items: [
                        {
                            enum: [
                                'and', 'or',
                                '=', 'equal', 'equals',
                                '!=', 'not equal', 'not equals',
                                '<', 'below', 'less',
                                '>', 'above', 'greater',
                                '<=', 'below or equal', 'less or equal',
                                '>=', 'above or equal', 'greater or equal'
                            ]
                        }
                    ],
                    additionalItems: { $ref: '#/properties/check' }
                },
                {
                    items: [
                        {
                            enum: ['switch']
                        },
                        {
                            $ref: '#/properties/check'
                        },
                        {
                            type: 'object',
                            additionalProperties: { type: ['string', 'number', 'boolean'] }
                        }
                    ]
                },
                {
                    items: [
                        {
                            enum: ['call']
                        },
                        {
                            type: 'string'
                        }
                    ]
                }
            ]
        },
        value: {
            oneOf: [
                {
                    type: ['string', 'number']
                },
                {
                    $ref: '#/check'
                }
            ]
        },
        time: {
            oneOf: [
                {
                    type: 'string'
                },
                {
                    $ref: '#/check'
                }
            ]
        },
        duration: { type: ['number', 'string'] }
    },
    required: ['topic', 'value'],
    additionalProperties: false

})

const checkConfiguration = new CheckInput({
    type: 'object',
    properties: {
        motionTopics: { type: 'array', items: { type: 'string' } },
        rules: { type: ['string', 'object'] },
        additionalProperties: false
    },
    required: ['motionTopics']
})

/**
 * @param {Object} rulesTree tree with 'rules' elements
 * @param {Object} options
 * @param {Array} [options.motionTopics] list of topics to subscribe to see all motions
 */
class Motion {
    constructor (rulesTree, options) {
        if (!types.isArray(options.motionTopics)) {
            options.motionTopics = ['+/+/+/motion sensor/detection state']
        }
        checkConfiguration.throwOnValidationError(options, 'Configuration error:')
        this._motionTopics = options.motionTopics
        this._history = new MotionHistory()
        this._rules = new Rules(rulesTree, checkRule)
        this._processRule = new ProcessRule()
    }

    /**
     * Sets a single variable (for example from a message)
     * @param {string} name name of the variable
     * @param {string|number} value value of the variable
     */
    _setVariable (name, value) { this._processRule.setVariable(name, value) }

    /**
     * Checks receives messages and adds them to motion and variable lists
     * @param {Message} message received message
     */
    processMessage (message) {
        const topicMatch = new TopicMatch(this._motionTopics)
        if (topicMatch.getFirstMatch(message.topic) !== undefined) {
            this._history.addMotion(message)
        }
        this._setVariable(message.topic, message.value)
    }

    /**
     * Get all the variables to subscribe to
     * @param {number} [QoS=1] quality of service
     * @returns {string[]} array of subscriptions
     */
    getSubscriptions (QoS = 1) {
        const variables = this.checkRules()
        const subscriptions = {}
        subscriptions[this._motionTopics] = QoS
        const topicMatch = new TopicMatch(this._motionTopics)
        for (const variable in variables) {
            const isNew = topicMatch.getFirstMatch(variable) === undefined
            if (variables[variable] === undefined && isNew) {
                subscriptions[variable] = QoS
            }
        }
        return subscriptions
    }

    /**
     * Checks all rules for errors, prints errors to console
     * @returns {Object} map of variables (variable name/variable value)
     */
    checkRules () {
        let result = {}
        if (this._rules.rules.length === 0) {
            errorLog('no valid rules')
        }
        for (const errors of this._rules.invalidRules) {
            console.log('Error in rule "' + errors.name + '": ' + JSON.stringify(errors.messages, null, 2))
        }
        for (const rule of this._rules.rules) {
            console.log('Checking rule ' + rule.name)
            try {
                const usedVariables = this._processRule.determineNeededVariables(rule)
                result = { ...result, ...usedVariables }
            } catch (err) {
                this._rules.invalidateRule(rule.name)
                err.message = 'Error in rule "' + rule.name + '": ' + err.message
                errorLog(err)
            }
        }
        return result
    }

    /**
     * Check that the latest move timestamp is long enough ago
     * @param {number} durationWithoutMovementInMinutes required amount of minutes passed since last move
     * @param {numer} latestMoveTimestamp timestamp of the last move in milliseconds
     * @param {Date} curDate current date
     * @returns {boolean} true, if the last move is long enough ago
     */
    _isLatestMoveLongEnoughAgo (durationWithoutMovementInMinutes, latestMoveTimestamp, curDate) {
        let result = true
        if (types.isNumber(durationWithoutMovementInMinutes)) {
            const noMoveTimespan = curDate.getTime() - latestMoveTimestamp
            const ONE_MINUTE = 60 * 1000
            result = noMoveTimespan > durationWithoutMovementInMinutes * ONE_MINUTE
        }
        return result
    }

    /**
     * Loops through all rules and processes them
     * @param {Date} [date] current date/time
     * @returns {Message[]} list of messages to process
     */
    processRules (date = new Date()) {
        const result = { messages: [], usedVariables: {} }
        this._processRule.date = date
        const recentMotion = this._history.getLatestMotionRoomList()
        for (const rule of this._rules.rules) {
            try {
                if (this._isLatestMoveLongEnoughAgo(rule.durationWithoutMovementInMinutes, recentMotion.timestamp, date)) {
                    const checkResult = this._processRule.check(rule, recentMotion.motions)
                    const messages = checkResult.messages
                    if (types.isArray(messages) && (messages.length > 0) && types.isObject(messages[0])) {
                        result.messages = [...result.messages, ...messages]
                    }
                }
            } catch (err) {
                this._rules.invalidateRule(rule.name)
                err.message = 'Error in rule "' + rule.name + '": ' + err.message
                errorLog(err)
            }
        }
        return result
    }
}

module.exports = Motion
