/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */
'use strict'

const DEBUG = false

const MotionHistory = require('./motionhistory')
const CheckInput = require('@mangar2/checkinput')
const { Rules, ProcessRule } = require('@mangar2/rules')
const types = require('@mangar2/types')

const errorLog = (err) => { require('@mangar2/errorlog')(err, DEBUG) }

const checkRule = new CheckInput({
    type: 'object',
    properties: {
        name: { type: 'string' },
        status: { type: 'string' },
        durationWithoutMovementInMinutes: { type: 'number' },
        require: {
            type: 'array',
            items: { type: 'string' }
        },
        allow: {
            type: 'array',
            items: { type: 'string' }
        },
        deny: {
            type: 'array',
            items: { type: 'string' }
        },
        topic: {
            anyOf: [
                { type: 'string' },
                {
                    type: 'array',
                    items: { type: 'string' }
                }
            ]
        },
        value: { type: ['string', 'number'] },
        time: { type: 'string' },
        duration: { type: ['number', 'string'] }
    },
    required: ['status', 'topic', 'value'],
    additionalProperties: true

})

class Motion {
    constructor (rulesTree) {
        this._history = new MotionHistory()
        this.rules = new Rules(rulesTree, checkRule)
        this._processRule = new ProcessRule()
    }

    /**
     * Gets the list of rules
     * @returns {Object[]} list of rules
     */
    get rules () { return this._rules }

    /**
     * Sets the list of rules
     * @param {Object[]} rules list of rules to process for automation
     */
    set rules (rules) { this._rules = rules }

    /**
     * Checks a message for motions and if a motion is included adds it to the motion list
     * @param {Message} message received message
     */
    addMotion (message) {
        this._history.addMotion(message)
    }

    /**
     * Checks all rules for errors
     * @returns {Object} map of variables (variable name/variable value)
     */
    checkRules () {
        let result = {}
        if (this._rules.rules.length === 0) {
            errorLog('no rules specified')
        }
        for (const errors of this._rules.invalidRules) {
            console.log('Error in rule "' + errors.name + '": ' + JSON.stringify(errors.messages, null, 2))
        }
        for (const rule of this._rules.rules) {
            console.log('Checking rule ' + rule.name)
            try {
                const usedVariables = this._processRule.neededVariables(rule)
                result = { ...result, ...usedVariables }
            } catch (err) {
                this._rules.invalidateRule(rule.name)
                err.message = 'Error in rule "' + rule.name + '": ' + err.message
                errorLog(err)
            }
        }
        return result
    }

    /**
     * Check that the latest move timestamp is long enough ago
     * @param {number} durationWithoutMovementInMinutes required amount of minutes passed since last move
     * @param {numer} latestMoveTimestamp timestamp of the last move in milliseconds
     * @param {Date} curDate current date
     * @returns {boolean} true, if the last move is long enough ago
     */
    _isLatestMoveLongEnoughAgo (durationWithoutMovementInMinutes, latestMoveTimestamp, curDate) {
        let result = true
        if (types.isNumber(durationWithoutMovementInMinutes)) {
            const noMoveTimespan = curDate.getTime() - latestMoveTimestamp
            const ONE_MINUTE = 60 * 1000
            result = noMoveTimespan > durationWithoutMovementInMinutes * ONE_MINUTE
        }
        return result
    }

    /**
     * Loops through all rules and processes them
     * @param {Date} [date] current date/time
     * @returns {Message[]} list of messages to process
     */
    processRules (date = new Date()) {
        const result = { messages: [], usedVariables: {} }
        this._processRule.date = date
        const recentMotion = this._history.getLatestMotionRoomList()
        for (const rule of this._rules.rules) {
            try {
                if (this._isLatestMoveLongEnoughAgo(rule.durationWithoutMovementInMinutes, recentMotion.timestamp, date)) {
                    const checkResult = this._processRule.check(rule, recentMotion.motions)
                    const messages = checkResult.messages
                    if (types.isArray(messages) && (messages.length > 0) && types.isObject(messages[0])) {
                        result.messages = [...result.messages, ...messages]
                    }
                }
            } catch (err) {
                this._rules.invalidateRule(rule.name)
                err.message = 'Error in rule "' + rule.name + '": ' + err.message
                errorLog(err)
            }
        }
        return result
    }
}

module.exports = Motion
