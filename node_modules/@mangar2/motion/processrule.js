/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const types = require('@mangar2/types')
const Message = require('@mangar2/message')
const { stringToSeconds, dateToTimeOfDayInSeconds } = require('@mangar2/time')

/**
 * Processes rules
 * @param {Date} [date=now] current date
 */
class ProcessRule {
    constructor (date = new Date()) {
        this.date = date
    }

    /**
     * Gets the current date/time
     * @returns {Date} current date/time
     */
    get date () { return this._date }

    /**
     * Sets the current date/time
     * @param {Date} date current date
     */
    set date (date) {
        this._date = date
    }

    /**
     * @private
     * Checks, if the rule has a time constrains. The rule is valid if
     * it has a time constrains defining a time span and the current time is in the time span or it
     * has no time constrains
     * @param {Object} rule rule to check
     * @param {string} [rule.time] time of day to activate the time
     * @param {string} [rule.duration='6:00'] duration of the rule
     * @returns {boolean} true, if the rule is currently valid based on the time of day stored
     */
    _checkTime (rule) {
        let result = rule.time === undefined
        const timeString = rule.time
        if (timeString !== undefined) {
            const durationString = rule.duration ? rule.duration : '6:00'
            const timeInSeconds = stringToSeconds(timeString)
            const durationInSeconds = stringToSeconds(durationString)
            const timeOfDayInSeconds = dateToTimeOfDayInSeconds(this._date)
            result = timeOfDayInSeconds >= timeInSeconds && timeOfDayInSeconds < durationInSeconds + timeInSeconds
        }

        return result
    }

    /**
     * @private
     * Checks, if the recentMotions map contains all required topics
     * @param {Array} required list of required topics
     * @param {Object} motions map (topic: timestamp) of recent topics
     */
    _isAllIncluded (required, motions) {
        let result = true
        for (const topic of required) {
            if (motions[topic] === undefined) {
                result = false
                break
            }
        }
        return result
    }

    /**
     * @private
     * Checks, if the recentMotions map contains any denied topics
     * @param {Array} denied list of denied topics
     * @param {Object} motions map (topic: timestamp) of recent topics
     */
    _isAnyIncluded (denied, motions) {
        let result = false
        for (const topic of denied) {
            if (motions[topic] === undefined) {
                result = true
                break
            }
        }
        return result
    }

    /**
     * @private
     * Checks, if the recentMotions map is a subset of the allowed topics
     * @param {Array} allow list of denied topics
     * @param {Object} motions map (topic: timestamp) of recent topics
     */
    _isSubset (allow, motions) {
        let result = true
        for (const topic in motions) {
            if (!allow.includes(topic)) {
                result = false
                break
            }
        }
        return result
    }

    /**
     * Processes a rule and if the rule demands, create a message
     * @param {Object} rule rule to check
     * @param {Object} recentMotions topic: timestamp object containing all recent motions
     * @throws {Error} on error in the decision rule
     * @returns {{messages: Message[], usedVariables}} Array of messages and object of variables used.
     */
    check (rule, recentMotions) {
        const result = { messages: [] }
        const motions = recentMotions.motions

        if (this._checkTime(rule, recentMotions)) {
            const { topic, name, value } = rule
            const reason = 'Rule: ' + name
            const require = Array.isArray(rule.require) ? rule.require : []
            const deny = Array.isArray(rule.deny) ? rule.deny : []
            const requireOk = this._isAllIncluded(require, motions)
            const denyOk = !this._isAnyIncluded(deny, motions)
            const allowOk = types.isArray(rule.allow) ? this._isSubset([...require, ...rule.allow], motions) : true

            if (requireOk && denyOk && allowOk) {
                if (types.isArray(topic)) {
                    for (const oneTopic of topic) {
                        result.messages.push(new Message(oneTopic, value, reason, this._date))
                    }
                } else {
                    result.messages.push(new Message(topic, value, reason, this._date))
                }
            }
        }
        return result
    }
}

module.exports = ProcessRule
