/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const types = require('@mangar2/types')
const Message = require('@mangar2/message')
const { stringToSeconds } = require('./timeHelper')

/**
 * Processes rules
 * @param {Date} [date=now] current date
 */
class ProcessRule {
    constructor (date = new Date()) {
        this.date = date
    }

    /**
     * Gets the current date/time
     * @returns {Date} current date/time
     */
    get date () { return this._date }

    /**
     * Sets the current date/time
     * @param {Date} date current date
     */
    set date (date) {
        this._date = date
    }

    /**
     * @private
     * Checks, if the rule has a time constrains. The rule is valid if
     * it has a time constrains defining a time span and the current time is in the time span or it
     * has no time constrains
     * @param {Object} rule rule to check
     * @param {string} [rule.time] time of day to activate the time
     * @param {string} [rule.duration='6:00'] duration of the rule
     * @returns {boolean} true, if the rule is currently valid based on the time of day stored
     */
    _checkTime (rule) {
        let result = rule.time === undefined
        const timeString = this._getPropertyValue(rule.time)
        if (timeString !== undefined) {
            const durationString = this._getPropertyValue(rule.duration, '6:00')
            const timeInSeconds = stringToSeconds(timeString)
            const durationInSeconds = stringToSeconds(durationString)
            const timeOfDayInSeconds = (this._date.getHours() * 60 + this._date.getMinutes()) * 60 + this._date.getSeconds()
            result = timeOfDayInSeconds >= timeInSeconds && timeOfDayInSeconds < durationInSeconds + timeInSeconds
        }

        return result
    }

    /**
     * @private
     * Checks, if the recentMotions map contains all required topics
     * @param {Array} required list of required topics
     * @param {Object} recentMotions map (topic: timestamp) of recent topics
     */
    _isAllIncluded (required, recentMotions) {
        let result = true
        for (const topic of required) {
            if (recentMotions[topic] === undefined) {
                result = false
                break
            }
        }
        return result
    }

    /**
     * @private
     * Checks, if the recentMotions map contains any denied topics
     * @param {Array} denied list of denied topics
     * @param {Object} recentMotions map (topic: timestamp) of recent topics
     */
    _isAnyIncluded (denied, recentMotions) {
        let result = false
        for (const topic of denied) {
            if (recentMotions[topic] === undefined) {
                result = true
                break
            }
        }
        return result
    }

    /**
     * @private
     * Checks, if the recentMotions map is a subset of the allowed topics
     * @param {Array} allow list of denied topics
     * @param {Object} recentMotions map (topic: timestamp) of recent topics
     */
    _isSubset (allow, recentMotions) {
        let result = true
        for (const topic in recentMotions) {
            if (allow[topic] === undefined) {
                result = false
                break
            }
        }
        return result
    }

    /**
     * Processes a rule and if the rule demands, create a message
     * @param {Object} rule rule to check
     * @param {Object} recentMotions topic: timestamp object containing all recent motions
     * @throws {Error} on error in the decision rule
     * @returns {{messages: Message[], usedVariables}} Array of messages and object of variables used.
     */
    check (rule, recentMotions) {
        const result = { messages: [] }

        if (this._checkTime(rule, recentMotions)) {
            const { topic, name, value } = rule
            const reason = 'Rule: ' + name
            const required = Array.isArray(rule.required) ? rule.required : []
            const denied = Array.isArray(rule.denied) ? rule.denied : []
            const requireOk = this._isAllIncluded(required, recentMotions)
            const denyOk = !this._isAnyIncluded(denied, recentMotions)
            const allowedOk = types.isArray(rule.allow) ? this._isSubset([...require, ...rule.allow], recentMotions) : true

            if (requireOk && denyOk && allowedOk) {
                if (types.isArray(topic)) {
                    for (const oneTopic of topic) {
                        result.messages.push(new Message(oneTopic, value, reason, this._date))
                    }
                } else {
                    result.messages.push(new Message(topic, value, reason, this._date))
                }
            }
        }
        return result
    }
}

module.exports = ProcessRule
