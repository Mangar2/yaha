/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */
'use strict'

const ONE_SECOND = 1000
const ROOM_EMPTY = 10 * 60 * 1000

function timeOfDay (Date) {
    return Date.getHours().toString().padStart(2, '0') + ':' +
        Date.getMinutes().toString().padStart(2, '0') + ':' +
        Date.getSeconds().toString().padStart(2, '0')
}

function getDayInfo (date) {
    let result = ''
    const dayBegin = new Date()
    dayBegin.setHours(0, 0, 0, 0)
    const yesterdayBegin = new Date(dayBegin)
    yesterdayBegin.setDate(dayBegin.getDate() - 1)
    if (date >= dayBegin) {
        result = 'today'
    } else if (date >= yesterdayBegin) {
        result = 'yesterday'
    } else {
        result = date.toLocaleDateString()
    }
    return result
}

/**
 * Constructs a new room list object holding motion information for rooms
 */
class RoomList {
    constructor () {
        this.rooms = {}
    }

    /**
     * Prints the roomlist to console
     */
    show () {
        for (const roomName in this.rooms) {
            const room = this.getRoom(roomName)
            const lastMotion = new Date(room.lastMotion)
            console.log('\x1b[32m%s: \x1b[0m %s %s (%s)', roomName.padEnd(20), getDayInfo(lastMotion), timeOfDay(lastMotion), room.roomType)
        }
    }

    /**
     * Gets the time difference of the room time and a given time
     * @param {string} roomName name of the room
     * @param {timestamp} timestamp time to compare
     * @returns {timestamp} time difference between given time and last room motion time
     */
    getRoomMotionTimeDifferenceInMilliseconds (roomName, timestamp) {
        let roomDelta = 0
        if (this.rooms[roomName] !== undefined) {
            roomDelta = timestamp - this.getRoomMotionTime(roomName)
        }
        return roomDelta
    }

    /**
     * Checks, if a new motion signals entering a room
     * @param {string} roomName name of the room
     * @param {timestamp} timestamp time to compare
     * @returns {boolean}
     */
    isEnteringRoom (roomName, timestamp) {
        let result = true
        if (this.rooms[roomName] !== undefined) {
            result = this.getRoomDelta(roomName, timestamp) > ROOM_EMPTY
        }
        return result
    }

    /**
     * Sets the time of last motion of a room
     * @param {string} roomName name of the room
     * @param {timestamp} timestamp time of the motion
     */
    setRoomMotionTime (roomName, timestamp) {
        if (this.rooms[roomName] === undefined) {
            this.rooms[roomName] = {
                lastMotion: timestamp,
                roomType: 'room'
            }
        } else {
            this.rooms[roomName].lastMotion = timestamp
        }
    }

    /**
     * Gets the time of last motion of a room
     * @param {string} roomName name of the room
     * @returns {timestamp} time of last motion
     */
    getRoomMotionTime (roomName) {
        return this.rooms[roomName].lastMotion
    }

    /**
     * Adds a motion information to the rooms
     * @param {string} roomName name of the room
     * @param {timestamp} time of motion
     * @param {boolean} versatile if true, the motion is printed to console
     */
    addMotion (roomName, timestamp, versatile) {
        this.setRoomMotionTime(roomName, timestamp)
        if (versatile) {
            const date = new Date(timestamp)
            console.log('\x1b[32m%s: \x1b[0m %s %s (%s)', roomName.padEnd(20), getDayInfo(date), timeOfDay(date))
        }
    }

    /**
     * Gets the infos stored to a room
     * @param {string} roomName name of the room
     */
    getRoom (roomName) {
        return this.rooms[roomName]
    }

    /**
     * Iterates through all rooms
     * @param {function} callback(roomName, room)
     */
    loop (callback) {
        for (const roomName in this.rooms) {
            callback(roomName, this.getRoom(roomName))
        }
    }

    /**
     * gets the room with the latest motion
     * @returns {string} name of the room with the latest motion
     */
    getLatestMotionRoomName () {
        let latestMotion = 0
        let resultRoomName
        this.loop((roomName, room) => {
            if (room.lastMotion > latestMotion) {
                latestMotion = room.lastMotion
                resultRoomName = roomName
            }
        })
        return resultRoomName
    }

    /**
     * Gets a displaystring for the latest movement room list
     * @param {Object} latestMovementRoomList
     * @returns {string}
     */
    latestMovementRoomListToDisplayString (latestMovementRoolList) {
        let displayString = ''
        let separator = ''
        for (const roomName in latestMovementRoolList) {
            const latestRoomMotionAsLocalTimeString = (new Date(this.getRoomMotionTime(roomName))).toLocaleTimeString()
            displayString = displayString + separator + roomName + ' ' + latestRoomMotionAsLocalTimeString
            separator = ', '
        }
        return displayString
    }

    /**
     * Gets a list of rooms with the latest (related) movement.
     * A movement is related, if it occurs in a small amount of time (like 5 sec.)
     * @param {number} [relatedMovementTimespanInSeconds=5] amount of seconds moves are "related"
     * @returns {Object} {displayString: display string with rooms and movement time, movements: list of rooms with the latest related movement}.
     */
    getLatestMovementRoomList (relatedMovementTimespanInSeconds = 5) {
        const relatedMovementTimespan = relatedMovementTimespanInSeconds * ONE_SECOND

        const relatedMovementRooms = {}
        const latestMotionRoomName = this.getLatestMotionRoomName()
        if (latestMotionRoomName !== undefined) {
            const latestMotion = this.getRoom(latestMotionRoomName).lastMotion
            this.loop((roomName, room) => {
                const isConcurrentMovement = room.lastMotion + relatedMovementTimespan > latestMotion
                if (isConcurrentMovement) {
                    relatedMovementRooms[roomName] = room
                }
            })
        }
        const latestMovementRooms = {
            displayString: this.latestMovementRoomListToDisplayString(relatedMovementRooms),
            movements: relatedMovementRooms
        }
        return latestMovementRooms
    }
}

module.exports = RoomList
