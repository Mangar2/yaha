/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * Provides a standard client to communicate with the mqtt broker
 */
import { IMessage, LogPattern, SubscribeResult, topics_t } from '@mangar2/mqtt-utils';
import { BrokerOptions } from '@mangar2/mqtt-client/src';
import { IMqttClient, receipientCallback_t, pollCallback_t } from '@mangar2/mqtt-client/src/client/imqtt-client';
/**
 * @typedef {Object} MqttClientOptions
 * @property {string} clientId unique id of the client
 * @property {BrokerOptions} broker information of the broker to connect to
 * @property {number} listener port this client will listen to
 * @property {string} [version='1.0'] interface version
 * @property {string} [keepAliveInSeconds] connection keep alive time in seconds
 * @property {boolean} [clean=true] clean the broker session on disconnect
 * @property {number} retry amount of retries to send messages to the broker
 * @property {LogPattern[]} log logging settings
 */
export interface MqttClientOptions {
    clientId: string;
    brokerOptions: BrokerOptions;
    listener?: number;
    version?: '0.0' | '1.0';
    keepAliveInSeconds?: number;
    clean?: boolean;
    logPattern?: LogPattern[];
}
export declare class MqttClient implements IMqttClient {
    private _server;
    private _client;
    private _brokerOptions;
    private _clientId;
    private _clean;
    private _connected;
    private _version;
    private _isShuttingDown;
    private _token;
    private _callbacks;
    private _closeChain;
    private _recipients;
    private _keepAlive;
    private _logger;
    constructor(options: MqttClientOptions);
    /**
     * Connection status. true, iff connected
     * @type {boolean}
     */
    get connected(): boolean;
    set connected(connected: boolean);
    get isShuttingDown(): boolean;
    /**
     * Registers a callback for a specific event.
     * @param {string} event - The event name.
     * @param {ProcessMessage} callback - The callback to be invoked.
     */
    on(event: string, callback: () => void): void;
    /**
     * @private
     * @description
     * Sets shutdown status. shutdown is cleared in the contructor and
     * set in the shutdown function.
     * @param {boolean} [isShuttingDown=true] true, iff shutting down
     */
    signalShutdown(isShuttingDown?: boolean): void;
    /**
     * Registeres a recipient
     * @param {string} serviceName name of the subscribing service
     * @param {Object} subscriptions subscription entries of format {topic:qos, topic:qos, ...}
     * @param {function} callback function to send received messages to
     * @returns {Promise<SubscribeResult>} result of the subscription
     * @throws {Error} If subscriptions are not well formatted or callback is not a function
     */
    registerRecipient(serviceName: string, topics: topics_t, callback: receipientCallback_t): Promise<SubscribeResult>;
    /**
     * @private
     * @description
     * Regularly calls a function
     * @param {number} intervalInMilliseconds interval between calls in milliseconds
     * @param {funnction} callback function to call
     */
    private invokeCallback;
    /**
     * Registers a sender function that will be invoked periodically.
     *
     * @param intervalInMilliseconds - The interval in milliseconds at which the sender function will be invoked.
     * @param callback - The callback function that will be invoked to retrieve the messages to be sent.
     * @throws {Error} - If the callback parameter is not a function.
     */
    registerSender(intervalInMilliseconds: number, callback: pollCallback_t): Promise<void>;
    /**
     * Updates the subscriptions
     * @param {string} serviceName name of the subscribing service
     * @param {Object} subscriptions subscription entries of format {topic:qos, topic:qos, ...}
     * @throws {Error} If subscriptions are not well formatted
     * @returns {Promise<SubscribeResult>} result of the subscription
     */
    subscribe(serviceName: string, topics: topics_t): Promise<SubscribeResult>;
    /**
     * Publishes a message to the MQTT broker.
     * @param message - The message to be published.
     * @param serviceName - The name of the service.
     * @returns A promise that resolves to an array of strings representing the published message.
     */
    publish(message: IMessage, serviceName?: string): Promise<string[]>;
    /**
     * @private
     * @description
     * Initializes the callbaks for "on publish" and "shutdown"
     */
    _initCallbacks(): void;
    /**
     * Connects and subscribes to the broker
     */
    reconnect(): Promise<void>;
    /**
     * @private
     * @description
     * Ensures that the system stayes connected with the broker
     * @param {number} memoryUsageTicks number of loops between memory usage messages. No message is sent, if
     * this parameter is <= 0
     */
    _keepConnected(memoryUsageTicks: number): Promise<void>;
    /**
     * Starts the mqttclient. Opens the listener and connects to the broker
     * @param {number} [memoryUsageLoopNumber=10] number of ping-loops between memory usage messages. No message is sent, if
     * this parameter is <= 0. A ping-loop takes keepAliveInSeconds/3 seconds
     */
    run(memoryUsageLoopNumber?: number): Promise<void>;
    /**
     * closes the client by shutting down all services and loops
     */
    close(): Promise<void>;
    /**
     * Registers close functions. It will be called when the client close function is called
     * @param {function} closeFunction function to be called on close commands
     */
    registerCloseFunction(closeFunction: () => void): void;
}
