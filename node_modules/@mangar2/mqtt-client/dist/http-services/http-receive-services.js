"use strict";
/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview Provides functions to connect to the (http based) yaha mqtt broker
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpReceiveServices = void 0;
const utils_1 = require("@mangar2/utils");
const httpservice_1 = require("@mangar2/httpservice");
const on_publish_1 = require("@mangar2/mqtt-client/src/service/on-publish");
const on_connect_1 = require("@mangar2/mqtt-client/src/service/on-connect");
/**
 * Provides functions to receive data
 */
class HttpReceiveServices {
    /**
     * Creates a new http service
     * @param port the port on which the server listens
     */
    constructor(port, _logger, qos2PubrelTimeoutInSeconds = 7200) {
        this._logger = _logger;
        this._onConnect = null;
        this._httpServer = new httpservice_1.HttpServer(port);
        this._onPublish = new on_publish_1.OnPublish(_logger, qos2PubrelTimeoutInSeconds);
        this._registerPut();
    }
    /**
     * Enables handling of connect requests
     * @param mqttServer the mqtt server
     * @returns {void}
     */
    setMqttServer(mqttServer) {
        this._onConnect = new on_connect_1.OnConnect(mqttServer, this._logger);
        this._onPublish.on('publish', (message, dup) => { mqttServer.publish({ message, dup }); });
    }
    /**
     * Listen for incoming http requests, e.g. from the broker
     * Sets the port used by the server
     */
    listen() {
        this._httpServer.listen();
    }
    /**
     * Closes the server
     */
    close() {
        return this._httpServer.close();
    }
    /**
     * Registers the post method for the server
     * If the request is a publish request, the request is handled by the onPublish object
     * @private
     * @returns {void}
     */
    _registerPut() {
        this._httpServer.on('PUT', (payload, headers, path, res) => {
            try {
                if (this._onPublish !== null && this._onPublish.isPublishRequest(path)) {
                    const result = this._onPublish.handleRequest(path, headers, payload);
                    res.writeHead(result.statusCode, result.headers);
                    res.end(result.payload);
                }
                else if (this._onConnect !== null && this._onConnect.isConnectRequest(path)) {
                    const result = this._onConnect.handleHttpRequest(path, headers, payload);
                    res.writeHead(result.statusCode, result.headers);
                    res.end(result.payload);
                }
                else {
                    res.writeHead(404, { 'Content-Type': 'text/plain' });
                    res.end('Illegal interface ' + path);
                }
            }
            catch (error) {
                res.writeHead(500, { 'Content-Type': 'text/plain' });
                res.end(utils_1.Types.getType(error) === 'Error' ? error.message : 'Unknown error');
            }
        });
    }
    /**
     * Gets the port used by the server
     * It is valid only after the listen method has been called
     * @returns {number} the port used by the server
     */
    get port() {
        var _a;
        return ((_a = this._httpServer.address) === null || _a === void 0 ? void 0 : _a.port) || 0;
    }
    /**
     * Gets the onPublish object
     * @returns {OnPublish} the onPublish object, if enabled
     * @throws {Error} if onPublish is not enabled
     */
    get onPublish() {
        if (this._onPublish === null) {
            throw new Error('onPublish not enabled');
        }
        return this._onPublish;
    }
    /**
     * Gets the onConnect event handler.
     * @returns The onConnect event handler.
     * @throws Error if onConnect is not enabled.
     */
    get onConnect() {
        if (this._onConnect === null) {
            throw new Error('onConnect not enabled');
        }
        return this._onConnect;
    }
}
exports.HttpReceiveServices = HttpReceiveServices;
//# sourceMappingURL=http-receive-services.js.map