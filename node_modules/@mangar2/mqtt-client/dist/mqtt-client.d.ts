/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * Provides a standard client to communicate with the mqtt broker
 */
import { Message, LogPattern, SubscribeResult, topics_t } from '@mangar2/mqtt-utils';
import { BrokerOptions } from './index';
/**
 * @typedef {Object} MqttClientOptions
 * @property {string} clientId unique id of the client
 * @property {BrokerOptions} broker information of the broker to connect to
 * @property {number} listener port this client will listen to
 * @property {string} [version='1.0'] interface version
 * @property {string} [keepAliveInSeconds] connection keep alive time in seconds
 * @property {boolean} [clean=true] clean the broker session on disconnect
 * @property {number} retry amount of retries to send messages to the broker
 * @property {LogPattern[]} log logging settings
 */
export interface MqttClientOptions {
    clientId: string;
    brokerOptions: BrokerOptions;
    listener?: number;
    version?: '0.0' | '1.0';
    keepAliveInSeconds?: number;
    clean?: boolean;
    logPattern?: LogPattern[];
}
/**
 * Callback function type for handling received messages.
 * @param message The received message.
 * @returns The resulting message or messages.
 */
export type receipientCallback_t = (message: Message) => Message | Message[];
export declare class MqttClient {
    private _server;
    private _client;
    private _brokerOptions;
    private _clientId;
    private _clean;
    private _connected;
    private _version;
    private _isShuttingDown;
    private _token;
    private _callbacks;
    private _closeChain;
    private _recipients;
    private _keepAlive;
    private _logger;
    constructor(options: MqttClientOptions);
    /**
     * Connection status. true, iff connected
     * @type {boolean}
     */
    get connected(): boolean;
    set connected(connected: boolean);
    get isShuttingDown(): boolean;
    /**
     * Registers a callback for a specific event.
     * @param {string} event - The event name.
     * @param {ProcessMessage} callback - The callback to be invoked.
     */
    on(event: string, callback: () => void): void;
    /**
     * @private
     * @description
     * Sets shutdown status. shutdown is cleared in the contructor and
     * set in the shutdown function.
     * @param {boolean} [isShuttingDown=true] true, iff shutting down
     */
    signalShutdown(isShuttingDown?: boolean): void;
    /**
     * Registeres a recipient
     * @param {string} serviceName name of the subscribing service
     * @param {Object} subscriptions subscription entries of format {topic:qos, topic:qos, ...}
     * @param {function} callback function to send received messages to
     * @returns {Promise<SubscribeResult>} result of the subscription
     * @throws {Error} If subscriptions are not well formatted or callback is not a function
     */
    registerRecipient(serviceName: string, topics: topics_t, callback: receipientCallback_t): Promise<SubscribeResult>;
    /**
     * Updates the subscriptions
     * @param {string} serviceName name of the subscribing service
     * @param {Object} subscriptions subscription entries of format {topic:qos, topic:qos, ...}
     * @throws {Error} If subscriptions are not well formatted
     * @returns {Promise<SubscribeResult>} result of the subscription
     */
    subscribe(serviceName: string, topics: topics_t): Promise<SubscribeResult>;
    /**
     * Publishes a message to the broker
     * @param {Message} message message to publish
     * @param {number} message.qos quality of service (0,1,2)
     * @param {boolean} message.retain true to create a retain message
     */
    publish(message: Message): Promise<string[]>;
    /**
     * @private
     * @description
     * Initializes the callbaks for "on publish" and "shutdown"
     */
    _initCallbacks(): void;
    /**
     * Connects and subscribes to the broker
     */
    reconnect(): Promise<void>;
    /**
     * @private
     * @description
     * Ensures that the system stayes connected with the broker
     * @param {number} memoryUsageTicks number of loops between memory usage messages. No message is sent, if
     * this parameter is <= 0
     */
    _keepConnected(memoryUsageTicks: number): Promise<void>;
    /**
     * Starts the mqttclient. Opens the listener and connects to the broker
     * @param {number} [memoryUsageLoopNumber=10] number of ping-loops between memory usage messages. No message is sent, if
     * this parameter is <= 0. A ping-loop takes keepAliveInSeconds/3 seconds
     */
    run(memoryUsageLoopNumber?: number): Promise<void>;
    /**
     * closes the client by shutting down all services and loops
     */
    close(): Promise<void>;
    /**
     * Registers close functions. It will be called when the client close function is called
     * @param {function} closeFunction function to be called on close commands
     */
    registerCloseFunction(closeFunction: () => void): void;
}
