"use strict";
/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * Provides a standard client to communicate with the mqtt broker
 */
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@mangar2/utils");
const index_1 = require("./index");
const DEBUG = true;
const errorLog = (error) => { (0, utils_1.errorLog)(error, DEBUG); };
;
class MqttClient {
    constructor(options) {
        this._isShuttingDown = false;
        if (options === undefined) {
            throw Error('MqttClient constructor needs a valid options object; Provided: undefined');
        }
        const { clientId, brokerOptions, listener, logPattern, clean } = options;
        this._server = new index_1.HttpReceiveServices(listener, logPattern);
        this._client = new index_1.HttpSendServices(clientId, brokerOptions);
        this._brokerOptions = brokerOptions;
        this._clientId = clientId;
        this._clean = clean || true;
        this._connected = false;
        this._version = options.version || '1.0';
        this._token = { send: '', receive: '' };
        this._closeChain = [];
        this._recipients = {};
        this._sender = [];
        this._isShuttingDown = false;
        this.connected = false;
        if (!isNaN(options.keepAliveInSeconds)) {
            this._keepAlive = options.keepAliveInSeconds * 1000;
        }
        this._callbacks = new utils_1.Callbacks('shutdown');
        this._initCallbacks();
    }
    /**
     * Connection status. true, iff connected
     * @type {boolean}
     */
    get connected() { return this._connected; }
    set connected(connected) { this._connected = connected; }
    get isShuttingDown() {
        // Add your implementation here
        return this._isShuttingDown;
    }
    /**
     * Connects and subscribes to the broker
     */
    async reconnect() {
        try {
            const result = await this._client.connect.connect({
                version: this._version,
                clean: this._clean,
                host: this._brokerOptions.host,
                port: this._brokerOptions.port,
            });
            this.connected = true;
            this._token = result.token;
            for (const key in this._recipients) {
                const recipient = this._recipients[key];
                const subscriptions = recipient.subscriptions;
                const subscribe = await this._client.connect.subscribe(this._version, subscriptions);
                const errorPosition = subscribe.qos ? subscribe.qos.indexOf(127) : -1;
                if (errorPosition > -1) {
                    throw 'subscribe failed at postion: ' + errorPosition;
                }
            }
        }
        catch (error) {
            this.connected = false;
            errorLog(error);
        }
    }
    /**
     * Starts the mqttclient. Opens the listener and connects to the broker
     * @param {number} [memoryUsageLoopNumber=10] number of ping-loops between memory usage messages. No message is sent, if
     * this parameter is <= 0. A ping-loop takes keepAliveInSeconds/3 seconds
     */
    async run(memoryUsageLoopNumber = 10) {
        if (!this.isShuttingDown) {
            try {
                this._server.listen();
                await this.reconnect();
                this._keepConnected(memoryUsageLoopNumber);
            }
            catch (error) {
                errorLog(error);
            }
        }
    }
}
//# sourceMappingURL=mqttclient.js.map