"use strict";
/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * Provides a standard client to communicate with the mqtt broker
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MqttClient = void 0;
const utils_1 = require("@mangar2/utils");
const mqtt_utils_1 = require("@mangar2/mqtt-utils");
const index_1 = require("./index");
const mqtt_utils_2 = require("@mangar2/mqtt-utils");
const DEBUG = true;
const errorLog = (error) => { (0, utils_1.errorLog)(error, DEBUG); };
;
class MqttClient {
    constructor(options) {
        this._isShuttingDown = false;
        this._recipients = {};
        this._logger = new mqtt_utils_2.Logger();
        if (options === undefined) {
            throw Error('MqttClient constructor needs a valid options object; Provided: undefined');
        }
        const { clientId, brokerOptions, listener, logPattern, clean } = options;
        this._logger.changePattern(logPattern);
        this._server = new index_1.HttpReceiveServices(listener, this._logger);
        this._client = new index_1.HttpSendServices(clientId, brokerOptions, this._logger);
        this._brokerOptions = brokerOptions;
        this._clientId = clientId;
        this._clean = clean || true;
        this._connected = false;
        this._version = options.version || '1.0';
        this._token = { send: '', receive: '' };
        this._closeChain = [];
        this._recipients = {};
        this._isShuttingDown = false;
        this.connected = false;
        this._keepAlive = 10 * 60 * 1000; // 10 minutes
        if (utils_1.Types.isNumber(options.keepAliveInSeconds)) {
            this._keepAlive = options.keepAliveInSeconds * 1000;
        }
        this._callbacks = new utils_1.Callbacks(['shutdown']);
        this._initCallbacks();
    }
    /**
     * Connection status. true, iff connected
     * @type {boolean}
     */
    get connected() { return this._connected; }
    set connected(connected) { this._connected = connected; }
    get isShuttingDown() {
        // Add your implementation here
        return this._isShuttingDown;
    }
    /**
     * @private
     * @description
     * Sets shutdown status. shutdown is cleared in the contructor and
     * set in the shutdown function.
     * @param {boolean} [isShuttingDown=true] true, iff shutting down
     */
    signalShutdown(isShuttingDown = true) { this._isShuttingDown = isShuttingDown; }
    /**
     * Updates the subscriptions
     * @param {string} serviceName name of the subscribing service
     * @param {Object} subscriptions subscription entries of format {topic:qos, topic:qos, ...}
     * @throws {Error} If subscriptions are not well formatted
     */
    async updateSubscriptions(serviceName, topics) {
        if (!this.isShuttingDown) {
            this._recipients[serviceName].topics = topics;
            if (this.connected) {
                await this._client.connect.subscribe(this._version, topics);
            }
        }
    }
    /**
     * Publishes a message to the broker
     * @param {Message} message message to publish
     * @param {number} message.qos quality of service (0,1,2)
     * @param {boolean} message.retain true to create a retain message
     */
    publish(message) {
        const token = this._token ? this._token.send : 'undefined';
        this._client.publish(token, message, this._version);
    }
    /**
     * @private
     * @description
     * Initializes the callbaks for "on publish" and "shutdown"
     */
    _initCallbacks() {
        this._server.onPublish.on('publish', async (message) => {
            for (const key in this._recipients) {
                const recipient = this._recipients[key];
                const topicMatch = new mqtt_utils_2.TopicMatch(recipient.topics);
                if (topicMatch.getFirstMatch(message.topic) !== undefined) {
                    const messageCopy = message.clone();
                    let returnMessage = await recipient.callback(messageCopy);
                    if (returnMessage instanceof mqtt_utils_1.Message) {
                        returnMessage = [returnMessage];
                    }
                    if (Array.isArray(returnMessage)) {
                        for (const entry of returnMessage) {
                            this.publish(entry);
                        }
                    }
                }
            }
        });
        (0, utils_1.shutdown)(async () => {
            await this.close();
        });
    }
    /**
     * Connects and subscribes to the broker
     */
    async reconnect() {
        try {
            const result = await this._client.connect.connect({
                version: this._version,
                clean: this._clean,
                clientId: this._clientId,
                host: this._brokerOptions.host,
                port: this._brokerOptions.port,
            });
            this.connected = true;
            this._token = result.token;
            for (const key in this._recipients) {
                const recipient = this._recipients[key];
                const subscribeResult = await this._client.connect.subscribe(this._version, recipient.topics);
                const errorPosition = subscribeResult ? subscribeResult.indexOf(127) : -1;
                if (errorPosition > -1) {
                    throw 'subscribe failed at postion: ' + errorPosition;
                }
            }
        }
        catch (error) {
            this.connected = false;
            errorLog(error);
        }
    }
    /**
     * @private
     * @description
     * Ensures that the system stayes connected with the broker
     * @param {number} memoryUsageTicks number of loops between memory usage messages. No message is sent, if
     * this parameter is <= 0
     */
    async _keepConnected(memoryUsageTicks) {
        let memoryUsageMessageCountdown = 0;
        while (!this.isShuttingDown) {
            try {
                if (this._version === '0.0' || !this.connected) {
                    this.reconnect();
                }
                else {
                    await this._client.connect.pingreq(this._token.send);
                }
                if (memoryUsageMessageCountdown <= 0) {
                    if (memoryUsageTicks > 0) {
                        this.publish((0, mqtt_utils_2.createMemoryUsageMessage)(this._clientId));
                    }
                    memoryUsageMessageCountdown = memoryUsageTicks;
                }
                memoryUsageMessageCountdown--;
            }
            catch (error) {
                this.connected = false;
                errorLog(error);
            }
            if (!this.connected) {
                await (0, utils_1.delay)(1000);
            }
            else {
                await (0, utils_1.delay)(this._keepAlive / 3);
            }
        }
    }
    /**
     * Starts the mqttclient. Opens the listener and connects to the broker
     * @param {number} [memoryUsageLoopNumber=10] number of ping-loops between memory usage messages. No message is sent, if
     * this parameter is <= 0. A ping-loop takes keepAliveInSeconds/3 seconds
     */
    async run(memoryUsageLoopNumber = 10) {
        if (!this.isShuttingDown) {
            try {
                this._server.listen();
                await this.reconnect();
                this._keepConnected(memoryUsageLoopNumber);
            }
            catch (error) {
                errorLog(error);
            }
        }
    }
    /**
     * closes the client by shutting down all services and loops
     */
    async close() {
        try {
            this.signalShutdown();
            await this._callbacks.invokeCallbackAsync('shutdown');
            await (0, utils_1.delay)(500);
            for (const closeFunction of this._closeChain) {
                await closeFunction();
            }
            await this._client.connect.disconnect(this._version);
        }
        catch (error) {
            errorLog(error);
        }
        await this._server.close();
    }
    /**
     * Registers close functions. It will be called when the client close function is called
     * @param {function} closeFunction function to be called on close commands
     */
    registerCloseFunction(closeFunction) {
        if (utils_1.Types.isAsyncFunction(closeFunction)) {
            this._closeChain.push(closeFunction);
        }
    }
}
exports.MqttClient = MqttClient;
//# sourceMappingURL=mqttclient.js.map