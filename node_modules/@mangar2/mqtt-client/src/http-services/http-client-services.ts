/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview Provides functionalities to communicate with an mqtt broker over http
 */

import { Logger, SubscribeResult, ConnectResult, topics_t, IMessage } from '@mangar2/mqtt-utils';

import { IMqttClientServices } from '../mqtt-service/imqtt-client-services';
import { HttpReceiveServices, HttpSendServices } from '../index';
import { BrokerOptions } from '../service/types';

export type version_t = '0.0' | '1.0';

/**
 * Represents the options for configuring an MQTT client.
 */
export type HttpClientOptions = {
    /**
     * The client ID used to identify the MQTT client.
     */
    clientId: string;
    /**
     * The options for configuring the MQTT broker.
     */
    brokerOptions: BrokerOptions;
    /**
     * The listener port number for the MQTT client.
     */
    listener?: number;
    /**
     * The version of the MQTT protocol to use.
     */
    version?: version_t;
}

export class HttpClient implements IMqttClientServices {

    private _server: HttpReceiveServices;
    private _client: HttpSendServices;

    constructor (private options: HttpClientOptions, private _logger: Logger) {
        
        const { clientId, brokerOptions, listener } = options;
        this._server = new HttpReceiveServices(listener || 0, this._logger);
        this._client = new HttpSendServices(clientId, brokerOptions, this._logger);
        
        this.options.version = this.options.version || '1.0';
    }

    supportsFeature(feature: string): boolean {
        if (feature === 'pingreq') {
            return this.options.version !== '0.0';
        } else if (feature in ['connect', 'disconnect', 'subscribe', 'publish']) {
            return true;
        } else {
            return false;
        }
    }

    async connect(clientId: string, clean: boolean, version?: string): Promise<ConnectResult> {
        // Connect sends the client's listening port to the broker
        const port = this._server.port;
        return this._client.connect.connect({ clientId, clean, version, port });
    }

    async disconnect(): Promise<void> {
        return this._client.connect.disconnect(this.options.version);
    }

    async subscribe(topics: topics_t): Promise<SubscribeResult> {
        return this._client.connect.subscribe(this.options.version, topics);
    }

    async  pingreq(token: string): Promise<void> {
        return this._client.connect.pingreq(token)
    }

    async publish(token: string, message: IMessage, serviceName: string): Promise<string[]> {
        return this._client.publish(token, message, serviceName, this.options.version);
    }   

    onPublish(callback: (message: IMessage) => void): void {
        this._server.onPublish.on('publish', callback);
    }

    start(): void {
        this._server.listen();
    }   

    close(): void {
        this._server.close();
    }

}