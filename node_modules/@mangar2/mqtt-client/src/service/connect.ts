/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview Provides functions to connect to the (http based) yaha mqtt broker
 */

import { Interfaces, ConnectResult, ConnectOptions, SubscribeResult, UnsubscribeResult, Logger, topics_t } from '@mangar2/mqtt-utils';
import { Callbacks, Types } from '@mangar2/utils';
import { headers_t } from '@mangar2/mqtt-client/src/service/types';
import os from 'os';

/**
 * @private
 * @description
 * Gets the IP v4 address of the current device
 * @returns {string} IP v4 address
 */
export function getIPv4Address(): string {
    const networkInterfaces = os.networkInterfaces();
    for (const network of Object.values(networkInterfaces)) {
        if (!network) continue;
        for (const info of network) {
            if (info.family === 'IPv4' && !info.internal) {
                return info.address;
            }
        }
    }
    return 'localhost';
}

/**
 * @callback ConnectMessage
 * @param message the message received
 * @param qos the quality of service information
 * @param dup flag signaling duplicates
 */
type ConnectMessage = (httpMethod: string, path: string, headers:headers_t, payload: string) => void;

/**
 * Organises connections to broker
 * This is part of the http based mqtt broker. Use this class to connect/disconnect and subscribe/unsubscribe to the broker
 * All functions are based on async/promises
 */
export class Connect {
    private nextPacketId: number = 0;
    private callbacks: Callbacks = new Callbacks(["send"]);

    /**
     * @param {string} _clientId id of this client
     * @param {Logger} _logger logger for debug information
     */
    constructor(private _clientId: string, private _logger: Logger | null = null) {
    }

    /**
     * Sets a callback.
     * @param {string} event event name (not case sensitive) for the callback
     * @param {function} callback(parameter)
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on(event: string, callback: ConnectMessage): void { this.callbacks.on(event, callback); }

    /**
     * @private
     * @description
     * Sends an object via put as application/json message
     * @param {string} path path for the http PUT
     * @param {Object} payload data to be transported via. PUT
     * @returns {Object} received answer
     */
    private async send(path: string, headers: headers_t, payload: any): Promise<any> {
        if (this._logger) {
            this._logger.log(this._clientId, `send${path}`, `${JSON.stringify(headers)} ${JSON.stringify(payload)}`);
        }
        return this.callbacks.invokeCallbackAsync('send', 'put', path, headers, payload);
    }

    /**
     * @private
     * @description
     * provides a new packet id
     * @returns {number} "nearly unique" packet id (between 0 .. 65536)
     */
    private providePacketId(): number {
        return this.nextPacketId = (this.nextPacketId % 0xFFFF) + 1;
    }

    /**
     * @private
     * @description
     * Extracts the error message from an error
     * @param {string|Error|any} err 
     * @returns {string} error message
     */
    private getMessage(err: string | Error | any): string {
        return Types.isString(err) ? err : Types.isError(err) ? err.message : 'unknown error';
    }

    /**
     * Connects to the broker
     * @param {IConnectOptions} options connection options
     * @returns {string} connection token
     */
    async connect(options: ConnectOptions): Promise<ConnectResult> {
        try {
            options.clientId = this._clientId;
            options.host = getIPv4Address();
            options.port = options.port || 0;
            const sendData = Interfaces.connect(options.version || '1.0', options);
            const result = await this.send('/connect', sendData.headers, sendData.payload);
            sendData.resultCheck(result);
            const { } = result;
            // resultCheck checked, that content type is application/json. So parsing should be ok.
            const parsedResult = JSON.parse(result.payload);
            const { present, token, mqttcode } = parsedResult;
            this._logger?.log(this._clientId, `$SYS/${this._clientId}/connect`, 
                `connected, present:${present}, send:${token.send}, receive:${token.receive}, mqttcode:${mqttcode}`, 
                this._clientId, 0);
            return parsedResult;
        } catch (err) {
            throw new Error(`Unable to connect: ${this.getMessage(err)}`)
        }
    }

    /**
     * Disconnects from the broker
     * @param {string} [version='1.0'] interface version (0.0 or 1.0)
     * @returns {Object} empty object
     */
    async disconnect(version: string = '1.0'): Promise<void> {
        try {
            const sendData = Interfaces.disconnect(version, this._clientId);
            const result = await this.send('/disconnect', sendData.headers, sendData.payload);
            sendData.resultCheck(result)
        } 
        catch (err) {
            throw new Error(`Unable to disconnect: ${this.getMessage(err)}`);
        }
    }

    /**
     * Subscribe to the broker
     * @param {Object} topics topics to subscribe to {topic1: QoS1, topic2: QoS2, ...}
     * @param {string} [version='1.0'] interface version (0.0 or 1.0)
     * @returns {Object} payload returned from subscribe request
     */
    async subscribe(version: string = '1.0', topics: topics_t): Promise<SubscribeResult> {
        try {
            const sendData = Interfaces.subscribe(version, topics, this._clientId, this.providePacketId());
            const result = await this.send('/subscribe', sendData.headers, sendData.payload);
            sendData.resultCheck(result)
            return JSON.parse(result.payload);
        } catch (err) {
            throw new Error(`Unable to subscribe: ${this.getMessage(err)}`);
        }
    }

    /**
     * Unsubscribes from the broker
     * @param {Array} topics topics to unsubscribe [topic1, topic2, ...]
     * @param {string} [version='1.0'] interface version (0.0 or 1.0)
     * @returns {Object} empty object
     */
    async unsubscribe(version: string = '1.0', topics: topics_t): Promise<UnsubscribeResult> {
        try {
            const sendData = Interfaces.unsubscribe(version, topics, this._clientId, this.providePacketId());
            const result = await this.send('/unsubscribe', sendData.headers, sendData.payload);
            sendData.resultCheck(result)
            return JSON.parse(result.payload);
        } catch (err) {
            throw new Error(`Unable to unsubscribe: ${this.getMessage(err)}`);
        }

    }

    /**
     * Sends a ping request to signal the client is alive
     * @returns {boolean} true on success
     */
    async pingreq(token: string): Promise<void> {
        try {
            const payload = { token };
            const headers = { 'content-type': 'application/json; charset=UTF-8' };
            const result = await this.send('/pingreq', headers, payload);
            if (result.statusCode !== 204) {
                throw new Error(`Illegal return code, expected 204 got ${result.statusCode}`);
            }
            if (result.headers.packet !== 'pingresp') {
                throw new Error(`Wrong packet id, expected \'pingresp\', got ${result.headers.packet}`);
            };
        } catch (err) {
            throw new Error(`Error in ping request: ${this.getMessage(err)}`);
        }
    }

    /**
     * First connect, then subscribe
     * @param {boolean} clean true, if a disconnect shall clean any connection information
     * @param {Object} topics topics to subscribe to {topic1: QoS1, topic2: QoS2, ...}
     * @param {string} [version='1.0'] interface version (0.0 or 1.0)
     * @param {number} [keepAlive=600000] time in milliseconds the broker will keep the connection without receiving calls
     * @returns {Object} combined result from connect and subscribe
     */
    async connectAndSubscribe(topics: topics_t, connectOptions: ConnectOptions): 
        Promise<{connectResult: ConnectResult, subscribeResult: SubscribeResult}> {
        const connectResult = await this.connect(connectOptions);
        const subscribeResult = await this.subscribe(connectOptions.version, topics);
        return { connectResult, subscribeResult };
    }

}


