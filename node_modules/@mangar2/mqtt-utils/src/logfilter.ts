/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview Filters logs by a topic string and prints them to console
 */

import  CheckInput from '@mangar2/checkinput';
import { TopicMatch } from './topic/topicmatch';
import { Message } from './message';  //Assuming there is a message class somewhere in your project

interface LogPattern {
    topic: string;
    module: string;
    level?: number;
}

/**
 * @class LogFilter
 * @description
 * Provides a simple filter for logging topic based messages.
 * @example
 * const logfilter = new LogFilter();
 * logfilter.changePattern([{ topic: 'input/%', module: 'receive', level: 1 }]);
 * logfilter.condLogMessage('receive', new Message('hello world', 1), 1);
 */
export class LogFilter {
    private moduleFilter: Record<string, TopicMatch>;
    private checkTopicList = new CheckInput({
        type: 'array',
        items: {
            type: 'object',
            properties: {
                topic: { type: 'string' },
                module: { type: 'string' },
                level: { type: 'number', minimum: 0 }
            },
            required: ['topic', 'module']
        }
    });

    constructor() {
        this.moduleFilter = {};
    }

    /**
     * Replaces the log filter patterns, deleting the current patterns and replace them with the new patterns.
     * @param {LogPattern[]} patternList
     * @throws {Error} If the parameter is badly formatted.
     */
    changePattern(patternList: LogPattern[]): void {
        this.moduleFilter = {};
        this.checkTopicList.throwOnValidationError(patternList, 'log filter error');
        for (const pattern in patternList) {
            const filter = patternList[pattern];
            const module = filter.module;
            const level = filter.level !== undefined ? filter.level : 0;
            if (this.moduleFilter[module] === undefined) {
                this.moduleFilter[module] = new TopicMatch();
            }
            this.moduleFilter[module].addPattern(filter.topic, level);
        }
    }

    /**
     * Gets the log level.
     * @param {string} module name of the module to check for.
     * @param {string} topic topic to check.
     * @returns {undefined | number} returns a log level or undefine, if logging is false.
     */
    getLogLevel(module: string, topic: string): number | undefined {
        let result: number | undefined;
        if (typeof this.moduleFilter[module] === 'object') {
            result = this.moduleFilter[module].getBestMatch(topic);
        }
        if (typeof this.moduleFilter.all === 'object') {
            const match = this.moduleFilter.all.getBestMatch(topic);
            if (result === undefined || match > result) {
                result = match;
            }
        }
        return result;
    }

    /**
     * Logs a message if the appropriate log level is set.
     * @param {string} moduleStr - Name of the "module" for logging.
     * @param {Message} message - Message structure.
     * @param {number} qos - Quality of service of message delivery.
     * @param {boolean | number} dup - Duplicate flag (true/false, 0/1).
     * @param {string} [serviceName] - Name of the service logging. Default value is an empty string.
     */
    condLogMessage(moduleStr: string, message: Message, qos: number, dup: boolean | number, serviceName = ''): void {
        const logLevel = this.getLogLevel(moduleStr, message.topic);

        if (logLevel) {
            const reasonStr = Array.isArray(message.reason)
                ? (moduleStr === 'received'
                    ? message.reason[0].message
                    : message.reason[message.reason.length - 1].message)
                : '';
            const valueStr = message.value ? `=${message.value}` : '';
            const dupStr = dup ? ',dup' : '';

            console.log(`${new Date().toLocaleString()} ${serviceName} (qos${qos}${dupStr}) ${moduleStr} ${message.topic}${valueStr} [${reasonStr}]`);
        }
    }
}
