/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview Filters logs by a topic string and prints them to console
 */

import  CheckInput from '@mangar2/checkinput';
import { IMessage, Message, qos_t, TopicMatch } from './index';  

export interface LogPattern {
    topic: string;
    module: string;
    level?: number;
}

/**
 * @class LogFilter
 * @description
 * Provides a simple filter for logging topic based messages.
 * @example
 * const logfilter = new LogFilter();
 * logfilter.changePattern([{ topic: 'input/%', module: 'receive', level: 1 }]);
 * logfilter.condLogMessage('receive', new Message('hello world', 1), 1);
 */
export class Logger {
    private moduleFilter: Record<string, TopicMatch> = {};
    private checkTopicList = new CheckInput({
        type: 'array',
        items: {
            type: 'object',
            properties: {
                topic: { type: 'string' },
                module: { type: 'string' },
                level: { type: 'number', minimum: 0 }
            },
            required: ['topic', 'module']
        }
    });
    private _messages: IMessage[] = [];

    /**
     * Gets the messages that have been logged.
     */
    get messages(): IMessage[] {
        return this._messages;
    }

    /**
     * Replaces the log filter patterns, deleting the current patterns and replace them with the new patterns.
     * @param {LogPattern[]} patternList
     * @throws {Error} If the parameter is badly formatted.
     */
    changePattern(patternList: LogPattern[]): void {
        this.moduleFilter = {};
        this.checkTopicList.throwOnValidationError(patternList, 'log filter error');
        for (const pattern in patternList) {
            const filter = patternList[pattern];
            const module = filter.module;
            const level = filter.level !== undefined ? filter.level : 0;
            if (this.moduleFilter[module] === undefined) {
                this.moduleFilter[module] = new TopicMatch();
            }
            this.moduleFilter[module].addPattern(filter.topic, level);
        }
    }

    /**
     * Gets the log level.
     * @param {string} module name of the module to check for.
     * @param {string} topic topic to check.
     * @returns {undefined | number} returns a log level or undefine, if logging is false.
     */
    getLogLevel(module: string, topic: string): number | undefined {
        let result: number | undefined;
        if (typeof this.moduleFilter[module] === 'object') {
            result = this.moduleFilter[module].getBestMatch(topic);
        }
        if (typeof this.moduleFilter.all === 'object') {
            const match = this.moduleFilter.all.getBestMatch(topic);
            if (result === undefined || match > result) {
                result = match;
            }
        }
        return result;
    }

    /**
     * Logs a message with the specified details.
     * @param moduleName - The name of the module.
     * @param topic - The topic of the message.
     * @param text - The text of the message.
     * @param serviceName - The name of the service. (optional)
     * @param qos - The quality of service. (optional)
     */
    log(moduleName: string, topic: string, text: string, serviceName = '', qos: qos_t = 0) {
        const logLevel = this.getLogLevel(moduleName, topic);
        if (logLevel) {
            const logText = `${new Date().toLocaleString()} ${serviceName} ${text}`
            const message = new Message(`$SYS/${serviceName}/log`, logText, 'log', qos, false);
            this._messages.push(message);
        }
    }

    /**
     * Logs a message if the appropriate log level is set.
     * @param {string} moduleName - Name of the "module" for logging.
     * @param {IMessage} message - Message structure.
     * @param {boolean} dup - Duplicate flag (true/false, 0/1).
     * @param {string} [serviceName] - Name of the service logging. Default value is an empty string.
     */
    logMessage(moduleName: string, message: IMessage, dup: boolean, serviceName = '', logQos: qos_t = 0): void {
        const { topic, value, reason, qos, retain } = message;

        const reasonStr = Array.isArray(reason)
            ? (moduleName === 'received'
                ? reason[0].message
                : reason[reason.length - 1].message)
            : '';
        const valueStr = value ? `=${value}` : '';
        const dupStr = dup ? ',dup' : '';
        const retainStr = retain ? ',retain' : '';
        const logText = ` (qos${qos}${dupStr}${retainStr}) ${moduleName} ${topic}${valueStr} [${reasonStr}]`;
        this.log(moduleName, topic, logText, serviceName, logQos);
    }

    /**
     * Prints the log to the console.
     */
    printLog() {
        for (const message of this._messages) {
            console.log(message);
        }
    }   

    /**
     * Clears the messages array.
     */
    clear() {
        this._messages = [];
    }   
}
