/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * This is the basic class holding MQTT message information
 * The yaha home automation is based on messages. Nothing happens without a message.
 * The message runs from creator to broker and then to the receiver.
 * On every step, a reason will added to the mesage including a timestamp to get a full trace.
 */

'use strict'

'use strict'

import { Types } from '@mangar2/utils';
import CheckInput from '@mangar2/checkinput';

export interface ReasonEntry {
    timestamp: string;
    message: string;
}

export interface Reason extends Array<ReasonEntry> { }

/**
 * @description
 * Creates a message object that can be sent over MQTT
 * @param {string} topic - Topic string to publish to
 * @param {(string|number)} [value=''] - Value to set topic to
 * @param {string|Reason} [reason=null] - Explaining why the topic will be set to value
 * @param {0,1,2} [qos=1] - quality of service level
 * @param {boolean} [retain=false] - wether the message shall be retained or not
 * @param {Date} [now= new Date()] - Current time
 * @example
 * const message = new Message('this/is/a/topic', 'a value', 'a reason')
 */
export class Message {
    private _value: string | number;
    private _qos: 0 | 1 | 2;
    private _retain: boolean;
    public reason: Reason | null;

    constructor(
        public topic: string,
        value: string | number = '',
        reason: string | Reason | null = null,
        qos: 0 | 1 | 2 = 1,
        retain = false,
        now: Date = new Date()
    ) {
        this._value = value;
        this._qos = qos;
        this._retain = retain;
        this.reason = null;
        if (Types.isArray(reason)) {
            this.reason = [...reason];
        } else if (Types.isString(reason)) {
            this.addReason(reason, now);
        }
        Message.validate(this);
    }

    /**
     * Sets the value of the message
     * @type {string|number}
     */
    set value(value: string | number) { this._value = value; }
    get value(): string | number { return this._value; }

    /**
     * Returns true if the value is "on" (1, 'on', 'true', true), false otherwise
     * @type {boolean}
     */
    isOn(): boolean {
        return (this._value === 'on' || this._value === 'ON' || this._value === 'true' || this._value === 1);
    }

    /**
     * The quality of service (0, 1 or 2) that the message should be delivered with
     * @type {integer}
     */
    set qos(qos: 0 | 1 | 2) { this._qos = qos; }
    get qos(): 0 | 1 | 2 { return this._qos; }

    /**
     * Whether the message shall be retained or not
     * @type {boolean}
     */
    set retain(retain: boolean) { this._retain = retain; }
    get retain(): boolean { return this._retain; }

    /**
     * Adds a new reason object to `this.reason`
     * @param {string} reason - Explaining why the topic will be set to value
     * @param {Date|undefined} now - Current time. Defaults to the current date if undefined.
     */
    addReason(reason: string, now: Date = new Date()): void {
        if (this.reason === null) {
            this.reason = [];
        }
        this.reason.push({
            message: reason,
            timestamp: now.toISOString()
        });
    }

    /**
     * Gets the latest date of the message by browsing the reasons
     * @returns {Date | undefined}
     */
    getDateOfNewestChange(): Date | undefined {
        let time: Date | undefined = undefined;
        if (this.reason !== null) {
            for (const element of this.reason) {
                const timestamp = element.timestamp;
                if (timestamp !== undefined) {
                    time = new Date(timestamp);
                    break;
                }
            }
        }
        return time;
    }

    /**
     * Validates that the message object matches the defined schema
     * @param {Object} object - Object to validate or `this`
     * @throws {error} - Throws an exception if the validation fails
     */
    static validate(object: any): void {
        const checkMessage = new CheckInput({
            type: 'object',
            properties: {
                topic: { type: 'string' },
                value: { type: ['string', 'number'] },
                reason: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            message: { type: 'string' },
                            timestamp: { type: 'string' }
                        },
                        required: ['message']
                    }
                },
                qos: { type: 'integer', minimum: 0, maximum: 2 },
                retain: { type: 'boolean' }
            },
            required: ['topic', 'value']
        });

        if (checkMessage.validate(object) !== true) {
            throw Error(JSON.stringify(checkMessage.messages, null, 2));
        }
    }

    /**
     * Ensures that the JSON format is well formatted (value instead of _value)
     */
    toJSON(): object {
        return {
            topic: this.topic,
            value: this._value,
            reason: this.reason,
            qos: this._qos,
            retain: this._retain
        };
    }
}

