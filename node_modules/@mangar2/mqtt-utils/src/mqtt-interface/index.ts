/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const { publish, onPublish, PublishOptions } = require('./publish')
const { pubrel, onPubrel } = require('./pubrel')
const { subscribe, onSubscribe, Topic } = require('./subscribe')
const { unsubscribe, onUnsubscribe } = require('./unsubscribe')
const { connect, onConnect, ConnectOptions } = require('./connect')
const { disconnect, onDisconnect } = require('./disconnect')

/**
 * @private
 * @description Extracts the version from a headers object
 * @param {Object} headers object with member version
 * @returns {string} version string
 */
function getVersion (headers: Record<string, string>) {
    const version = headers.version === undefined ? '0.0' : headers.version
    if (onPublish[version] === undefined) {
        throw 'undefined version ' + version
    }
    return version
}

export const Interfaces = {
    /**
     * @description Creates the objects to publish to a client
     * @param {string} version interface version ('0.0' or '1.0')
     * @param {object} options publish options
     * @param {string} options.token connection token
     * @param {Object} options.message payload
     * @param {number} options.qos quality of service (0,1,2)
     * @param {number} options.dup duplicate flag 1 (true) or 0 (false). Identifies duplicate packages
     * @param {number} options.retain flag 1 (true) or 0 (false). Requrests to retain the message
     * @param {number} options.packetid unique id of the package
     * @returns {Object} {headers, payload, resultCheck(result)}
     */
    publish: (version: string, options: typeof PublishOptions) => {
        return publish[version](options)
    },

    /**
     * @description creates the return types for a receive message
     * @param {Object} headers input headers
     * @returns {Object} {headers, payload, statusCode, packetid}
     */
    onPublish: (headers: Record<string, string>) => {
        return onPublish[getVersion(headers)](headers)
    },
    receive: (headers: Record<string, string>) => {
        return onPublish[getVersion(headers)](headers)
    },

    /**
     * @description creates the return types for a receive pubrel message
     * @param {string} version interface version ('0.0' or '1.0')
     * @param {string} token connection token
     * @param {number} packetid of the packet (must be the same id as send by publish!)
     * @returns {Object} {headers, payload, resultCheck(result)}
     */
    pubrel: (version: string, token: string, packetid: number) => {
        return pubrel[version](token, packetid)
    },
    /**
     * @description Creates the objects for a qos=2 commit message "pubcomp"
     * @param {Object} headers pubrel message headers
     * @returns {Object} {headers, payload, statusCode, packetid}
     */
    onPubrel: (headers: Record<string, string>) => {
        return onPubrel[getVersion(headers)](headers)
    },
    /**
     * @description Subscribes to a client
     * @param {string} version interface version ('0.0' or '1.0')
     * @param {Object} topics {topic: qos, ...}
     * @param {string} clientId unique client identifier
     * @param {number|undefined} packetid unique id of the package (not used on version 0.0)
     * @returns {Object} {headers, payload, resultCheck(result)}
     */
    subscribe: (version: string, topics: typeof Topic, clientId: string, packetid: number) => {
        return subscribe[version](topics, clientId, packetid)
    },
    /**
     * @description Creates the subscribe result objects
     * @param {Object} headers input headers
     * @param {Array} qosArray quality of service reply array
     * @returns {Object} {headers, payload, statusCode, packetid}
     */
    onSubscribe: (headers: Record<string, string>, qosArray: number[]) => {
        return onSubscribe[getVersion(headers)](headers, qosArray)
    },
    /**
     * @description Creats the objects to unsubscribe from a client
     * @param {string} version interface version ('0.0' or '1.0')
     * @param {Array} topics array of topic strings
     * @param {string} clientId unique client identifier
     * @param {number|undefined} packetid unique id of the package (not used on version 0.0)
     * @returns {Object} {headers, payload, resultCheck(result)}
     */
    unsubscribe: (version: string, topics: typeof Topic, clientId: string, packetid: number) => {
        return unsubscribe[version](topics, clientId, packetid)
    },
    /**
     * @description creates the return types for a disconnect request
     * @param {Object} headers message headers
     * @returns {Object} {headers, payload, statusCode, packetid}
     */
    onUnsubscribe: (headers: Record<string, string>) => {
        return onUnsubscribe[getVersion(headers)](headers)
    },
    /**
     * @description Creates the objects to connect ot a broker
     * @param {string} version interface version '1.0' or '0.0'
     * @param {Object} options connect options
     * @param {string} options.clientId unique client identifier
     * @param {string} options.host host name of the client host
     * @param {number} options.port port number of the clien listening port
     * @param {bool} options.clean true, if the connection is cleaned up after disconnect
     * @param {nubmer} options.keepAlive keep alive time in milliseconds
     * @returns {Object} {headers, payload, resultCheck(result)}
     */
    connect: (version: string, options: typeof ConnectOptions) => {
        return connect[version](options)
    },
    /**

    * @description Creates the return types for a connect request
     * @param {Object} headers message headers
     * @param {Object} payload payload to return
     * @returns {Object} {headers, payload, statusCode}
     */
    onConnect: (headers: Record<string, string>, payload: string) => {
        return onConnect[getVersion(headers)](payload)
    },
    /**
     * @description Creates the objects to disconnect from a broker
     * @param {string} clientId unique client identifier
     * @returns {Object} {headers, payload, resultCheck(result)}
     */
    disconnect: (version: string, clientId: string) => {
        return disconnect[version](clientId)
    },
    /**
     * @description creates the return types for a disconnect request
     * @param {Object} headers message headers
     * @returns {Object} {headers, payload, statusCode}
     */
    onDisconnect: (headers: Record<string, string>) => {
        return onDisconnect[getVersion(headers)]()
    }
}
