/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

import { Message } from "../message";
import { Result, RequestData, standardHeaderJSON } from "./interfaces"

/**
 * Type representing the connection options
 */
export interface PublishOptions {
    token: string;
    message: Message;
    qos?: number | string;
    dup?: number | string;
    retain?: number | string;
    packetid?: number;
}

/**
 * Publish function interface.
 */
interface PublishFunction {
    (options: PublishOptions): RequestData
}

/**
 * Publish functions mapped by their version numbers
 * @private
 */
export const publish: Record<string, PublishFunction> = {
    '0.0': (options: PublishOptions) =>  {
        const { message, qos = 1, packetid} = options;
        // token, dup, retain are in the interface for compatibility with the 1.0 interface
        const payload = message;
        const headers: Record<string, string> = { ...standardHeaderJSON, qos: qos.toString(), version: '0.0' };
        if (packetid !== undefined) {
            headers.id = packetid.toString();
        }

        const resultCheck = (result: Result) => {
            return Number(qos) === 0 || (
                result.statusCode === 200 &&
                result.headers['content-type'].startsWith('text/plain') &&
                result.payload.toLowerCase() === 'puback' &&
                result.headers.id === packetid?.toString()
            );
        }

        return { headers, payload, resultCheck };
    },

    '1.0': (options: PublishOptions) => {
        const {token, message, qos = 1, dup = 0, retain = 0, packetid } = options;
        const payload = { token, message };
        const headers: Record<string, string> = { 
            ...standardHeaderJSON, 
            qos: qos.toString(), 
            dup: dup.toString(), 
            retain: retain.toString(), 
            version: '1.0' 
        };
        if (packetid !== undefined) {
            headers.packetid = packetid.toString();
        }

        const resultCheck = (result: Result) => {
            let success: boolean;
            const statusOk = result.statusCode === 204;
            const packetIdMatches = result.headers.packetid === packetid?.toString();
            const packet = result.headers.packet;

            switch (qos) {
                case '0': success = true; break;
                case '1': success = statusOk && packet === 'puback' && packetIdMatches; break;
                case '2': success = statusOk && packet === 'pubrec' && packetIdMatches; break;
                default: success = true; // invalid qos, should not happen
            }

            return success;
        }

        return { headers, payload, resultCheck };
    }
};

/**
 * Publish response interface.
 */
interface PublishResponseFunction {
    (headers: Record<string, string>): Result 
}


/**
 * OnPublish functions mapped by their version numbers
 * @private
 */
export const onPublish: Record<string, PublishResponseFunction> = {
    '0.0': headers => {
        const version = '0.0';
        const result: Result = {
            headers: { 'content-type': 'text/plain; charset=UTF-8', version },
            payload: 'puback',
            statusCode: 200,
            packetid: Number(headers.id)
        }

        if (headers.id !== undefined) {
            result.headers.id = headers.id;
        }

        return result;
    },

    '1.0': headers => {
        const version = '1.0';
        const qos = Number(headers.qos);
        const result: Result = {
            headers: { 'content-type': 'application/json; charset=UTF-8', version },
            payload: '',
            statusCode: 204,
            packetid: Number(headers.packetid)
        }

        if (qos === 1) { result.headers.packet = 'puback'; }
        if (qos === 2) { result.headers.packet = 'pubrec'; }
        if (headers.packetid !== undefined) {
            result.headers.packetid = headers.packetid;
        }

        return result;
    }
}


