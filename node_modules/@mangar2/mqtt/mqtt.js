/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      mqtt.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

'use strict'

const Message = require('@mangar2/message')
const LogFilter = require('@mangar2/logfilter')
const Connections = require('@mangar2/connections')
const CheckInput = require('@mangar2/checkinput')
const errorLog = require('@mangar2/errorlog')
const mqttVersion = require('@mangar2/mqttversion')
const Callbacks = require('@mangar2/callbacks')

// set to true to print stack traces for debugging
const DEBUG = false

/**
 * Checks the payload structure of a connect command
 */
const checkConnectPayload = new CheckInput({
    type: 'object',
    properties: {
        clientId: { type: 'string' },
        host: { type: 'string' },
        port: { type: 'number' },
        clean: { type: 'boolean' },
        keepAlive: { type: 'number' },
        password: { type: 'string' },
        user: { type: 'string' },
        will: {
            type: 'object',
            properties: ''
        }
    },
    required: ['clientId', 'host', 'port', 'clean']
})

/**
 * Checks the payload structure of a disconnect command
 */
const checkDisconnectPayload = new CheckInput({
    type: 'object',
    properties: {
        clientId: { type: 'string' }
    },
    required: ['clientId']
})

/**
 * Checks the structure of a subscribe and unsubscribe
 */
const checkSubscribePayload = new CheckInput({
    type: 'object',
    properties: {
        clientId: { type: 'string' },
        topics: { type: 'object' },
        subscribe: {
            type: 'object',
            properties: {
                QoS: { type: 'number', minimum: 0, maximum: 2 },
                topics: {
                    anyOf: [
                        { type: 'string' },
                        {
                            type: 'array',
                            items: { type: 'string' }
                        }
                    ]
                }
            }
        }
    },
    required: ['clientId']
})

/**
 * Gets the quality of service from headers
 * @param {Object} headers headers with qos field
 * @returns {number} qos
 */
function getQos (headers) {
    const qos = Number(headers.qos)
    return qos === 1 ? 1 : (qos === 2 ? 2 : 0)
}

function getDup (headers) {
    return !!(headers.dup === '1' || headers.dup === 'true')
}

function getRetain (headers) {
    return !!(headers.retain === '1' || headers.retain === 'true')
}

/**
 * Main Mqtt message handler, receives, checks, transforms and foreward messages
 * @param {Object} configuration configuration options for the instance
 * @param {Object} configuration.log logging options
 * @param {Object} configuration configuration
 * @param {string} configuration.fileName filename for persistence
 * @param {string} configuration.directory directory (file path) for persistence
 * @param {nubmber} configuration.replyTimeoutInMilliseconds timeout to wait for an answer
 * of a http call, default 10 seconds
 * @param {number} configuration.inFlightWindow amount of qos 1 and qos 2 messages
 * send for the same topic at the same time, default 1
 * @param {number} configuration.pubrelTimeoutInMilliseconds timout to wait for a
 * corresponding pubrel message, default one day
 * @param {number} configuration.maxRetryCount amount of resend of messages
 * before forcing a disconnect
 * @param {number} configuration.maxQueuSize maximal amount of entries in a message queue
 */
class Mqtt {
    constructor (configuration) {
        this.connections = new Connections(configuration)
        this.logFilter = new LogFilter()
        if (configuration.log !== undefined) {
            this.logFilter.changePattern(configuration.log)
        }

        this._callbacks = new Callbacks(['login', 'authenticate', 'send', 'publish'])
        this.on('login', (username, password) => { return true })
        this.on('authenticate', (token) => { return true })
    };

    /**
     * Restores the broker state from a file
     */
    restoreFromFile () {
        try {
            this.connections.restoreFromFile()
        } catch (err) {
            errorLog(err, DEBUG)
        }
    }

    /**
     * Sets a callback.
     * @param {string} event callback name
     * @param {function} callback
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on (event, callback) { this._callbacks.on(event, callback) }

    /**
     * Reads the value from a parsed payload (if available)
     * @param {Object} value Message payload
     * @returns {Object} the message value
     */
    static parseValue (value) {
        if (value === undefined) {
            value = ''
        }

        try {
            value = Number(value)
        } catch (err) {
        }

        return value
    }

    /**
     * Sets the topics to log. Uses the mqtt topic match strings with wildchards # and +
     * @param {Object} payload {topic: type, topic: type, ... } type = "received, send, all"
     * @returns {Object} {Content-Type, body, statusCode}
     */
    setLog (payload) {
        this.logFilter.changePattern(payload)
        const result = {
            headers: { 'Content-Type': 'application/json' },
            payload: JSON.stringify(this.logFilter.moduleFilter),
            statusCode: 200
        }
        return result
    }

    /**
     * Internal use only: publishes a message
     * @param {Object} message message to publish
     * @param {number} qos quality of service
     * @param {boolean} dup duplicate flag
     * @param {boolean} retain retain flag
     */
    publish (message, qos, dup, retain) {
        if (this.logFilter.getLogLevel('received', message.topic) !== undefined) {
            const reason = message.reason === undefined ? '' : message.reason[0].message
            const dupStr = dup ? ',dup' : ''
            const retainStr = retain ? ',retain' : ''
            const valueStr = message.value === '' || message.value === undefined ? '' : '=' + message.value
            console.log('%s (qos%s%s%s) received %s%s [%s]', new Date().toLocaleString(), qos, dupStr, retainStr, message.topic, valueStr, reason)
        }
        this._callbacks.invokeCallback('publish', message)
        this.connections.publishMessage(message, qos, retain)
    }

    /**
     * Receives a pubrel packages
     * @param {Object} payload publish payload
     * @param {Object} headers headers parameter {packetid}
     * @returns {Object} {headers, payload, statusCode}
     */
    onPubrel (payload, headers) {
        const result = mqttVersion.onPubrel(headers)
        this.connections.onPubrel(payload.token, result.packetid)
        return result
    }

    /**
     * Receives a message to pubish
     * @param {Object} payload publish payload
     * @param {Object} headers header parameters {qos, dup, packetid, retain}
     * @param {number} headers.qos quality of service
     * @param {(number|string)} [headers.dup] duplicate flag
     * @param {number} headers.packetid id of the packet
     * @param {(number|boolean)} [headers.retain] retain flag (true or 1 to retain the message)
     * @param {string} [headers.version='0.0'] interface version
     * @returns {Object} {headers, payload, statusCode}
     */
    onPublish (payload, headers) {
        const token = payload.token
        const message = payload.message === undefined ? payload : payload.message
        const messageObj = new Message(message.topic, message.value, message.reason)
        let isDuplicate = false
        messageObj.addReason('received by broker')

        if (headers.version !== undefined && headers.version !== '0.0') {
            const clientId = this.connections.checkToken(token)
            this.connections.getClientById(clientId).actualizeLastActiveTimestamp()
            isDuplicate = this.connections.isDuplicateQos2message(clientId, message.topic,
                getQos(headers), getDup(headers), headers.packetid)
        }

        const result = mqttVersion.onPublish(headers)

        if (!isDuplicate) {
            this.publish(messageObj, getQos(headers), getDup(headers), getRetain(headers), result.packetid)
        }

        return result
    }

    /**
     * Connects a client to the broker, storing the connection informations
     * @param {Object} payload payload {clientId, host, port, clean, will}
     * @param {string} payload.clientId id of the connecting client
     * @param {string} payload.host host name (or ip) of the client
     * @param {number} payload.port port number
     * @param {boolean} payload.clean true, if the session shall be cleaned
     * @param {number} payload.keepAlive timeout in milliseconds for disconnecting
     * if no message is transmitted
     * @param {string} payload.password connection password
     * @param {string} payload.user connection user name
     * @param {Object} payload.will message to be send on connection loss
     * @param {Object} headers received headers
     * @param {string} headers.version interface version
     * @returns {{headers, payload, statusCode}}
     */
    onConnect (payload, headers) {
        checkConnectPayload.throwOnValidationError(payload, 'Connect wrong parameters: ')
        let result
        const { clientId, host, port, clean, keepAlive, password, user, will } = payload
        const { version = '0.0' } = headers
        try {
            if (!this._callbacks.invokeCallback('login', user, password)) {
                throw Error('Could not login, request from ' + payload.clientId)
            }
            const connect = this.connections.connect(clientId, host, port, clean, version, keepAlive)
            if (connect.mqttcode !== 0) {
                throw Error('Could not connect (code: ' + connect.mqttcode + ') request from ' + payload.clientId)
            }
            result = mqttVersion.onConnect(headers, { present: connect.present, token: connect.token })
            const message = new Message('$SYS/broker/connect', 'success', 'request from ' + payload.clientId)
            this.connections.setWill(clientId, will)

            this.publish(message, 1, false, false)
        } catch (err) {
            const message = new Message('$SYS/broker/connect', 'refused', err.message)
            this.publish(message, 1, false, false)
            throw err
        }
        return result
    }

    /**
     * disconnects a client from the broker
     * @param {Object} payload
     * @param {string} payload.clientId Id of the client to disconnect
     * @param {Object} headers received headers
     * @param {string} headers.version interface version
     * @returns {{headers: object, payload: object, statusCode: number}} http result objects
     */
    onDisconnect (payload, headers) {
        let result
        try {
            checkDisconnectPayload.throwOnValidationError(payload, 'Disconnect wrong parameters: ')
            this.connections.disconnect(payload.clientId)

            const message = new Message('$SYS/broker/disconnect', 'success', 'request from ' + payload.clientId)
            this.publish(message, 1, false, false)
            result = mqttVersion.onDisconnect(headers)
        } catch (err) {
            const message = new Message('$SYS/broker/disconnect', 'failed', err.message)
            this.publish(message, 1, false, false)
            throw err
        }

        return result
    }

    /**
     * Subscribes to topics
     * @param {Object} payload {clientId, topics}
     * @param {Object} headers received headers
     * @param {number} headers.packetid id of the packet
     * @param {string} headers.version interface version
     * @returns {{headers: object, payload: object, statusCode: number}} http result objects
     */
    onSubscribe (payload, headers) {
        checkSubscribePayload.throwOnValidationError(payload, 'Subscribe wrong parameters: ')

        const qos = this.connections.subscribe(
            payload.clientId,
            payload.subscribe === undefined ? payload.topics : payload.subscribe
        )

        const message = new Message('$SYS/broker/subscribe', JSON.stringify(qos), 'request from ' + payload.clientId)
        this.publish(message, 1, false, false)

        const result = mqttVersion.onSubscribe(headers, qos)
        return result
    }

    /**
     * Unsubscribes to topics
     * @param {Object} payload {clientId, topics}
     * @param {string} payload.clientId id of the connecting client
     * @param {Object} payload.topics topics to subscribe to
     * @param {Object} headers received headers
     * @param {string} headers.version interface version
     * @returns {{headers: object, payload: object, statusCode: number}} http result objects
     */
    onUnsubscribe (payload, headers) {
        checkSubscribePayload.throwOnValidationError(payload, 'Unsubscribe wrong parameters: ')

        const message = new Message('$SYS/broker/unsubscribe', '', 'request from ' + payload.clientId)
        this.publish(message, 1, false, false)

        this.connections.unsubscribe(payload.clientId, payload.topics)
        const result = mqttVersion.onUnsubscribe(headers)

        return result
    }

    /**
     * Answers to a ping
     * @param {Object} payload http call payload
     * @param {string} playload.token
     * @returns {{headers: object, payload: object, statusCode: number}} http result objects
     */
    onPingreq (payload) {
        const client = this.connections.getClientByToken(payload.token)
        if (client === undefined) {
            throw Error('pingreq with illegal token')
        }
        client.actualizeLastActiveTimestamp()
        const message = new Message('$SYS/broker/ping', '', client.clientId)
        this.publish(message, 1, false, false)

        const result = {
            headers: { 'Content-Type': 'application/json', packet: 'pingresp' },
            payload: '',
            statusCode: 204
        }
        return result
    }

    /**
     * Calls a connection interface
     * @param {string} controls name of the mqtt controls to call (connect, disconnect, ...)
     * @param {Object} payload parameters for the interface (see interfaces)
     * @param {Object} headers headers of the http message
     * @returns {{headers: object, payload: object, statusCode: number}} http result objects
     */
    processRequest (controls, payload, headers) {
        let result = { headers: { 'content-type': 'text/plain' }, payload: 'request path not found: ' + controls, statusCode: 404 }
        try {
            switch (controls) {
            case 'publish': result = this.onPublish(payload, headers); break
            case 'pubrel': result = this.onPubrel(payload, headers); break
            case 'connect': result = this.onConnect(payload, headers); break
            case 'disconnect': result = this.onDisconnect(payload, headers); break
            case 'subscribe': result = this.onSubscribe(payload, headers); break
            case 'unsubscribe': result = this.onUnsubscribe(payload, headers); break
            case 'pingreq': result = this.onPingreq(payload); break
            case 'log': result = this.setLog(payload); break
            }
        } catch (err) {
            let error = (typeof (err) === 'string') ? err : err.message
            error = controls + ' ' + error
            errorLog(err, DEBUG)
            result = {
                headers: { 'content-type': 'application/json' },
                payload: JSON.stringify({ error }),
                statusCode: 400
            }
        }
        return result
    }

    /**
     * Gets all connections or a single connection (depends on path)
     * @param {string} clientId id of the client or ""
     * @returns {{headers: object, payload: object, statusCode: number}} http result objects
     */
    getConnections (clientId) {
        const result = {
            headers: { 'Content-Type': 'application/json' },
            payload: {},
            statusCode: 200
        }
        if (clientId === '') {
            result.payload = this.connections.clients
        } else {
            try {
                result.payload = this.connections.getClient(clientId, false)
            } catch (err) {
                result.payload = err.message
            }
        }
        return result
    }

    /**
     * Sends a publish message by invoking a callback
     * @param {MessageQueueEntry} options options for the callback
     * @param {string} options.host host name
     * @param {number} options.port port number
     * @param {string} options.version version string
     * @param {string} options.token send token
     * @param {Message} options.payload payload to send
     * @param {number} options.qos quality of service
     * @param {number} options.dup 1, if the packet is a duplicate (else 0)
     * @param {number} options.packetid packet id
     * @returns {boolean} true, if sending was successful
     */
    async _sendPublish (options) {
        const { host, port, version, token, payload: message, qos, dup, packetid } = options
        const dupStr = dup ? ',dup' : ''
        const valueStr = message.value === '' || message.value === undefined ? '' : '=' + message.value
        const retain = false
        const publishData = mqttVersion.publish(version, token, message, qos, dup, retain, packetid)
        let success = false

        try {
            const result = await this._callbacks.invokeCallbackAsync(
                'send', host, port, 'publish', publishData.payload, publishData.headers)

            success = publishData.resultCheck(result)
            if (success) {
                this.connections.acknowledgeMessage(options)
            }
            if (this.logFilter.getLogLevel('send', message.topic) !== undefined) {
                const reason = message.reason === undefined ? '' : message.reason[0].message
                console.log('%s %s:%s (qos%s%s) send %s=%s [%s]', new Date().toLocaleString(), host, port, qos, dupStr, message.topic, valueStr, reason)
            }
        } catch (err) {
            if (this.logFilter.getLogLevel('send', '$SYS/broker/error') !== undefined) {
                console.log('%s %s:%s send %s=%s [%s]', new Date().toLocaleString(), host, port, message.topic, valueStr, err.message)
            }
        };
        return success
    }

    /**
     * Sends a pubrel message by invoking a callback
     * @param {MessageQueueEntry} options options for the callback
     * @param {string} options.host host name
     * @param {number} options.port port number
     * @param {string} options.version version string
     * @param {string} options.token send token
     * @param {number} options.packetid packet id
     * @returns {boolean} true, if sending was successful
     */
    async _sendPubrel (options) {
        const { host, port, version, token, packetid } = options
        const publishData = mqttVersion.pubrel(version, token, packetid)
        let success = false

        try {
            const result = await this._callbacks.invokeCallbackAsync(
                'send', host, port, 'pubrel', publishData.payload, publishData.headers)

            success = publishData.resultCheck(result)
            if (success) {
                this.connections.acknowledgeMessage(options)
            }
        } catch (err) {
            if (this.logFilter.getLogLevel('send', '$SYS/broker/error') !== undefined) {
                console.log('%s %s:%s pubrel [%s]', new Date().toLocaleString(), host, port, err.message)
            }
        };
    }

    /**
     * Processes all messages to send and for each message calls the provided callback function.
     * @returns {number} amount of messages sent
     */
    async processSendMessage () {
        const messages = this.connections.getAllMessagesToSend()
        this.connections.cleanup()
        let promises = []
        for (const message of messages) {
            let result
            if (message.isStatusPubrel()) {
                result = this._sendPubrel(message)
            } else {
                result = this._sendPublish(message)
            }
            promises.push(result)
            if (promises.length >= 10) {
                Promise.all(promises)
                promises = []
            }
        }
        Promise.all(promises)
        return messages.length
    }
}

module.exports = Mqtt
