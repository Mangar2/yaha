/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      mqttWebServer.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * Version:     1.0
 * ---------------------------------------------------------------------------------------------------
 */

'use strict';

const Message = require('@mangar2/message');
const LogFilter = require('@mangar2/logfilter')
const Connections = require('@mangar2/connections');
const CheckInput = require('@mangar2/checkinput');
const errorLog = require('@mangar2/errorlog');
const mqttVersion = require('@mangar2/mqttversion');

/**
 * Checks the payload structure of a connect command
 */
const checkConnectPayload = new CheckInput({
    type: 'object',
    properties: {
        clientId: {type: 'string'},
        host: {type: 'string'},
        port: {type: 'number'},
        clean: {type: 'boolean'},
        will: {
            type: 'object',
            properties: ''
        }
    },
    required: ['clientId', 'host', 'port', 'clean']
});

/**
 * Checks the payload structure of a disconnect command
 */
const checkDisconnectPayload = new CheckInput({
    type: 'object',
    properties: {
        clientId: {type: 'string'}
    },
    required: ['clientId']
});

/**
 * Checks the structure of a subscribe and unsubscribe
 */
const checkSubscribePayload = new CheckInput({
    type: 'object',
    properties: {
        clientId: {type: 'string'},
        topics: {type: 'object'},
        subscribe: {
            type: 'object',
            properties: {
                QoS: {type: 'number', minimum: 0, maximum: 2},
                topics: {anyOf: [
                    {type: 'string'},
                    {
                        type: 'array',
                        items: {type: 'string'}
                    }
                ]}
            }
        }
    },
    required: ['clientId']
});



module.exports = class mqttControls {

    constructor(configuration) {
        this.connections = new Connections(configuration);
        this.logFilter = new LogFilter();
        if (configuration.log !== undefined) {
            this.logFilter.changePattern(configuration.log);
        }
        this.connections.restoreClientsFromLastFile();
    };

    /**
     * Reads the value from a parsed payload (if available)
     * @param {object} parsedpayload parsed Message payload 
     * @returns {object} the message value
     */
    static parseValue(value) {
        if (value == undefined) {
            value = "";
        }

        try {
            if (!isNaN(value) && !isNaN(parseFloat(value))) {
                valueFloat = parseFloat(parsedpayload.value);
                valueInt = parseInt(parsepayload.value);
                if (valueFloat === 0 && valueInt !== 0) {
                    value = valueInt;
                } else {
                    value = valueFloat;
                }
            }
        } catch (err) {
        }

        return value;
    }

    /**
     * Sets the topics to log. Uses the mqtt topic match strings with wildchards # and +
     * @param {object} payload {topic: type, topic: type, ... } type = "received, send, all"
     * @returns {object} {Content-Type, body, statusCode}
     */
    setLog(payload) {
        this.logFilter.changePattern(payload);
        let result = { 
            headers: { "Content-Type": "application/json" },
            payload: JSON.stringify(this.logFilter.moduleFilter),
            statusCode: 200 
        }
        return result;
    }


    /**
     * Internal use only: publishes a message
     * @param {object} message message to publish
     * @param {number} qos quality of service
     * @param {boolean} dup duplicate flag
     * @param {boolean} retain retain flag
     */
    publish(message, qos, dup, retain) {
        qos = qos == 1 ? 1 : (qos == 2 ? 2 : 0);
        if (this.logFilter.getLogLevel("received", message.topic) !== undefined)  {
            let reason = message.reason === undefined ? "" : message.reason[0].message;
            let dupStr = dup ? ",dup" : "";
            let retainStr = retain ? ",retain" : "";
            let valueStr = message.value === "" || message.value === undefined ? "" : "=" + message.value;
            console.log("%s (qos%s%s%s) received %s%s [%s]", new Date().toLocaleString(), qos, dupStr, retainStr, message.topic, valueStr, reason);
        }
        this.connections.publishMessage(message, qos, retain);
    }

    /**
     * Publishes a message
     * @param {object} message message containing location and interface 
     * @param {object} headers header parameters {qos, dup, packetid, retain}
     * @returns {object} {Content-Type, headers, body, statusCode}
     */
    onPublish(message, headers) {
        if (message === undefined) {throw Error("publish without parameters"); }
        let messageObj = new Message(message.topic, mqttControls.parseValue(message.value), message.reason);
        messageObj.addReason("received by broker");
        let qos = headers.qos;
        let dup = headers.dup === "1" || headers.dup === "true" ? true : false;
        let retain = headers.retain === "1" || headers.retain === "true" ? true : false;

        this.publish(messageObj, qos, dup, retain);

        let result = mqttVersion.receive(headers);
        return result;
    }

    /**
     * Connects a client to the broker, storing the connection informations
     * @param {object} payload payload {clientId, host, port, clean, will}
     * @param {object} headers received headers {version: interface version}
     * @returns {object} {Content-Type, body, statusCode}
     */
    onConnect(payload, headers) {
        checkConnectPayload.throwOnValidationError(payload, "Connect wrong parameters: ")
        let result;
        let will = payload.will;
        if (will !== undefined) {
            // todo implement
        }
        let version = headers.version === undefined ? "0.0" : headers.version;
        let connect = this.connections.connect(payload.clientId, payload.host, payload.port, payload.clean, version);
        
        if (connect.mqttcode === 0) {
            result = mqttVersion.onConnect(headers, connect.present);
            let message = new Message("system/broker/connect/success", connect.mqttcode, "request from " + payload.clientId);
            this.publish(message, 1, false, false);
        } else {
            let message = new Message("system/broker/connect/refused", connect.mqttcode, "request from " + payload.clientId);
            this.publish(message, 1, false, false);
            throw Error("connection refused");
        }
        return result;
    }

    /**
     * disconnects a client from the broker
     * @param {object} payload {clientId}
     * @returns {object} {Content-Type, body, statusCode}
     */
    onDisconnect(payload) {
        checkDisconnectPayload.throwOnValidationError(payload, "Disconnect wrong parameters: ")
        this.connections.disconnect(payload.clientId);
        
        let message = new Message("system/broker/disconnect/success", "", "request from " + payload.clientId);
        this.publish(message, 1, false, false);

        let result = {
            headers: {'Content-Type': "application/json"},
            payload: "",
            statusCode: 204
        }
        return result;
    }

    /**
     * Subscribes to topics
     * @param {object} payload {clientId, topics}
     * @param {object} headers received headers {packetid: packet identifier, version: interface version}
     * @returns {object} {Content-Type, headers, body, statusCode}
     */
    onSubscribe(payload, headers) {
        checkSubscribePayload.throwOnValidationError(payload, "Subscribe wrong parameters: ");
        
        let qos = this.connections.subscribe(
            payload.clientId, 
            payload.subscribe === undefined ? payload.topics : payload.subscribe
            );
        
        let message = new Message("system/broker/subscribe", JSON.stringify(qos), "request from " + payload.clientId);
        this.publish(message, 1, false, false);

        let result = mqttVersion.onSubscribe(headers, qos);
        return result;
    }

    /**
     * Unsubscribes to topics
     * @param {object} payload {clientId, topics}
     * @returns {object} {Content-Type, statusCode}
     */
    onUnsubscribe(payload) {
        checkSubscribePayload.throwOnValidationError(payload, "Unsubscribe wrong parameters: ");

        let message = new Message("system/broker/unsubscribe", "", "request from " + payload.clientId);
        this.publish(message, 1, false, false);

        this.connections.unsubscribe(payload.clientId, payload.topics);
        let result = { 
            headers: {'Content-Type': "application/json", packet: "unsuback"},
            payload: "",
            statusCode: 204 
        } 
        return result;
    }

    /**
     * Answers to a ping
     */
    onPingreq(payload) {

        let message = new Message("system/broker/ping", "", "request from " + payload.clientId);
        this.publish(message, 1, false, false);

        let result = { statusCode: 204 }
        return result;
    }

    /**
     * Calls a connection interface
     * @param {string} controls name of the mqtt controls to call (connect, disconnect, ...)
     * @param {object} payload parameters for the interface (see interfaces)
     * @param {object} headers headers of the http message
     * @returns {object} {Content-Type, headers, body, statusCode}, headers and body is optional
     */
    processRequest(controls, payload, headers) {
        let result = {'Content-Type': "text/plain", payload: "not found " + controls, statusCode: 404};
        try {
            switch(controls) {
                case "publish": result = this.onPublish(payload, headers); break;
                case "connect": result = this.onConnect(payload, headers); break;
                case "disconnect": result = this.onDisconnect(payload); break;
                case "subscribe": result = this.onSubscribe(payload, headers); break;
                case "unsubscribe": result = this.onUnsubscribe(payload); break;
                case "pingreq": result = this.onPingreq(payload); break;
                case "log": result = this.setLog(payload); break;
            }
        }
        catch (err) {
            errorLog(err);
            let error = (typeof(err) === 'string') ? err : err.message;
            result = {
                headers: {'content-type': "application/json"}, 
                payload:JSON.stringify({error}), 
                statusCode: 400
            }
        }
        return result;
    }

    /**
     * Gets all connections or a single connection (depends on path)
     * @param {string} clientId id of the client or ""
     */
    getConnections(clientId) {
        let result = { 
            headers: {'Content-Type': "application/json"},
            payload: {},
            statusCode: 200 
        } 
        if (clientId === "") {
            result.payload = this.connections.clients;
        } else {
            try {
                result.payload = this.connections.getClient(clientId, false);
            } catch (err) {
                result.payload = err.message;
            }
        }
        return result;
    }

    /**
     * Processes all messages to send and for each message calls the provided callback function. 
     * The callback receives 
     * host: hostname, 
     * port: port number, 
     * message: message to send, 
     * headers: http headers 
     * @param {function} callback (host, port, message, headers) function processing the messages 
     * @returns {integer} amount of messages sent
     */
    processSendMessage(callback) {
        return this.connections.sendAllMessages(async (host, port, message, flags) => {

            let dupStr = flags.dup ? ",dup" : "";
            let valueStr = message.value === "" || message.value === undefined ? "" : "=" + message.value;
            let retain = false;
            let publishData = mqttVersion.publish(flags.version, message, flags.qos, flags.dup, retain, flags.packetid);
            let success = false;

            try {
                let result = await callback(host, port, publishData.payload, publishData.headers);
                success = publishData.resultCheck(result);

                if (this.logFilter.getLogLevel("send", message.topic) !== undefined) {
                    let reason = message.reason === undefined ? "" : message.reason[0].message;
                    console.log("%s %s:%s (qos%s%s) send %s=%s [%s]", new Date().toLocaleString(), host, port, headers.qos, dupStr, message.topic, valueStr, reason);
                }
            }
            catch (err) {
                if (this.logFilter.getLogLevel("send", "system/broker/error") !== undefined) {
                    console.log("%s %s:%s send %s=%s [%s]", new Date().toLocaleString(), host, port, message.topic, valueStr, err.message);
                }
            };
            
            return success;
        });
    }

   
}
    
