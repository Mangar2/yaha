/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const TopicMatch = require('@mangar2/topicmatch')
const Message = require('@mangar2/message')
const MessageQueues = require('./messagequeues')
const MessageQueue = require('./messagequeue')
const MessageQueueEntry = require('./messageQueueEntry')

/**
 * Creates a new connection
 * The Client class corresponds to a connection, it is created for each client subscribing to the broker
 * It stores all client status and provides functions to identify the messages to send to the client
 * @private
 */
class Client {
    constructor () {
        this._clientId = undefined
        this.host = undefined
        this.port = undefined
        this.will = undefined

        this.subscribePattern = new TopicMatch()
        this.nextMessageId = 0
        this.token = {}
        this.qos2Queue = {}
        this.orderedTopicsQueue = new MessageQueues()
        this.qos0Queue = new MessageQueue()
        this.keepAlive = 0
        this.lastActiveTimestamp = 0

        if (Client.maxQueueSize === undefined) {
            Client.maxQueueSize = 100
        }
    }

    /**
     * Name of the sender host
     * @type {string}
     */
    get host () { return this._host }
    set host (host) { this._host = host }

    /**
     * Number of the client port
     * @type {number}
     */
    get port () { return this._port }
    set port (port) { this._port = port }

    /**
     * Id of the client. Note: it can only be set once
     * @type {string}
     */
    get clientId () { return this._clientId }
    set clientId (clientId) {
        if (this._clientId === undefined && clientId !== undefined) {
            this._clientId = clientId
        }
        if (this.clientId !== clientId) {
            throw Error('clientId may not be changed (' + clientId + ')')
        }
    }

    /**
     * Maximal length of a queue per topic. Longer queues will be truncated
     * @type {integer}
     */
    static set maxQueueSize (size) { Client._maxQueueSize = size }
    static get maxQueueSize () { return Client._maxQueueSize }

    /**
     * Queues ordered by topic
     * @type {Object}
     */
    get orderedTopicsQueue () { return this._orderedTopicsQueue }
    set orderedTopicsQueue (queues) { this._orderedTopicsQueue = queues }

    /**
     * Queue for qos=0 messages
     * @type { MessageQueueEntry[] }
     */
    get qos0Queue () { return this._qos0Queue }
    set qos0Queue (queue) { this._qos0Queue = queue }

    /**
     * Will message configuration
     * @type {Object}
     * @param {Object} will will message configuration
     * @param {number} will.qos will message quality of service
     * @param {boolean} will.retain true, if the will message is retained
     * @param {string} will.topic topic of the will message
     * @param {string|number} will.value value of the will message
     */
    get will () { return this._will }
    set will (will) { this._will = will }

    /**
     *Token the client will use to publish data, only access by get
     * @type {string}
     */
    get sendToken () { return this.token.send }

    /**
     * Sets the last active timestamp to now
     */
    actualizeLastActiveTimestamp () {
        this.lastActiveTimestamp = new Date().getTime()
    }

    /**
     * Checks, if the client has received messages lately
     * @returns {boolean} true, if the client is alive
     */
    isAlive () {
        const mqttStandardAliveFactor = 1.5
        const now = new Date().getTime()
        let alive = true
        if (this.keepAlive !== 0) {
            alive = this.lastActiveTimestamp + this.keepAlive * mqttStandardAliveFactor >= now
        }
        return alive
    }

    /**
     * Checks, if the client is currently connected
     * @returns {boolean} true, if the client is connected
     */
    isConnected () {
        return this.status === 'connected'
    }

    /**
     * Restores the client from a JSON object.
     * @param {Object} jsonObject
     */
    restoreFromJSON (jsonObject) {
        for (const property in jsonObject) {
            this[property] = jsonObject[property]
        }
        this.subscribePattern = new TopicMatch(this.subscribePattern._topicPatternList)
        this.rebuildMessageQueues()
    }

    /**
     * @private
     * @description
     * Creates a message object from payload (plain object)
     * @param {Object} payload object with topic, value and reason
     * @returns {Message} message object
     */
    rebuildPayload (payload) {
        const message = new Message(payload.topic, payload.value, payload.reason)
        return message
    }

    /**
     * @private
     * @description
     * Recreates the message queue from persistend data
     */
    rebuildMessageQueues () {
        const rebuildQos0 = new MessageQueue()
        rebuildQos0.rebuild(this.qos0Queue)
        this.qos0Queue = rebuildQos0

        const rebuildQueue = new MessageQueues()
        rebuildQueue.rebuild(this.orderedTopicsQueue)
        this.orderedTopicsQueue = rebuildQueue
    }

    /**
     * @private
     * @description
     * Cleans up the session
     */
    cleanSession () {
        this.orderedTopicsQueue = new MessageQueues()
        this.qos2Queue = {}
        this.subscribePattern = new TopicMatch()
        this.status = 'clean'
    }

    /**
     * @private
     * @description
     * Initializes values if not already set
     */
    init () {
        if (this.clean) {
            this.cleanSession()
        }
        this.qos0Queue.deleteAllEntries()
        this.orderedTopicsQueue.clearRetryCount()
    }

    /**
     * Sets the clean value (does NOT clean the session). If the parameter clean is
     * undefined AND the property clean is undefined it will set clean to true.
     * @param {boolean|string} clean new clean value (accepts true, "true", 1, "1" as true value). Any other value is false.
     */
    setClean (clean) {
        if (clean !== undefined) {
            this.clean = (clean === true || clean === 'true' || clean === 1 || clean === '1')
        } else if (this.clean === undefined) {
            this.clean = true
        }
    }

    /**
     * Removes old entries from the qos2Queue
     * @param {number} timeoutInMilliseconds amount of milliseconds to keep entries in
     * the queue
     */
    cleanupQos2Queue (timeoutInMilliseconds) {
        const now = new Date().getTime()
        const qos2Queue = this.qos2Queue
        for (const index in qos2Queue) {
            const entry = qos2Queue[index]
            if (entry.time + timeoutInMilliseconds < now) {
                delete qos2Queue[index]
            }
        }
    }

    /**
     * sets the connection to "connected", resets the unsuccessful counter to 0, starts with
     * messageId 0 and stores the current timestamp.
     * @param {any} clientId id of the client
     * @param {string} host host name
     * @param {string} port port name
     * @param {bool} clean true, if the connection will be cleaned on disconnect
     * @param {string} version client interface version
     * @param {number} keepAlive keep alive time in milliseconds. The broker will disconnect
     * any client not sending messages in the keepAlive interval. Default is one hour
     * @returns {Object} connection tokens {send, receive}
     */
    connect (clientId, host, port, clean = true, version = '1.0', keepAlive = (3600 * 1000)) {
        this.startToTransmitTimestamp = 0

        this.clientId = clientId
        this.host = host
        this.port = port
        this.version = version
        this.keepAlive = keepAlive
        this.setClean(clean)

        this.init()
        this.status = 'connected'
        this.actualizeLastActiveTimestamp()
        this.connectTimestamp = new Date().getTime()
        this.token = { send: 'send' + this.clientId, receive: 'receive' + this.clientId }
        return this.token
    }

    /**
     * @private
     * @description
     * Validates the existance of a valid connection
     * @param {string} clientId id of the client
     * @param {string} action actio name for the error message
     * @throws {Error} Connection not valid
     */
    validateConnection (clientId, action) {
        if (this.clientId !== clientId) {
            throw Error(action + ': clientId does not match (' + clientId + ')')
        }
        if (this.status !== 'connected') {
            throw Error(action + ' without beeing connected')
        }
    }

    /**
     * @private
     * @description
     * Disconnects a client
     * @throws {Error} if clientId does not match
     */
    disconnect () {
        this.status = 'disconnected'
        this.qos0Queue.deleteAllEntries()
        this.will = undefined
        if (this.clean) {
            this.cleanSession()
        }
    }

    /**
     * @private
     * @description
     * Adds a subscription to the connection
     * @param {Object} subscribe {QoS:Qos, topics:[topic1, topic2, ...]}
     * @throws {Error} if clientId does not match or subscription is not given
     */
    subscribeOldFormat (subscribe) {
        const QoS = this.convertQoSToValidQoS(subscribe.QoS)
        const topics = subscribe.topics
        const result = []

        if (!Array.isArray(topics)) {
            this.subscribePattern.addPattern(topics, QoS)
            result.push(QoS)
        } else {
            for (const topic of topics) {
                this.subscribePattern.addPattern(topic, QoS)
                result.push(QoS)
            }
        }
        return result
    }

    /**
     * Adds a subscription to the connection
     * @param {any} clientId id of the client
     * @param {Object} topics {topic1:QoS1, topic2:Qos2, ...}
     * @throws {Error} if clientId does not match or subscription is not given
     */
    subscribe (clientId, topics) {
        let result = []
        try {
            this.validateConnection(clientId, 'subscribe')
            if (topics.topics === undefined) {
                for (const topic in topics) {
                    const qos = this.convertQoSToValidQoS(topics[topic])
                    result.push(qos)
                    this.subscribePattern.addPattern(topic, qos)
                }
            } else {
                result = this.subscribeOldFormat(topics)
            }
        } catch (err) {
            result = [0x80]
        }
        return result
    }

    /**
     * removes subscriptions from topics
     * @param {any} clientId id of the client
     * @param {string|Array} topics array of topic strings with wildchars
     * @throws {Error} if clientId does not match or subscription is not given
     */
    unsubscribe (clientId, topics) {
        this.validateConnection(clientId, 'unsubscribe')
        this.subscribePattern.deletePattern(topics)
    }

    /**
     * Deletes an entry from the qos2 queue
     * @param {number} packetid unique identifier of the packet (unique by client)
     */
    deleteFromQos2Queue (packetid) {
        delete this.qos2Queue[packetid]
    }

    /**
     * Checks, if a packet id is in the qos 2 queue.
     * @param {number} packetid unique identifier of the packet (unique by client)
     */
    isInQos2Queue (packetid) {
        return this.qos2Queue[packetid] !== undefined
    }

    /**
     * Adds an entry to the qos=2 queue to remember send packages and to ignore duplicates
     * @param {number} packetid id of the package
     * @param {string} topic topic of the corresponding message
     */
    addToQos2Queue (packetid, topic) {
        this.qos2Queue[packetid] = { time: new Date().getTime(), topic }
    }

    /**
     * "Publishes" messages by adding them to the publish queues. The messages must then still be sent
     * to the client afterwards
     * @param {Object} param parameters
     * @param {Message} param.payload message to add to a publish storage
     * @param {number} param.qos quality of service received from published headers
     * @param {boolean} param.retain true, if the message is triggered from a retained message
     * @param {TopicMatch} pattern optional: alternative match filter to filter messages
     */
    publishMessage (param, pattern = undefined) {
        const { payload, qos } = param
        const topic = payload.topic
        const entryParam = { ...param }

        if (pattern !== undefined && pattern.constructor.name === 'TopicMatch') {
            entryParam.qos = pattern.getBestMatch(topic)
        } else {
            entryParam.qos = this.subscribePattern.getBestMatch(topic)
        }

        const topicIsSubscribed = entryParam.qos !== undefined

        if (topicIsSubscribed) {
            entryParam.qos = this.calcQoS(qos, entryParam.qos)
            const messageQueueEntry = new MessageQueueEntry(entryParam)
            if (entryParam.qos === 0) {
                this.qos0Queue.addMessage(messageQueueEntry, Client.maxQueueSize)
            } else {
                messageQueueEntry.packetid = this.genMessageId()
                this.orderedTopicsQueue.addMessage(messageQueueEntry, Client.maxQueueSize)
            }
        }
    }

    /**
     * Acknowledges a message, either delete it or set it to pubrel
     * @param {string} topic topic to delete message from
     * @param {number} packetid id of the message
     */
    acknowledgeMessageById (topic, packetid) {
        this.orderedTopicsQueue.acknowledgeMessageById(topic, packetid)
    }

    /**
     * @private
     * @description
     * calculates the next message id
     * @returns {number} message id
     */
    genMessageId () {
        var result = this.nextMessageId
        if (result >= 0 || result < 0xFFFF) {
            this.nextMessageId++
        } else {
            result = 0
            this.nextMessageId = 1
        }
        return result
    }

    /**
     * @private
     * @description
     * Converts a QoS to a valid QoS. (0,1,2) by converting it to Number and setting it to
     * "0" on any invalid entry
     * @param {any} QoS QoS to transform
     * @return {number} valid QoS
     */
    convertQoSToValidQoS (QoS) {
        var numberQoS = Number(QoS)
        if (numberQoS !== 1 && numberQoS !== 2) {
            numberQoS = 0
        }
        return numberQoS
    }

    /**
     * @private
     * @description
     * Calculates the resulting QoS from message an subscription
     * @param {number} messageQoS QoS from message
     * @param {number} subscribeQoS QoS from subscription
     */
    calcQoS (messageQoS, subscribeQoS) {
        var validMessageQoS = this.convertQoSToValidQoS(messageQoS)
        var validSubscribeQoS = this.convertQoSToValidQoS(subscribeQoS)
        var result = Math.min(validMessageQoS, validSubscribeQoS)
        return result
    }

    /**
     * Get all messages to send
     * @param {number} inFlightWindow maximal amount of qos1 and qos2 messages to process
     * @param {number} timeoutInMilliseconds timeout waiting for messages
     * @returns {Message[]} messages that should be sent to the client
     */
    getAllMessagesToSend (inFlightWindow, timeoutInMilliseconds) {
        let result = []
        // qos= 0 message are deleted, even if the client is not connected
        const notOrderedMessages = this.qos0Queue.deleteAllEntries()
        if (this.isConnected()) {
            result = this.orderedTopicsQueue.getMessagesToSend(inFlightWindow, timeoutInMilliseconds)
            // only add messages if connected
            result = [...notOrderedMessages, ...result]
            // Each entry needs to know all about the receiver
            for (const entry of result) {
                entry.setClientInfo(
                    this.clientId, this.host, this.port, this.version, this.token.receive)
            }
        }
        return result
    }

    /**
     * @private
     * @description
     * Gets the maximal retry count for a client
     * @returns {number}
     */
    getMaxRetryCount () {
        return this.orderedTopicsQueue.getMaxRetryCount()
    }
}

module.exports = Client
