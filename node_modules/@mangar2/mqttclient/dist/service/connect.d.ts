/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview Provides functions to connect to the (http based) yaha mqtt broker
 */
import { IConnectResult, IConnectOptions, SubscribeResult, UnsubscribeResult, topics_t } from '@mangar2/mqtt-utils';
import { headers_t } from './types';
/**
 * @private
 * @description
 * Gets the IP v4 address of the current device
 * @returns {string} IP v4 address
 */
export declare function getIPv4Address(): string;
/**
 * @callback ConnectMessage
 * @param message the message received
 * @param qos the quality of service information
 * @param dup flag signaling duplicates
 */
type ConnectMessage = (httpMethod: string, path: string, headers: headers_t, payload: string) => void;
/**
 * Organises connections to broker
 * This is part of the http based mqtt broker. Use this class to connect/disconnect and subscribe/unsubscribe to the broker
 * All functions are based on async/promises
 */
export declare class Connect {
    private clientId;
    private nextPacketId;
    private callbacks;
    /**
     * @param {string} clientId id of this client
     */
    constructor(clientId: string);
    /**
     * Sets a callback.
     * @param {string} event event name (not case sensitive) for the callback
     * @param {function} callback(parameter)
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on(event: string, callback: ConnectMessage): void;
    /**
     * @private
     * @description
     * Sends an object via put as application/json message
     * @param {string} path path for the http PUT
     * @param {Object} payload data to be transported via. PUT
     * @returns {Object} received answer
     */
    private send;
    /**
     * @private
     * @description
     * provides a new packet id
     * @returns {number} "nearly unique" packet id (between 0 .. 65536)
     */
    private providePacketId;
    /**
     * @private
     * @description
     * Extracts the error message from an error
     * @param {string|Error|any} err
     * @returns {string} error message
     */
    private getMessage;
    /**
     * Connects to the broker
     * @param {boolean} clean true, if a disconnect shall clean any connection information
     * @param {string} [version='1.0'] interface version (0.0 or 1.0)
     * @param {number} [keepAlive=600000] time in milliseconds the broker will keep the connection without receiving calls
     * @returns {string} connection token
     */
    connect(version: string | undefined, options: IConnectOptions): Promise<IConnectResult>;
    /**
     * Disconnects from the broker
     * @param {string} [version='1.0'] interface version (0.0 or 1.0)
     * @returns {Object} empty object
     */
    disconnect(version?: string): Promise<void>;
    /**
     * Subscribe to the broker
     * @param {Object} topics topics to subscribe to {topic1: QoS1, topic2: QoS2, ...}
     * @param {string} [version='1.0'] interface version (0.0 or 1.0)
     * @returns {Object} payload returned from subscribe request
     */
    subscribe(version: string | undefined, topics: topics_t): Promise<SubscribeResult>;
    /**
     * Unsubscribes from the broker
     * @param {Array} topics topics to unsubscribe [topic1, topic2, ...]
     * @param {string} [version='1.0'] interface version (0.0 or 1.0)
     * @returns {Object} empty object
     */
    unsubscribe(version: string | undefined, topics: topics_t): Promise<UnsubscribeResult>;
    /**
     * Sends a ping request to signal the client is alive
     * @returns {boolean} true on success
     */
    pingreq(token: string): Promise<void>;
    /**
     * First connect, then subscribe
     * @param {boolean} clean true, if a disconnect shall clean any connection information
     * @param {Object} topics topics to subscribe to {topic1: QoS1, topic2: QoS2, ...}
     * @param {string} [version='1.0'] interface version (0.0 or 1.0)
     * @param {number} [keepAlive=600000] time in milliseconds the broker will keep the connection without receiving calls
     * @returns {Object} combined result from connect and subscribe
     */
    connectAndSubscribe(version: string | undefined, topics: topics_t, connectOptions: IConnectOptions): Promise<{
        connectResult: IConnectResult;
        subscribeResult: SubscribeResult;
    }>;
}
export {};
