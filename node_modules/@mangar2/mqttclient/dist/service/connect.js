"use strict";
/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview Provides functions to connect to the (http based) yaha mqtt broker
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connect = void 0;
const httpservice_1 = require("@mangar2/httpservice");
const mqtt_utils_1 = require("@mangar2/mqtt-utils");
const utils_1 = require("@mangar2/utils");
const os_1 = __importDefault(require("os"));
/**
 * @private
 * @description
 * Gets the IP v4 address of the current device
 * @returns {string} IP v4 address
 */
function getIPv4Address() {
    const networkInterfaces = os_1.default.networkInterfaces();
    for (const network of Object.values(networkInterfaces)) {
        if (!network)
            continue;
        for (const info of network) {
            if (info.family === 'IPv4' && !info.internal) {
                return info.address;
            }
        }
    }
    return 'localhost';
}
/**
 * Organises connections to broker
 * This is part of the http based mqtt broker. Use this class to connect/disconnect and subscribe/unsubscribe to the broker
 * All functions are based on async/promises
 */
class Connect {
    /**
     * @param {string} clientId id of this client
     * @param {string} brokerHost hostname (or ip) of the broker
     * @param {number} brokerPort port of the broker
     * @param {number} listenerPort port to listen for published messages from broker
     * @example
     * let connect = new Connect("/connect/test", "127.0.0.1", 9001, 9002);
     * result = await connect.connect(CLEAN);
     */
    constructor(clientId, brokerHost, brokerPort, listenerPort) {
        this.clientId = clientId;
        this.listenerPort = listenerPort;
        this.myAddress = getIPv4Address();
        this._isConnected = false;
        this.client = new httpservice_1.HttpClient(brokerHost, brokerPort);
        this.nextPacketId = 1;
        this.callbacks = new utils_1.Callbacks();
        this.on('send', async (path, httpMethod, payload, headers) => {
            return this.client.send(path, httpMethod, payload, headers);
        });
    }
    /**
     * True, if the client is connected
     * @type {boolean}
     */
    get isConnected() { return this._isConnected; }
    set isConnected(isConnected) { this._isConnected = isConnected; }
    /**
     * Gets/Sets send and receive token
     * @type {{send:string, receive:string}} token
     */
    get token() { return this._token; }
    set token(token) { this._token = token; }
    /**
     * Sets a callback.
     * @param {string} event event name (not case sensitive) for the callback
     * @param {function} callback(parameter)
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on(event, callback) { this.callbacks.on(event, callback); }
    /**
     * @private
     * @description
     * provides a new packet id
     * @returns {number} "nearly unique" packet id (between 0 .. 65536)
     */
    providePacketId() {
        return this.nextPacketId = (this.nextPacketId % 0xFFFF) + 1;
    }
    /**
     * @private
     * @description
     * Sends an object via put as application/json message
     * @param {string} path path for the http PUT
     * @param {Object} payload data to be transported via. PUT
     * @returns {Object} received answer
     */
    async send(path, headers, payload) {
        return this.callbacks.invokeCallbackAsync('send', path, 'put', payload, headers);
    }
    /**
     * Connects to the broker
     * @param {boolean} clean true, if a disconnect shall clean any connection information
     * @param {string} [version='1.0'] interface version (0.0 or 1.0)
     * @param {number} [keepAlive=600000] time in milliseconds the broker will keep the connection without receiving calls
     * @returns {Object} payload returned from connect request
     */
    async connect(clean, version = '1.0', keepAlive = 600 * 1000) {
        const httpObjects = mqtt_utils_1.Interfaces.connect(version, {
            clientId: this.clientId, host: this.myAddress, port: this.listenerPort, clean, keepAlive
        });
        const result = await this.send('/connect', httpObjects.headers, httpObjects.payload);
        if (!httpObjects.resultCheck(result)) {
            throw new Error(`Unable to connect status code: ${result.statusCode} ${JSON.stringify(result.headers)}`);
        }
        this.isConnected = true;
        if (result.headers['content-type'].startsWith('application/json')) {
            result.payload = JSON.parse(result.payload);
        }
        if (version >= '1.0') {
            this.token = result.payload.token;
        }
        return result.payload;
    }
    /**
     * Disconnects from the broker
     * @param {string} [version='1.0'] interface version (0.0 or 1.0)
     * @returns {Object} empty object
     */
    async disconnect(version = '1.0') {
        const httpObjects = mqtt_utils_1.Interfaces.disconnect(version, this.clientId);
        const result = await this.send('/disconnect', httpObjects.headers, httpObjects.payload);
        if (!httpObjects.resultCheck(result)) {
            throw new Error(`Unable to disconnect status code: ${result.statusCode}`);
        }
        this._isConnected = false;
        return {};
    }
    /**
     * Subscribe to the broker
     * @param {Object} topics topics to subscribe to {topic1: QoS1, topic2: QoS2, ...}
     * @param {string} [version='1.0'] interface version (0.0 or 1.0)
     * @returns {Object} payload returned from subscribe request
     */
    async subscribe(topics, version = '1.0') {
        const httpObjects = mqtt_utils_1.Interfaces.subscribe(version, topics, this.clientId, this.providePacketId());
        const result = await this.send('/subscribe', httpObjects.headers, httpObjects.payload);
        const headers = result.headers;
        if (!httpObjects.resultCheck(result)) {
            throw new Error(`Unable to subscribe status code: ${result.statusCode} headers: ${JSON.stringify(headers)}`);
        }
        if (headers['content-type'].startsWith('application/json')) {
            result.payload = JSON.parse(result.payload);
        }
        return result.payload;
    }
    /**
     * Unsubscribes from the broker
     * @param {Array} topics topics to unsubscribe [topic1, topic2, ...]
     * @param {string} [version='1.0'] interface version (0.0 or 1.0)
     * @returns {Object} empty object
     */
    async unsubscribe(topics, version = '1.0') {
        const httpObjects = mqtt_utils_1.Interfaces.unsubscribe(version, topics, this.clientId, this.providePacketId());
        const result = await this.send('/unsubscribe', httpObjects.headers, httpObjects.payload);
        if (!httpObjects.resultCheck(result)) {
            throw new Error(`Unable to unsubscribe status code: ${result.statusCode}`);
        }
        return {};
    }
    /**
     * Sends a ping request to signal the client is alive
     * @returns {boolean} true on success
     */
    async pingreq() {
        var _a;
        const payload = { token: (_a = this.token) === null || _a === void 0 ? void 0 : _a.send };
        const headers = { 'content-type': 'application/json; charset=UTF-8' };
        const result = await this.send('/pingreq', headers, payload);
        return result.statusCode === 204 && result.headers.packet === 'pingresp';
    }
    /**
     * First connect, then subscribe
     * @param {boolean} clean true, if a disconnect shall clean any connection information
     * @param {Object} topics topics to subscribe to {topic1: QoS1, topic2: QoS2, ...}
     * @param {string} [version='1.0'] interface version (0.0 or 1.0)
     * @param {number} [keepAlive=600000] time in milliseconds the broker will keep the connection without receiving calls
     * @returns {Object} combined result from connect and subscribe
     */
    async connectAndSubscribe(clean, topics, version = '1.0', keepAlive = 600 * 1000) {
        let result = await this.connect(clean, version, keepAlive);
        if (this.isConnected) {
            const subscribeResult = await this.subscribe(topics, version);
            result = { ...result, ...subscribeResult };
        }
        return result;
    }
    /**
     * Closes the connection to the broker
     */
    async close() {
        await this.client.close();
    }
}
exports.Connect = Connect;
//# sourceMappingURL=connect.js.map