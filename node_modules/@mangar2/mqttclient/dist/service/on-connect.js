"use strict";
/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * Helping functions to send mqtt data
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OnConnect = void 0;
const utils_1 = require("@mangar2/utils");
const mqtt_utils_1 = require("@mangar2/mqtt-utils");
const checkinput_1 = __importDefault(require("@mangar2/checkinput"));
const checkdefinitions_1 = require("./checkdefinitions");
class OnConnect {
    constructor(mqttServer) {
        this.mqttServer = mqttServer;
        this._callbacks = new utils_1.Callbacks(['connect', 'disconnect', 'subscribe', 'unsubscribe', 'pingreq']);
    }
    /**
     * Validates the connect parameter and returns the validated object
     * @param {string} payload payload provided for connect
     * @returns validated connection options
     */
    HttpToConnectOptions(headers, payload) {
        const result = JSON.parse(payload);
        const checkConnectPayload = new checkinput_1.default({
            type: 'object',
            properties: {
                clientId: { type: 'string' },
                host: { type: 'string' },
                port: { type: ['integer'] },
                clean: { enum: ['true', 'false', true, false] },
                keepAlive: { type: ['number', 'string'] },
                password: { type: 'string' },
                user: { type: 'string' },
                will: {
                    type: 'object',
                    properties: ''
                }
            },
            required: ['clientId', 'host', 'port', 'clean']
        });
        checkConnectPayload.throwOnValidationError(result, 'Connect error: wrong parameters');
        result.qos = headers.qos === '0' ? 0 : headers.qos === '2' ? 2 : 1;
        result.version = utils_1.Types.isString(headers.version) ? headers.version : '0.0';
        return result;
    }
    /**
     * Registers a callback for a specific event.
     * @param {string} event - The event name.
     * @param {ProcessMessage} callback - The callback to be invoked.
     */
    on(event, callback) {
        this._callbacks.on(event, callback);
    }
    /**
     * Handles incoming server requests.
     * @param {string} path - The request path.
     * @param {headers_t} headers - The headers of the request.
     * @param {string} payload - The payload of the request.
     * @param {ServerResponse} res - The response object.
     */
    handleHttpRequest(path, headers, payload) {
        switch (path) {
            case '/connect':
                return this.onConnect(headers, payload);
            case '/disconnect':
                return this.onDisconnect(headers, JSON.parse(payload));
            case '/subscribe':
                return this.onSubscribe(headers, JSON.parse(payload));
            case '/subscribe':
                return this.onUnsubscribe(headers, JSON.parse(payload));
            case '/pingreq':
                return this.onPingreq(JSON.parse(payload));
            default:
                throw new Error('Illegal interface ' + path);
        }
    }
    /**
     * @private
     * @description
     * Connects a client to the broker, storing the connection informations
     * @param {Object} payload payload {clientId, host, port, clean, will}
     * @param {string} payload.clientId id of the connecting client
     * @param {string} payload.host host name (or ip) of the client
     * @param {number} payload.port port number
     * @param {boolean} payload.clean true, if the session shall be cleaned
     * @param {number} payload.keepAlive timeout in milliseconds for disconnecting
     * if no message is transmitted
     * @param {string} payload.password connection password
     * @param {string} payload.user connection user name
     * @param {IMessage} payload.will message to be send on connection loss
     * @param {Object} headers received headers
     * @param {string} headers.version interface version
     * @returns {httpReturn} http return information
     */
    onConnect(headers, payload) {
        const connectOptions = this.HttpToConnectOptions(headers, payload);
        const connectResult = this.mqttServer.connect(connectOptions);
        const result = mqtt_utils_1.Interfaces.onConnect(headers, connectResult);
        return result;
    }
    /**
     * @private
     * @description
     * disconnects a client from the broker
     * @param {Object} payload
     * @param {string} payload.clientId Id of the client to disconnect
     * @param {Object} headers received headers
     * @param {string} headers.version interface version
     * @returns {httpReturn} http return information
     */
    onDisconnect(headers, payload) {
        checkdefinitions_1.checkDisconnectPayload.throwOnValidationError(payload, 'Disconnect wrong parameters (' + payload.clientId + '): ');
        this._callbacks.invokeCallback('disconnect', headers, payload);
        const result = mqtt_utils_1.Interfaces.onDisconnect(headers);
        // this.publishLogMessage('disconnect', 'success', 'client request', payload.clientId)
        return result;
    }
    /**
     * @private
     * @description
     * Subscribes to topics
     * @param {Object} payload {clientId, topics}
     * @param {Object} headers received headers
     * @param {number} headers.packetid id of the packet
     * @param {string} headers.version interface version
     * @returns {httpReturn} http return information
     */
    onSubscribe(headers, payload) {
        checkdefinitions_1.checkSubscribePayload.throwOnValidationError(payload, 'Subscribe wrong parameters (' + payload.clientId + '): ');
        const qos = this._callbacks.invokeCallback('subscribe', headers, payload);
        const result = mqtt_utils_1.Interfaces.onSubscribe(headers, qos);
        return result;
    }
    /**
     * @private
     * @description
     * Unsubscribes to topics
     * @param {Object} payload {clientId, topics}
     * @param {string} payload.clientId id of the connecting client
     * @param {string[]} payload.topics topics to subscribe to
     * @param {Object} headers received headers
     * @param {string} headers.version interface version
     * @returns {httpReturn} http return information
     */
    onUnsubscribe(headers, payload) {
        checkdefinitions_1.checkUnsubscribePayload.throwOnValidationError(payload, 'Unsubscribe wrong parameters (' + payload.clientId + '): ');
        this._callbacks.invokeCallback('unsubscribe', headers, payload);
        //this.publishLogMessage('unsubscribe', 'success', 'client request', payload.clientId)
        const result = mqtt_utils_1.Interfaces.onUnsubscribe(headers);
        return result;
    }
    /**
     * @private
     * @description
     * Answers to a ping
     * @param {Object} payload http call payload
     * @param {string} payload.token
     * @returns {httpReturn} http return information
     */
    onPingreq(payload) {
        this._callbacks.invokeCallback('pingreq', payload);
        const result = {
            headers: { 'Content-Type': 'application/json', packet: 'pingresp' },
            payload: '',
            statusCode: 204
        };
        return result;
    }
}
exports.OnConnect = OnConnect;
//# sourceMappingURL=on-connect.js.map