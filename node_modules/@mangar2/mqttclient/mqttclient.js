/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      mqttversion.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

'use strict'

const MqttService = require('@mangar2/mqttservice')
const Connect = require('@mangar2/connect')
const TopicMatch = require('@mangar2/topicmatch')
const errorLog = require('@mangar2/errorlog')
const shutdown = require('@mangar2/shutdown')

class MqttClient {
    /**
     * @public
     * Creates a standard mqtt client, connects and subscribes to the broker
     * @param {object} options options to provide for connection
     * @param {string} options.clientId unique id of the client
     * @param {object} options.broker information of the broker to connect to
     * @param {string} options.broker.host hostname of the broker
     * @param {number} options.broker.port port of the broker
     * @param {number} options.listener port this client will listen to
     * @param {string} [options.version='1.0'] interface version
     * @param {number} options.retry amount of retries to send messages to the broker
     */
    constructor (options) {
        const { clientId, broker, listener } = options
        this._connect = new Connect(clientId, broker.host, broker.port, listener)
        this._server = new MqttService.OnPublish(listener)
        this._recipients = []
        this._client = new MqttService.Publish(broker.host, broker.port, options)
        this._version = options.version || '1.0'
        this._clean = options.clean || true

        this._server.on('publish', (message, qos, dup) => {
            for (const recipient of this._recipients) {
                if (recipient.topics.getFirstMatch(message.topic)) {
                    const returnMessage = recipient.callback(message)
                    if (returnMessage !== undefined) {
                        this._client.publish(returnMessage.token, returnMessage, qos, false, this._version)
                    }
                }
            }
        })

        shutdown(async () => {
            await this._connect.disconnect(this._version)
            await this._server.close()
        })
    }

    async run () {
        try {
            this._server.listen()
            await this._connect.connect(this._clean, this._version)
        } catch (error) {
            errorLog(error)
        }
    }

    /**
     * Registeres a recipient
     * @param {object} subscriptions subscription entries of format {topic:qos, topic:qos, ...}
     * @param {function} callback function to send received messages to
     * @param {string} [version='1.0'] Interface version
     * @throws {Error} If subscriptions are not well formatted or callback is not a function
     */
    async registerRecipient (subscriptions, callback) {
        try {
            if (typeof (callback) !== 'function') {
                throw Error('A callback function must be provided for registerRecipient')
            }
            await this._connect.subscribe(subscriptions, this._version)
            this._recipients.push({ topics: new TopicMatch(subscriptions), callback })
        } catch (error) {
            errorLog(error)
        }
    }
}

module.exports = MqttClient
