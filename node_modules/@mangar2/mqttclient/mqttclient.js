/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      mqttversion.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

'use strict'

const MqttService = require('@mangar2/mqttservice')
const Connect = require('@mangar2/connect')
const TopicMatch = require('@mangar2/topicmatch')
const DEBUG = true
const errorLog = (error) => { require('@mangar2/errorlog')(error, DEBUG) }
const shutdown = require('@mangar2/shutdown')
const LogFilter = require('@mangar2/logfilter')

/**
 * @typedef {object} LogPattern
 * @property {string} pattern log topic pattern
 * @property {string} module module to log, "send", "receive" or "all" (for all modules)
 * @property {number} level log level for the pattern
 */

/**
 * Pauses the execution for a while (needs to "wait") for the result.
 * @param {number} timeInMilliseconds delay in milliseconds
 */
function delay (timeInMilliseconds) {
    return new Promise(resolve => setTimeout(resolve, timeInMilliseconds))
}

class MqttClient {
    /**
     * @public
     * Creates a standard mqtt client, connects and subscribes to the broker
     * @param {object} options options to provide for connection
     * @param {string} options.clientId unique id of the client
     * @param {object} options.broker information of the broker to connect to
     * @param {string} options.broker.host hostname of the broker
     * @param {number} options.broker.port port of the broker
     * @param {number} options.listener port this client will listen to
     * @param {string} [options.version='1.0'] interface version
     * @param {string} [options.keepAliveInSeconds] connection keep alive time in seconds
     * @param {number} options.retry amount of retries to send messages to the broker
     * @param {LoPattern[]} options.log
     */
    constructor (options) {
        const { clientId, broker, listener } = options
        this._connect = new Connect(clientId, broker.host, broker.port, listener)
        this._server = new MqttService.OnPublish(listener)
        this._recipients = []
        this._client = new MqttService.Publish(broker.host, broker.port, options)
        this.version = options.version || '1.0'
        this._running = false
        this.connected = false
        this._logFilter = new LogFilter()
        this._logFilter.changePattern(options.log)

        if (!isNaN(options.keepAliveInSeconds)) {
            this._keepAlive = options.keepAliveInSeconds * 1000
        }
        this._clean = options.clean || true
        this._initCallbacks()
    }

    /**
     * Initializes the callbaks for "on publish" and "shutdown"
     */
    _initCallbacks () {
        this._server.on('publish', async (message, qos, dup) => {
            this._logFilter.condLogMessage('received', message, qos, dup)
            for (const recipient of this._recipients) {
                const topicMatch = new TopicMatch(recipient.subscriptions)
                if (topicMatch.getFirstMatch(message.topic) !== undefined) {
                    const returnMessage = await recipient.callback(message)
                    if (Array.isArray(returnMessage)) {
                        for (const entry of returnMessage) {
                            this.publish(entry, qos)
                        }
                    } else if (returnMessage !== undefined) {
                        this.publish(returnMessage, qos)
                    }
                }
            }
        })

        shutdown(async () => {
            try {
                this._running = false
                await this._connect.disconnect(this.version)
                await this._server.close()
            } catch (error) {
                errorLog(error)
            }
        })
    }

    /**
     * Gets/Sets token
     * @type token
     * @property {string} token.send send token
     * @property {string} token.receive receive token
     */
    get token () { return this._token }
    set token (token) { this._token = token }

    /**
     * Gets/Sets connection status
     * @type {boolean} true, iff connected
     */
    get connected () { return this._connected }
    set connected (connected) { this._connected = connected }

    /**
     * Gets/Sets the interface version to use
     * @type {string} version number as string
     */
    get version () { return this._version }
    set version (version) { this._version = version }

    /**
     * Publishes a message to the broker
     * @param {Message} message message to publish
     * @param {number} qos quality of service (0,1,2)
     */
    publish (message, qos) {
        this._logFilter.condLogMessage('send', message, qos, false)
        this._client.publish(this.token.send, message, qos, false, this.version)
    }

    /**
     * Starts the mqttclient. Opens the listener and connects to the broker
     */
    async run () {
        try {
            this._server.listen()
            await this.reconnect()
            this._running = true
            this._keepConnected()
        } catch (error) {
            errorLog(error)
        }
    }

    /**
     * Connects and subscribes to the broker
     */
    async reconnect () {
        try {
            const result = await this._connect.connect(this._clean, this.version, this._keepAlive)
            this.connected = true
            this.token = result.token
            for (const recipient of this._recipients) {
                const subscriptions = recipient.subscriptions
                const subscribe = await this._connect.subscribe(subscriptions, this.version)
                const errorPosition = subscribe.qos.indexOf(127)
                if (errorPosition > -1) {
                    throw 'subscribe failed at postion: ' + errorPosition
                }
            }
        } catch (error) {
            this.connected = false
            errorLog(error)
        }
    }

    /**
     * Registeres a recipient
     * @param {object} subscriptions subscription entries of format {topic:qos, topic:qos, ...}
     * @param {function} callback function to send received messages to
     * @param {string} [version='1.0'] Interface version
     * @throws {Error} If subscriptions are not well formatted or callback is not a function
     */
    async registerRecipient (subscriptions, callback) {
        try {
            if (typeof (callback) !== 'function') {
                throw Error('A callback function must be provided for registerRecipient')
            }
            this._recipients.push({ subscriptions, callback })
            if (this.connected) {
                await this._connect.subscribe(subscriptions, this.version)
            }
        } catch (error) {
            errorLog(error)
        }
    }

    /**
     * Ensures that the system stayes connected with the broker
     */
    async _keepConnected () {
        while (this._running) {
            try {
                if (this.version === '0.0' || !this.connected) {
                    this.reconnect()
                } else {
                    this.connected = await this._connect.pingreq()
                }
            } catch (error) {
                this.connected = false
                errorLog(error)
            }
            if (!this.connected) {
                await delay(1000)
            } else {
                await delay(this._keepAlive / 3)
            }
        }
    }
}

module.exports = MqttClient
