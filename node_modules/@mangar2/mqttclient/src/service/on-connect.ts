/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * Helping functions to send mqtt data
 */

import { Callbacks, Types } from '@mangar2/utils';
import { IResult, topics_t, Interfaces, IConnectOptions } from '@mangar2/mqtt-utils';
import { IMqttServer } from './i-mqtt-server';
import { headers_t } from './types';
import  CheckInput from '@mangar2/checkinput';

import {
    checkSubscribePayload,
    checkUnsubscribePayload
} from './checkdefinitions';



/**
 * @callback ProcessRequest
 * @param message the message received
 * @param dup flag signaling duplicates
 */
type ProcessMessage = (headers: headers_t, payload: string) => void;


export class OnConnect {
    private _callbacks: Callbacks = new Callbacks(['connect', 'disconnect', 'subscribe', 'unsubscribe', 'pingreq']);

    constructor(private mqttServer: IMqttServer) {
    }

    /**
     * Validates the connect parameter and returns the validated object
     * @param {string} payload payload provided for connect
     * @returns validated connection options
     */
    HttpToConnectOptions(headers: headers_t, payload: string): IConnectOptions {
        const result: IConnectOptions = JSON.parse(payload);
        const checkConnectPayload = new CheckInput({
            type: 'object',
            properties: {
                clientId: { type: 'string' },
                host: { type: 'string' },
                port: { type: ['integer'] },
                clean: { enum: ['true', 'false', true, false] },
                keepAlive: { type: ['number', 'string'] },
                password: { type: 'string' },
                user: { type: 'string' },
                will: {
                    type: 'object',
                    properties: ''
                }
            },
            required: ['clientId', 'host', 'port', 'clean']
        })
        checkConnectPayload.throwOnValidationError(result, 'Connect error: wrong parameters');
        result.qos = headers.qos === '0' ? 0 : headers.qos === '2' ? 2 : 1;
        result.version = Types.isString(headers.version) ? headers.version : '0.0';
        return result;
    }

    /**
     * Registers a callback for a specific event.
     * @param {string} event - The event name.
     * @param {ProcessMessage} callback - The callback to be invoked.
     */
    on(event: string, callback: ProcessMessage): void {
        this._callbacks.on(event, callback);
    }

    /**
     * Handles incoming server requests.
     * @param {string} path - The request path.
     * @param {headers_t} headers - The headers of the request.
     * @param {string} payload - The payload of the request.
     * @param {ServerResponse} res - The response object.
     */
    public handleHttpRequest(path: string, headers: headers_t, payload: string): IResult {
        switch (path) {
            case '/connect':
                return this.onConnect(headers, payload);
            case '/disconnect':
                return this.onDisconnect(headers, JSON.parse(payload));
            case '/subscribe':
                return this.onSubscribe(headers, JSON.parse(payload));
            case '/subscribe':
                return this.onUnsubscribe(headers, JSON.parse(payload));
            case '/pingreq':
                return this.onPingreq(JSON.parse(payload));
            default:
                throw new Error('Illegal interface ' + path);
        }
    }



    /**
     * @private
     * @description
     * Connects a client to the broker, storing the connection informations
     * @param {Object} payload payload {clientId, host, port, clean, will}
     * @param {string} payload.clientId id of the connecting client
     * @param {string} payload.host host name (or ip) of the client
     * @param {number} payload.port port number
     * @param {boolean} payload.clean true, if the session shall be cleaned
     * @param {number} payload.keepAlive timeout in milliseconds for disconnecting
     * if no message is transmitted
     * @param {string} payload.password connection password
     * @param {string} payload.user connection user name
     * @param {IMessage} payload.will message to be send on connection loss
     * @param {Object} headers received headers
     * @param {string} headers.version interface version
     * @returns {httpReturn} http return information
     */
    private onConnect(headers: headers_t, payload: string): IResult {
        const connectOptions = this.HttpToConnectOptions(headers, payload);
        const connectResult = this.mqttServer.connect(connectOptions);
        const result = Interfaces.onConnect(headers, connectResult)
        return result
    }

    /**
     * @private
     * @description
     * disconnects a client from the broker
     * @param {Object} payload
     * @param {string} payload.clientId Id of the client to disconnect
     * @param {Object} headers received headers
     * @param {string} headers.version interface version
     * @returns {httpReturn} http return information
     */
    private onDisconnect(headers: headers_t, payload: string): IResult {
        const disconnectOptions = JSON.parse(payload);
        if (!Types.isObject(disconnectOptions)) {
            throw new Error('Disconnect error: wrong payload format')
        }
        if (!Types.isString(disconnectOptions.clientId) || disconnectOptions.clientId === '') {
            throw new Error('Disconnect error: missing clientId');
        }
        this.mqttServer.disconnect(disconnectOptions);
        const result = Interfaces.onDisconnect(headers)

        // this.publishLogMessage('disconnect', 'success', 'client request', payload.clientId)
        return result
    }

    /**
     * @private
     * @description
     * Subscribes to topics
     * @param {Object} payload {clientId, topics}
     * @param {Object} headers received headers
     * @param {number} headers.packetid id of the packet
     * @param {string} headers.version interface version
     * @returns {httpReturn} http return information
     */
    private onSubscribe(headers: headers_t, payload: { clientId: string, topics: topics_t, subscribe: topics_t }): IResult {
        checkSubscribePayload.throwOnValidationError(
            payload, 'Subscribe wrong parameters (' + payload.clientId + '): ')

        const qos = this._callbacks.invokeCallback('subscribe', headers, payload);
        const result = Interfaces.onSubscribe(headers, qos)

        return result
    }

    /**
     * @private
     * @description
     * Unsubscribes to topics
     * @param {Object} payload {clientId, topics}
     * @param {string} payload.clientId id of the connecting client
     * @param {string[]} payload.topics topics to subscribe to
     * @param {Object} headers received headers
     * @param {string} headers.version interface version
     * @returns {httpReturn} http return information
     */
    private onUnsubscribe(headers: headers_t, payload: { clientId: string, topics: topics_t }): IResult {
        checkUnsubscribePayload.throwOnValidationError(
            payload, 'Unsubscribe wrong parameters (' + payload.clientId + '): ')

        this._callbacks.invokeCallback('unsubscribe', headers, payload);
        //this.publishLogMessage('unsubscribe', 'success', 'client request', payload.clientId)

        const result = Interfaces.onUnsubscribe(headers)

        return result
    }

    /**
     * @private
     * @description
     * Answers to a ping
     * @param {Object} payload http call payload
     * @param {string} payload.token
     * @returns {httpReturn} http return information
     */
    private onPingreq(payload: { token: string }): IResult {
        this._callbacks.invokeCallback('pingreq', payload);

        const result = {
            headers: { 'Content-Type': 'application/json', packet: 'pingresp' },
            payload: '',
            statusCode: 204
        }
        return result
    }

}
