/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * Helping functions to send mqtt data
 */

import { Types } from '@mangar2/utils';
import { IResult, IMessage, qos_t, topics_t, Interfaces } from '@mangar2/mqtt-utils';
import { IMqttServer } from './i-mqtt-server';
import { headers_t } from './types';

import { 
    checkConnectPayload, 
    checkDisconnectPayload,
    checkSubscribePayload,
    checkUnsubscribePayload
} from './checkdefinitions';


interface IMqttHeaders {
    qos: qos_t;
    dup: boolean;
    packetid: number;
    retain: boolean;
    version: string;
}

interface IConnectPayload {
    clientId: string;
    host: string;
    port: number;
    clean: boolean;
    keepAlive: number;
    password: string;
    user: string;
    will: IMessage;
}


export class OnConnect { 

    constructor(private server: IMqttServer) {     
    }

    /**
     * Translates http headers to mqtt headers
     * @param headers headers of the call
     * @returns parsed headers
     */
    private headersToMqttHeaders(headers: headers_t): IMqttHeaders {
        return {
            qos: headers.qos === '1' ? 1 : (headers.qos === '2' ? 2 : 0),
            dup: headers.dup === '1' || headers.dup === 'true',
            packetid: !Types.isString(headers.packetid) ? 0 : parseInt(headers.packetid),
            retain: headers.retain === '1' || headers.retain === 'true',
            version: Types.isString(headers.version) ?  headers.version : '0.0'
        }
    }

     /**
     * @private
     * @description
     * Receives a pubrel packages
     * @param {Object} payload publish payload
     * @param {Object} headers headers parameter {packetid}
     * @returns {Object} {headers, payload, statusCode}
     */
     onPubrel (payload: { token: string }, headers: headers_t) {
        const result = Interfaces.onPubrel(headers)
        this.server.pubrel(payload.token, result.packetid);
    }

    /**
     * @private
     * @description
     * Connects a client to the broker, storing the connection informations
     * @param {Object} payload payload {clientId, host, port, clean, will}
     * @param {string} payload.clientId id of the connecting client
     * @param {string} payload.host host name (or ip) of the client
     * @param {number} payload.port port number
     * @param {boolean} payload.clean true, if the session shall be cleaned
     * @param {number} payload.keepAlive timeout in milliseconds for disconnecting
     * if no message is transmitted
     * @param {string} payload.password connection password
     * @param {string} payload.user connection user name
     * @param {IMessage} payload.will message to be send on connection loss
     * @param {Object} headers received headers
     * @param {string} headers.version interface version
     * @returns {httpReturn} http return information
     */
    onConnect (payload: IConnectPayload, headers: headers_t): IResult {
        const { version } = this.headersToMqttHeaders(headers)
        if (Types.isString(payload.port)) {
            payload.port = parseInt(payload.port)
        }
        checkConnectPayload.throwOnValidationError(
            payload, 'Connect wrong parameters (' + payload.clientId + '): ')
        const { clientId, host, port, clean, password, user, will } = payload
        const keepAlive = payload.keepAlive > 0;

        if (this.server.login(user, password)) {
            throw Error('Could not login')
        }
        const connect = this.server.connect(clientId, host, port, clean, version, will, keepAlive);
        if (connect.statusCode !== 0) {
            throw Error('Could not connect (code: ' + connect.statusCode + ')')
        }
        const result = Interfaces.onConnect(headers, { present: connect.present, token: connect.token.send })
        // this.publishLogMessage('connect', 'success', 'client request', payload.clientId)
        return result
    }

    /**
     * @private
     * @description
     * disconnects a client from the broker
     * @param {Object} payload
     * @param {string} payload.clientId Id of the client to disconnect
     * @param {Object} headers received headers
     * @param {string} headers.version interface version
     * @returns {httpReturn} http return information
     */
    onDisconnect (payload: { clientId: string }, headers: headers_t): IResult {
        checkDisconnectPayload.throwOnValidationError(
            payload, 'Disconnect wrong parameters (' + payload.clientId + '): ')
        this.server.disconnect(payload.clientId);
        const result = Interfaces.onDisconnect(headers)
        // this.publishLogMessage('disconnect', 'success', 'client request', payload.clientId)
        return result
    }

    /**
     * @private
     * @description
     * Subscribes to topics
     * @param {Object} payload {clientId, topics}
     * @param {Object} headers received headers
     * @param {number} headers.packetid id of the packet
     * @param {string} headers.version interface version
     * @returns {httpReturn} http return information
     */
    onSubscribe (payload: { clientId: string, topics: topics_t, subscribe: topics_t }, headers: headers_t): IResult {
        checkSubscribePayload.throwOnValidationError(
            payload, 'Subscribe wrong parameters (' + payload.clientId + '): ')

        const qos = this.server.subscribe(payload.clientId, payload.subscribe === undefined ? payload.topics : payload.subscribe)
         // this.publishLogMessage('subscribe', 'success', 'client request', payload.clientId)

        const result = Interfaces.onSubscribe(headers, qos)
        return result
    }

    /**
     * @private
     * @description
     * Unsubscribes to topics
     * @param {Object} payload {clientId, topics}
     * @param {string} payload.clientId id of the connecting client
     * @param {string[]} payload.topics topics to subscribe to
     * @param {Object} headers received headers
     * @param {string} headers.version interface version
     * @returns {httpReturn} http return information
     */
    onUnsubscribe (payload: { clientId: string, topics: topics_t }, headers: headers_t): IResult {
        checkUnsubscribePayload.throwOnValidationError(
            payload, 'Unsubscribe wrong parameters (' + payload.clientId + '): ')

        this.server.unsubscribe(payload.clientId, payload.topics);    
        //this.publishLogMessage('unsubscribe', 'success', 'client request', payload.clientId)

        const result = Interfaces.onUnsubscribe(headers)

        return result
    }

    /**
     * @private
     * @description
     * Answers to a ping
     * @param {Object} payload http call payload
     * @param {string} payload.token
     * @returns {httpReturn} http return information
     */
    onPingreq (payload: { token: string }): IResult {
        const statusCode = this.server.pingreq(payload.token);
        // this.publishLogMessage('ping', 'success', 'client request', client.clientId)

        const result = {
            headers: { 'Content-Type': 'application/json', packet: 'pingresp' },
            payload: '',
            statusCode: statusCode
        }
        return result
    }

}
