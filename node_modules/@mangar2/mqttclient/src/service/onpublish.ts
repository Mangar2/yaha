/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2023 Volker Böhm
 */
import { HttpServer as Server, ServerResponse, IncomingHttpHeaders } from '@mangar2/httpservice';
import { Message, Interfaces, LogFilter, LogPattern } from '@mangar2/mqtt-utils';
import { Callbacks, Types } from '@mangar2/utils';

type LogSettings = any; // Define the type for log settings according to its structure

interface Qos2QueueEntry {
    time: number;
    topic: string;
}

/**
 * @callback ProcessMessage
 * @param message the message received
 * @param qos the quality of service information
 * @param dup flag signaling duplicates
 */
type ProcessMessage = (message: object, qos: 0 | 1 | 2, dup: 0 | 1) => void;

export class OnPublish {
    public _logFilter: LogFilter;
    private _server: Server;
    private _callbacks: Callbacks;
    private _qos2Queue: { [packetid: string]: Qos2QueueEntry } = {};
    private _qos2PubrelTimeoutInMilliseconds: number;

    constructor(listenerPort: number, logSettings: LogSettings, qos2PubrelTimeoutInSeconds: number = 7200) {
        this._logFilter = new LogFilter();
        this._logFilter.changePattern(logSettings);
        this._server = new Server(listenerPort);
        this._callbacks = new Callbacks(['publish']);
        this._qos2PubrelTimeoutInMilliseconds = qos2PubrelTimeoutInSeconds * 1000;

        this._server.on('PUT', (payload, headers, path, res) => {
            if (path === '/publish') {
                this.onPublish(JSON.parse(payload), headers, res)
            } else if (path === '/pubrel') {
                this.onPubrel(headers, res)
            } else if (path === '/log') {
                this.onLog(JSON.parse(payload), res)
            } else {
                throw ('illegal interface ' + path)
            }
        })
    }

    get port(): number | undefined { 
        return this._server.address ? this._server.address.port : undefined;
    }

    get logFilter(): LogFilter { 
        return this._logFilter;
    }

    listen(): void {
        this._server.listen();
    }

    on(event: string, callback: ProcessMessage): void {
        this._callbacks.on(event, callback);
    }

    private deleteOldQos2QueueEntries(): void {
        const now = new Date().getTime();
        for (const entry in this._qos2Queue) {
            if (this._qos2Queue[entry].time + this._qos2PubrelTimeoutInMilliseconds < now) {
                delete this._qos2Queue[entry];
            } else {
                break;
            }
        }
    }

    onPubrel(headers: IncomingHttpHeaders, res: ServerResponse): void { // Define the type for 'res'
        const result = Interfaces.onPubrel(headers);
        if (result.packetid) {
            delete this._qos2Queue[result.packetid];
            this.deleteOldQos2QueueEntries();
        }

        res.writeHead(result.statusCode, result.headers);
        res.end(result.payload);
    }

    private rememberMessage(topic: string, packetid: string): void {
        this._qos2Queue[packetid] = { time: new Date().getTime(), topic };
    }

    onPublish(payload: any, headers: IncomingHttpHeaders, res: ServerResponse): void { // Define the types for payload, headers, and res
        const message = payload.message ? payload.message : payload;
        const messageClone = Message.createMessage(message, headers.qos, headers.retain);

        Message.validate(messageClone);
        const dup = headers.dup === '1' || headers.dup === 'true';
        const packetid = headers.version === '1.0' ? headers.packetid : headers.id;

        this.logFilter.condLogMessage('received', messageClone, dup, false);

        const qos2PacketPublishedBefore = dup && Types.isString(packetid) && this._qos2Queue[packetid] !== undefined;

        if (!qos2PacketPublishedBefore) {
            if (messageClone.qos === 2 && Types.isString(packetid)) {
                this.rememberMessage(messageClone.topic, packetid);
            }
            this._callbacks.invokeCallback('publish', messageClone, dup);
        }

        const result = Interfaces.receive(headers);

        res.writeHead(result.statusCode, result.headers);
        res.end(result.payload);
    }

    onLog(payload: LogPattern[], res: ServerResponse): void { // Define the type for 'res'
        this._logFilter.changePattern(payload);
        res.writeHead(204, { 'Content-Type': 'application/json' });
        res.end('');
    }

    close(): void {
        this._server.close();
    }
}


