/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

import { Types, delay, Callbacks } from '@mangar2/utils';
import { Message, Interfaces, IResult, RequestDataV2 } from '@mangar2/mqtt-utils';
import { headers_t } from './types';

type Configuration = {
    retry?: number;
};

/**
 * @callback PublishMessage
 * @param message the message received
 * @param qos the quality of service information
 * @param dup flag signaling duplicates
 */
export type PublishMessage = (path: string, httpMethod: string, payload: string, headers: headers_t) => void;


export class Publish {
    private topicQueues: Record<string, any> = {};
    private callbacks: Callbacks = new Callbacks(["send"]);
    private nextPacketId: number = 1;
    private retry: number;
    public terminate: boolean = false;

    /**
     * Creates an instance of PublishMessage.
     * @param {Configuration} configuration Configuration for the publisher.
     */
    constructor(configuration: Configuration) {
        this.retry = Types.isNumber(configuration.retry) ? configuration.retry : 60;
    }

    /**
     * Sets a callback.
     * @param {string} event event name (not case sensitive) for the callback
     * @param {function} callback(parameter)
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on(event: string, callback: PublishMessage): void { this.callbacks.on(event, callback); }

    /**
     * @private
     * @description
     * Sends an object via put as application/json message
     * @param {string} path path for the http PUT
     * @param {Object} payload data to be transported via. PUT
     * @returns {Object} received answer
     */
    private async send(path: string, headers: Record<string, any>, payload: any): Promise<IResult> {
        return this.callbacks.invokeCallbackAsync('send', 'put', path, headers, payload);
    }

    /**
     * Provides the next packet ID for MQTT messages.
     * @returns {number} The next packet ID.
     */
    private providePacketId(): number {
        this.nextPacketId = this.nextPacketId % 0xFFFF || 1;
        return this.nextPacketId++;
    }

    /**
     * Handles the PUBREL part of QoS 2 message flow.
     * @param {string} packetid The packet ID of the message.
     * @param {string} token Authentication token.
     * @param {string} topic The MQTT topic.
     * @returns {Promise<boolean>} True if PUBREL was successful, false otherwise.
     */
    private async pubrel(packetid: string, token: string, topic: string): Promise<boolean> {
        const sendData = Interfaces.pubrel('1.0', token, packetid);
        let errorMessage: string | undefined = undefined

        for (let retryCount = 0; retryCount < this.retry; retryCount++) {

            this.topicQueues[topic].state = 'pubrel';
            try {
                const result = await this.send('/pubrel', sendData.payload, sendData.headers);
                const sendCheck = sendData.resultCheck(result);
                errorMessage = sendCheck.error;
                if (sendCheck.success) {
                    return true;
                }
            } catch (err) {
                // success === false; No need to change anything, retry
            }
            await delay(1000 * Math.min(retryCount * retryCount, 60));
        }
        throw Error(`Error in pubrel, message: ${errorMessage ?? 'unknown error'}`);
    }

    /**
     * Retries the publishing of a message until it succeeds or max retries are reached.
     * @param {RequestDataV2} sendData Data to be sent.
     * @returns {Promise<boolean>} True if publish is successful.
     */
    private async retryPublish(sendData: RequestDataV2): Promise<boolean> {
        const { headers, payload } = sendData;
        let errorMessage: string | undefined;

        for (let retryCount = 0; retryCount < this.retry; retryCount++) {
            try {
                const result = await this.send('/publish', payload, headers);
                const sendCheck = sendData.resultCheck(result);
                errorMessage = sendCheck.error;
                if (sendCheck.success) {
                    return true;
                }
            } catch (err) {
                const sendError = err as Error;
                errorMessage = sendError.message;
                // success === false; No need to change anything, we retry
            }
            headers.dup = '1';
            await delay(1000 * Math.min(retryCount ** 2, 60));
        }

        throw Error(`Error sending message: ${errorMessage ?? ''}`);
    }

    /**
     * Sends a message with appropriate retries.
     * @param {RequestDataV2} sendData Data to be sent.
     * @returns {Promise<boolean>} True if the message was successfully sent, throws otherwise.
     */
    private async sendMessage(sendData: RequestDataV2): Promise<boolean> {
        const { headers, payload } = sendData;

        const result = await this.retryPublish(sendData);
        if (headers.qos === '2') {
            return this.pubrel(headers.packetid, payload.token, payload.message.topic);
        }
        return result;
    }

    /**
     * Publishes a message to an MQTT topic. For QoS 1 and QoS 2, messages are queued per topic and sent sequentially.
     * QoS 0 messages are sent without confirmation. For QoS 1 and QoS 2, this function manages the message flow,
     * ensuring that messages are sent in order and retried as necessary.
     * 
     * @param {string} token Authentication token used for the MQTT connection.
     * @param {Message} message The message object to be published. This includes the topic, payload, and optionally QoS.
     * @param {string} [version='1.0'] The MQTT protocol version to use for the message. Defaults to '1.0'.
     * @returns {Promise<string[]>} A promise that resolves with the result of the publish operation. For QoS 0, it may resolve
     *                          immediately after sending. For QoS 1 and QoS 2, it resolves after the appropriate
     *                          acknowledgment process is completed. It returns a list of success/non success messages
     */
    public async publish(token: string, message: Message, version = '1.0'): Promise<string[]> {
        let result = [];
        const { qos = 1 } = message;

        if (qos === 0) {
            const sendData = Interfaces.publish(version, { token, message });
            const sendResult = await this.send('/publish', sendData.payload, sendData.headers).catch(() => {
                // Do not care, if send is successful for qos === 0. Still await is needed to safely catch rejects.
            });
            const returnMessage = sendResult && (sendResult.statusCode === 204 || sendResult.statusCode === 200) ? "send (qos 0)" : "not send (qos 0)";
            result.push(returnMessage);
          } else {
            // For qos > 0, messages are queued per topic and sent one at a time.
            this.topicQueues[message.topic] ??= { state: 'ready', queue: [] };
            const topicQueue = this.topicQueues[message.topic];
            const sendData = Interfaces.publish(version, { token, message, dup: false, packetid: this.providePacketId() });
            topicQueue.queue.push(sendData);

            if (topicQueue.state === 'ready') {
                while (topicQueue.queue.length > 0) {
                    // state settings ensure that we only publish one message with qos > 0 at a time.
                    topicQueue.state = 'publish';
                    const firstElement = topicQueue.queue.shift();
                    const success = await this.sendMessage(firstElement);
                    result.push(success ? `delivered (qos ${firstElement.headers.qos})` : `not delivered(qos ${firstElement.headers.qos})`);
                    topicQueue.state = 'ready';
                }
            } else {
                result.push(`queued (qos ${qos})`);
            }
        }
        return result;
    }
}

