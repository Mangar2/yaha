/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * Provides a standard client to communicate with the mqtt broker
 */

'use strict'

// Importing required modules and classes
const { TestRun } = require('@mangar2/unittest')
const { Publish, OnPublish } = require('../dist/index') // Replace with actual path
const { Message } = require('@mangar2/mqtt-utils')


const VERBOSE = true
const DEBUG = true

const testRun = new TestRun(VERBOSE, DEBUG)

// Global constants


testRun.on('prepare', async (testcase) => {
    const onPublish = new OnPublish(0, [])
    onPublish.publishedMessages = []
    onPublish.on('publish', (message) => { 
        onPublish.publishedMessages.push(message) 
    }) 
    onPublish.listen()
    const { configuration } = testcase
    const publishInstance = new Publish('localhost', onPublish.port, configuration)
    return { publishInstance, onPublish }
})

const runTest = async (test, testObject) => {
    const { method, token, message, messages, version } = test
    const { publishInstance, onPublish } = testObject
    const runMessages = message ? [message] : messages
    let result
    onPublish.publishedMessages = []
    const promises = []

    try {
        switch (method) {
        case 'publish':
            for (const message of runMessages) {
                // Create a promise for each publish operation
                const publishPromise = publishInstance.publish(token, Message.createMessage(message), version)
                promises.push(publishPromise)
            }

            // Wait for all publish operations to complete
            result = await Promise.all(promises)
            //result = promises
            break
        case 'close':
            result = await publishInstance.close()
            break
        case 'stop receiver':
            result = await onPublish.close()
            break
        default:
            throw new Error(`Unsupported method: ${method}`)
        }
    }
    catch(err) {
        result = err.message
    }

    return { result, messages: onPublish.publishedMessages }
}

testRun.on('run', async (test, testObject) => {
    return runTest(test, testObject)
})

testRun.on('break', async (test, testObject) => {
    // Re-run the failed test for debugging
    return runTest(test, testObject)
})

testRun.on('cleanup', async (testObject) => {
    const { onPublish } = testObject
    await onPublish.close()
})

module.exports = () => testRun.asyncRun( ['publish-cases' ], __dirname, 8, 'js' )
