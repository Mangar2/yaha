/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      receive.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

'use strict'

const Log = require('@mangar2/logfilter')
const Message = require('@mangar2/message')
const Server = require('@mangar2/httpservice').HttpServer
const mqttVersion = require('@mangar2/mqttversion')

module.exports = class OnPublish {
    /**
     * Creates a new server receiving messages
     * @param {number} listenerPort port to listen on
     * @param {number} qos2PubrelTimeoutInSeconds time to delete qos2 related packageid´s from the qos2 queue.
     * This will happen, if a pubrel does not follow the publish call for a this amount of seconds
     */
    constructor (listenerPort, qos2PubrelTimeoutInSeconds = 7200) {
        this.log = new Log()
        this.server = new Server(listenerPort)
        this.callbacks = {}
        this.qos2Queue = {}
        this.qos2PubrelTimeoutInMilliseconds = qos2PubrelTimeoutInSeconds * 1000
        let result

        this.server.on('PUT', (payload, headers, path, res) => {
            if (path === '/publish') {
                result = this.onPublish(JSON.parse(payload), headers, res)
            } else if (path === '/pubrel') {
                result = this.onPubrel(JSON.parse(payload), headers, res)
            } else if (path === '/log') {
                result = this.onLog(JSON.parse(payload), headers, res)
            } else {
                throw ('illegal interface ' + path)
            }
        })
        return result
    }

    /**
     * Starts to listen and wait for input
     */
    listen () {
        this.server.listen()
    }

    /**
     * Callcs a callback stored to an event, if registered
     * @param {string} event event for callback
     * @param  {...any} param parameters to pass to the callback
     */
    invokeCallback (event, ...param) {
        if (this.callbacks[event] !== undefined) {
            this.callbacks[event](...param)
        }
    }

    /**
     * Sets a callback
     * @param {string} event RESTful http verb (POST, GET, PUT, PATCH, DELETE)
     * @param {function} callback(payload, qos)
     * where payload is the http payload, headers the http headers, res the result structure and path is
     * is the http path as string
     */
    on (event, callback) {
        const eventLowerCase = event.toLowerCase()
        if (typeof (callback) === 'function') {
            this.callbacks[eventLowerCase] = callback
        }
    }

    /**
     * Deletes entries in the "wait for pubrel queue" that are too old
     */
    deleteOldQos2QueueEntries () {
        const now = new Date().getTime()
        for (const entry in this.qos2Queue) {
            if (this.qos2Queue[entry].time + this.qos2PubrelTimeoutInMilliseconds < now) {
                delete this.qos2Queue[entry]
            } else {
                break
            }
        }
    }

    /**
     * Receives a pubrel message
     * @param {object} payload payload of the message
     * @param {object} headers headers of the message
     * @param {object} res http result structure
     */
    onPubrel (payload, headers, res) {
        const result = mqttVersion.onPubrel(headers)

        delete this.qos2Queue[result.packetid]
        this.deleteOldQos2QueueEntries()

        res.writeHead(result.statusCode, result.headers)
        res.end(result.payload)
    }

    /**
     * Stores a qos2 publish message to check for a pubrel call
     * @param {string} topic topic of the message
     * @param {number} packetid id of the packet
     */
    rememberMessage (topic, packetid) {
        this.qos2Queue[packetid] = { time: new Date().getTime(), topic }
    }

    /**
     * Receives a published message
     * @param {object} payload received {token, message}
     * @param {object} headers headers of the message
     * @param {object} res http result structure
     */
    onPublish (payload, headers, res) {
        const message = payload.message
        Message.validate(message)
        const dup = headers.dup === '1' || headers.dup === 'true'
        const packetid = headers.version === '1.0' ? headers.packetid : headers.id

        if (this.log.getLogLevel('received', message.topic) !== undefined) {
            const reason = message.reason === undefined ? '' : message.reason[0].message
            const dupStr = dup ? ',dup' : ''
            const qos = Number(headers.qos)
            const valueStr = message.value === '' || message.value === undefined ? '' : '=' + message.value
            console.log('%s (qos%s%s) received %s%s [%s]', new Date().toLocaleString(), qos, dupStr, message.topic, valueStr, reason)
        }

        const qos2PacketPublishedBefore = dup && this.qos2Queue[packetid] !== undefined

        if (!qos2PacketPublishedBefore) {
            if (Number(headers.qos) === 2) {
                this.rememberMessage(message.topic, packetid)
            }

            this.invokeCallback('publish', message, headers.qos, dup)
        }

        const result = mqttVersion.receive(headers)

        res.writeHead(result.statusCode, result.headers)
        res.end(result.payload)
    }

    /**
     * Receives a logging request
     * @param {topics} payload content received
     * @param {object} headers headers of the message
     * @param {object} res http result structure
     */
    onLog (topics, payload, res) {
        this.log.changePattern(payload)
        res.writeHead(204, { 'Content-Type': 'application/json' })
        res.end('')
    }

    /**
     * Closes all connections
     */
    close () {
        this.server.close()
    }
}
