/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      test.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

'use strict'

const MqttService = require('@mangar2/mqttservice')
const UnitTest = require('@mangar2/unittest')
const Message = require('@mangar2/message')

var unitTest = new UnitTest(false)
const TEST_COUNT = 100;

(async function test () {
    try {
        const HOST = '127.0.0.1'
        const PORT = 19001
        const TOKEN = '/a/b'

        const receive = new MqttService.OnPublish(PORT)
        const publish = new MqttService.Publish(HOST, PORT, { retry: 2 })
        const value = {}

        let result

        receive.on('publish', (message, qos) => {
            qos = Number(qos)
            if (value[message.topic] === undefined) {
                value[message.topic] = 1
            }
            if (message.topic === '/a/0' || message.topic === 'single/0') {
                unitTest.assertEqual(qos, 0, 'qos check 0')
            } else if (message.topic === '/a/1' || message.topic === '/b/1' || message.topic === 'single/1') {
                unitTest.assertEqual(qos, 1, 'qos check 1')
                unitTest.assertEqual(message.value, value[message.topic], 'value check qos 1')
            } else if (message.topic === '/a/2' || message.topic === '/c/2' || message.topic === 'single/2') {
                unitTest.assertEqual(qos, 2, 'qos check 2')
                unitTest.assertEqual(message.value, value[message.topic], 'value check qos 2')
            } else {
                unitTest.fail('unexpected topic: ' + message.topic)
            }
            value[message.topic]++
        })

        // listen
        receive.listen()

        // qos 0 publish
        result = await publish.publish(TOKEN, new Message('single/0', 1, 'test'), 0, 0)
        unitTest.assertEqual(result, undefined, 'QoS 0 message have undefined result')

        // qos 1 publish
        result = await publish.publish(TOKEN, new Message('single/1', 1, 'test'), 1, 0)
        unitTest.assertTrue(result, 'QoS 1 message successful')

        // qos 2 publish
        result = await publish.publish(TOKEN, new Message('single/2', 1, 'test'), 2, 0)
        unitTest.assertTrue(result, 'QoS 2 message successful')

        // syncron mass publish
        for (let i = 1; i <= TEST_COUNT; i++) {
            if (i % 10 === 0) unitTest.log(i + ' of ' + TEST_COUNT * 2)
            await publish.publish(TOKEN, new Message('/a/0', i, 'test'), 0, 0)
            await publish.publish(TOKEN, new Message('/a/1', i, 'test'), 1, 0)
            await publish.publish(TOKEN, new Message('/b/1', i, 'test'), 1, 0)
            await publish.publish(TOKEN, new Message('/a/2', i, 'test'), 2, 0)
            await publish.publish(TOKEN, new Message('/c/2', i, 'test'), 2, 0)
        }

        const promises = []
        // asyncron mass publish
        for (let i = TEST_COUNT + 1; i <= TEST_COUNT * 2; i++) {
            if (i % 10 === 0) unitTest.log(i + ' of ' + TEST_COUNT * 2)
            promises.push(publish.publish(TOKEN, new Message('/a/0', i, 'test'), 0, 0))
            promises.push(publish.publish(TOKEN, new Message('/a/1', i, 'test'), 1, 0))
            promises.push(publish.publish(TOKEN, new Message('/b/1', i, 'test'), 1, 0))
            promises.push(publish.publish(TOKEN, new Message('/a/2', i, 'test'), 2, 0))
            promises.push(publish.publish(TOKEN, new Message('/c/2', i, 'test'), 2, 0))
        }

        unitTest.log('wait for all promises to finish ...')
        await Promise.all(promises)

        unitTest.showResult(TEST_COUNT * 9 * 2 + 8)
        process.exit(0)
    } catch (err) {
        console.error(err)
        console.error('Error: test ends with errors')
        process.exit(1)
    }
})()
