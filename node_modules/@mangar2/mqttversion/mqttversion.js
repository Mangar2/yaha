/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      mqttversion.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

var standardHeaderText = {
    'content-type': "text/plain; charset=UTF-8",
    accept: "application/json,text/plain",
    'accept-charset': "UTF-8"
}

var standardHeaderJSON = {
    'content-type': "application/json; charset=UTF-8",
    accept: "application/json,text/plain",
    'accept-charset': "UTF-8"
}

var publish = {
    /**
     * Publishes to a client
     * @param {object} message 
     * @param {number} qos quality of service (0,1,2)
     * @param {number} dup duplicate flag 1 (true) or 0 (false). Identifies duplicate packages
     * @param {number} retain flag 1 (true) or 0 (false). Requrests to retain the message
     * @param {number} packetid unique id of the package
     */
    "0.0" : (message, qos, dup, retain, packetid) => {
        let payload = message;
        let headers = {...standardHeaderJSON, version: '0.0'}
        if (packetid !== undefined) {
            headers.id = packetid;
        }
        
        let resultCheck = (result) => {
            return qos == 0 || (
                    result.statusCode === 200 && 
                    result.headers['content-type'].startsWith('text/plain') && 
                    result.payload === 'puback' && 
                    result.headers.id == packetid
                    );
        }

        return {headers, payload, resultCheck}
    },

    "1.0" : (message, qos, dup, retain, packetid) => {
        let payload = message; 
        let headers = {...standardHeaderJSON, qos, dup, retain, version: '1.0'}
        if (packetid !== undefined) {
            headers.packetid = packetid;
        }

        let resultCheck = (result) => {
            let success;
            let statusOk = result.statusCode === 204;
            let packetIdMatches = result.headers.packetid == packetid;
            let packet = result.headers.packet;
            switch (qos) {
                case 0: success = true; break;
                case 1: success = statusOk && packet === "puback" && packetIdMatches; break;
                case 2: success = statusOk && packet === "pubrec" && packetIdMatches; break;
                default: success = true; // invalid qos, should not happen
            }
            return success;
        }
        return {headers, payload, resultCheck}
    }
}

var onPublish = {
    "0.0": 
        /**
         * creates the return types for a receive message
         * @param {object} headers input headers
         */
        headers => {
            let version = '0.0';
            let result =  {
                headers: { "content-type": "text/plain; charset=UTF-8", version},
                payload: "puback",
                statusCode: 200
            }
            if (headers.id !== undefined) {
                result.headers.id = headers.id;
            }
            return result;
        },
    "1.0":
        /**
         * creates the return types for a receive message
         * @param {object} headers input headers
         */
        headers => {
            let version = '1.0';
            let qos = headers.qos;
            let result =  {
                headers: { 'content-type': "application/json; charset=UTF-8", version},
                payload: "",
                statusCode: 204
            }
            if (qos == 1) { result.headers.packet = 'puback'; }
            if (qos == 2) { result.headers.packet = 'pubrec'; }
            if (headers.packetid !== undefined) {
                result.headers.packetid = headers.packetid;
            }
            return result;
        } 
}

var pubrel = {
    /**
     * Sends a qos=2 commit message "pubrel" to a client
     * @param {packetid} id of the packet (must be the same id as send by publish!)
     */
    "0.0" : (packetid) => {
        let payload = "";
        let headers = {...standardHeaderText, version: '0.0'}
        if (packetid !== undefined) {
            headers.id = packetid;
        }
        
        let resultCheck = (result) => {
            return  result.statusCode === 200 && 
                    result.headers['content-type'].startsWith('text/plain') && 
                    result.payload === 'pubcomp' && 
                    result.headers.id == packetid;
        }

        return {headers, payload, resultCheck}
    },

    "1.0" : (packetid) => {
        let payload = ""; 
        let headers = {...standardHeaderText, version: '1.0'}
        if (packetid !== undefined) {
            headers.packetid = packetid;
        }

        let resultCheck = (result) => {
            let statusOk = result.statusCode === 204;
            let packetIdMatches = result.headers.packetid == packetid;
            let packetNameOk = result.headers.packet === 'pubcomp';
            return statusOk && packetIdMatches && packetNameOk;
        }
        return {headers, payload, resultCheck}
    }
}

var onPubrel = {
    "0.0": 
        /**
         * creates the return types for a receive pubrel message
         * @param {object} headers input headers
         */
        headers => {
            let version = '0.0';
            let result =  {
                headers: { "content-type": "text/plain; charset=UTF-8", version},
                payload: "pubcomp",
                statusCode: 200
            }
            if (headers.id !== undefined) {
                result.headers.id = headers.id;
            }
            return result;
        },
    "1.0":
        /**
         * creates the return types for a receive message
         * @param {object} headers input headers
         */
        headers => {
            let version = '1.0';
            let packet = 'pubcomp';
            let packetid = headers.packetid;

            return result =  {
                headers: { "content-type": "text/plain; charset=UTF-8", version, packet, packetid},
                payload: "",
                statusCode: 204
            }
        } 
}

           
var subscribe = {
    /**
     * Subscribes to a client
     * @param {object} topics {topic: qos, ...}
     * @param {string} clientId unique client identifier
     * @param {number|undefined} packetid unique id of the package (not used on version 0.0)
     */
    "0.0" : (topics, clientId, packetid) => {
        let subscribe = {QoS: 0, topics:[]}
        for (let topic in topics) {
            subscribe.QoS = topics[topic];
            subscribe.topics.push(topic);
        }
        let payload = {
            clientId, subscribe
        };
        let headers = {...standardHeaderJSON, version: '0.0'}
        
        let resultCheck = (result) => {
            return result.statusCode === 200 && 
                result.headers['content-type'].startsWith('text/plain') && 
                result.payload === 'suback';
        }

        return {headers, payload, resultCheck}
    },

    "1.0" : (topics, clientId, packetid) => {
        let payload = {
            clientId, topics
        }
        let headers = {...standardHeaderJSON, packetid, version: '1.0'}

        let resultCheck = (result) => {
            return result.statusCode === 200 && 
                result.headers['content-type'].startsWith('application/json') && 
                result.headers.packet === 'suback' && 
                result.headers.packetid == packetid;
        }
        return {headers, payload, resultCheck}
    }
}

var onSubscribe = {
    /**
     * replies to a subscribe request
     * @param {array} qos quality of service reply array
     */
    "0.0" : (headers, qos) => {
        
        return {
            headers: { "content-type": "text/plain; charset=UTF-8", version: "0.0"},
            payload: "suback",
            statusCode: 200
        }

    },

    "1.0" : (headers, qos) => {
        let packetid = headers.packetid === undefined ? 0 : headers.packetid;

        return {
            headers: { "content-type": "application/json; charset=UTF-8", version: "1.0", packet: "suback", packetid },
            payload: JSON.stringify({ qos }),
            statusCode: 200
        }

    }
}

var connect = {
    /**
     * Connects to a broker
     * @param {string} clientId unique client identifier
     */
    "0.0" : (clientId, host, port, clean) => {
        let payload = {
            clientId, host, port, clean
        }
        let headers = {...standardHeaderJSON, version: '0.0'}
        
        let resultCheck = (result) => {
            return result.statusCode === 200 && 
                result.headers['content-type'].startsWith('text/plain') && 
                result.payload === 'connack';
        }

        return {headers, payload, resultCheck}
    },

    "1.0" : (clientId, host, port, clean) => {
        let payload = {
            clientId, host, port, clean
        }
        let headers = {...standardHeaderJSON, version: '1.0'}
        
        let resultCheck = (result) => {
            return result.statusCode === 200 && 
                result.headers['content-type'].startsWith('application/json') && 
                result.headers.packet === 'connack';
        }

        return {headers, payload, resultCheck}
    }
}

var onConnect = {
    /**
     * replies to a connect request
     * @param {number} present 1, if the session is already present - else 0.
     * @param {number} packetid id of the subscribe packet
     */
    "0.0" : (present) => {
        
        return {
            headers: { "content-type": "text/plain; charset=UTF-8", version: "0.0"},
            payload: "connack",
            statusCode: 200
        }

    },

    "1.0" : (present) => {

        return {
            headers: { "content-type": "application/json; charset=UTF-8", packet: "connack", version: "1.0" },
            payload: JSON.stringify({ present }),
            statusCode: 200
        }

    }
}



/**
 * Extracts the version from a headers object
 * @param {object} headers object with member version
 */
function getVersion(headers) {
    let version = headers.version === undefined? "0.0" : headers.version;
    if (onPublish[version] === undefined) {
        throw "undefined version " + version;
    }
    return version;
}
  
module.exports = {
    publish: (version, message, qos, dup, retain, packetid) => {
        return publish[version](message, qos, dup, retain, packetid);
    },
    receive: (headers) => {
        return onPublish[getVersion(headers)](headers);
    },
    pubrel: (version, packetid) => {
        return pubrel[version](packetid);
    },
    onPubrel: (headers) => {
        return onPubrel[getVersion(headers)](headers);
    },
    subscribe: (version, topics, clientId, packetid) => {
        return subscribe[version](topics, clientId, packetid);
    },
    onSubscribe: (headers, qos) => {
        return onSubscribe[getVersion(headers)](headers, qos);
    },
    connect: (version, clientId, host, port, clean) => {
        return connect[version](clientId, host, port, clean);
    },
    onConnect: (headers, present) => {
        return onConnect[getVersion(headers)](present);
    }

}