/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      mqttversion.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

var standardHeaderText = {
    'content-type': 'text/plain; charset=UTF-8',
    accept: 'application/json,text/plain',
    'accept-charset': 'UTF-8'
}

var standardHeaderJSON = {
    'content-type': 'application/json; charset=UTF-8',
    accept: 'application/json,text/plain',
    'accept-charset': 'UTF-8'
}

var publish = {
    /**
     * Publishes to a client
     * @param {string} token connection token
     * @param {object} message
     * @param {number} qos quality of service (0,1,2)
     * @param {number} dup duplicate flag 1 (true) or 0 (false). Identifies duplicate packages
     * @param {number} retain flag 1 (true) or 0 (false). Requrests to retain the message
     * @param {number} packetid unique id of the package
     * @returns {object} {headers, payload, resultCheck(result)}
     */
    '0.0': (token, message, qos, dup, retain, packetid) => {
        const payload = message
        const headers = { ...standardHeaderJSON, version: '0.0' }
        if (packetid !== undefined) {
            headers.id = packetid
        }

        const resultCheck = (result) => {
            return Number(qos) === 0 || (
                result.statusCode === 200 &&
                    result.headers['content-type'].startsWith('text/plain') &&
                    result.payload === 'puback' &&
                    Number(result.headers.id) === packetid
            )
        }

        return { headers, payload, resultCheck }
    },

    '1.0': (token, message, qos, dup, retain, packetid) => {
        const payload = { token, message }
        const headers = { ...standardHeaderJSON, qos, dup, retain, version: '1.0' }
        if (packetid !== undefined) {
            headers.packetid = packetid
        }

        const resultCheck = (result) => {
            let success
            const statusOk = result.statusCode === 204
            const packetIdMatches = Number(result.headers.packetid) === packetid
            const packet = result.headers.packet
            switch (qos) {
            case 0: success = true; break
            case 1: success = statusOk && packet === 'puback' && packetIdMatches; break
            case 2: success = statusOk && packet === 'pubrec' && packetIdMatches; break
            default: success = true // invalid qos, should not happen
            }
            return success
        }
        return { headers, payload, resultCheck }
    }
}

var onPublish = {
    '0.0':
        /**
         * creates the return types for a receive message
         * @param {object} headers input headers
         * @returns {object} {headers, payload, statusCode, packetid}
         */
        headers => {
            const version = '0.0'
            const result = {
                headers: { 'content-type': 'text/plain; charset=UTF-8', version },
                payload: 'puback',
                statusCode: 200,
                packetid: headers.id
            }
            if (headers.id !== undefined) {
                result.headers.id = headers.id
            }
            return result
        },
    '1.0':
        /**
         * creates the return types for a receive message
         * @param {object} headers input headers
         */
        headers => {
            const version = '1.0'
            const qos = Number(headers.qos)
            const result = {
                headers: { 'content-type': 'application/json; charset=UTF-8', version },
                payload: '',
                statusCode: 204,
                packetid: headers.packetid
            }
            if (qos === 1) { result.headers.packet = 'puback' }
            if (qos === 2) { result.headers.packet = 'pubrec' }
            if (headers.packetid !== undefined) {
                result.headers.packetid = headers.packetid
            }
            return result
        }
}

var pubrel = {
    /**
     * Creates the objects for a qos=2 commit message "pubcomp"
     * @param {string} token connection token
     * @param {number} packetid of the packet (must be the same id as send by publish!)
     * @returns {object} {headers, payload, resultCheck(result)}
     */
    '0.0': (token, packetid) => {
        const payload = { token }
        const headers = { ...standardHeaderText, version: '0.0' }
        if (packetid !== undefined) {
            headers.id = packetid
        }

        const resultCheck = (result) => {
            return result.statusCode === 200 &&
                    result.headers['content-type'].startsWith('text/plain') &&
                    result.payload === 'pubcomp' &&
                    Number(result.headers.id) === packetid
        }

        return { headers, payload, resultCheck }
    },

    '1.0': (token, packetid) => {
        const payload = { token }
        const headers = { ...standardHeaderText, version: '1.0' }
        if (packetid !== undefined) {
            headers.packetid = packetid
        }

        const resultCheck = (result) => {
            const statusOk = result.statusCode === 204
            const packetIdMatches = Number(result.headers.packetid) === packetid
            const packetNameOk = result.headers.packet === 'pubcomp'
            return statusOk && packetIdMatches && packetNameOk
        }
        return { headers, payload, resultCheck }
    }
}

var onPubrel = {
    /**
     * creates the return types for a receive pubrel message
     * @param {object} headers input headers
     * @returns {object} {headers, payload, statusCode, packetid}
     */
    '0.0':

        headers => {
            const version = '0.0'
            const id = headers.id
            const result = {
                headers: { 'content-type': 'text/plain; charset=UTF-8', version, id },
                payload: 'pubcomp',
                statusCode: 200,
                packetid: id
            }
            return result
        },
    '1.0':
        headers => {
            const version = '1.0'
            const packet = 'pubcomp'
            const packetid = headers.packetid

            const result = {
                headers: { 'content-type': 'text/plain; charset=UTF-8', version, packet, packetid },
                payload: '',
                statusCode: 204,
                packetid
            }
            return result
        }
}

var pubrel = {
    /**
     * Sends a qos=2 commit message "pubrel" to a client
     * @param {packetid} id of the packet (must be the same id as send by publish!)
     */
    "0.0" : (packetid) => {
        let payload = "";
        let headers = {...standardHeaderText, version: '1.0'}
        if (packetid !== undefined) {
            headers.id = packetid;
        }
        
        let resultCheck = (result) => {
            return qos == 0 || (
                    result.statusCode === 200 && 
                    result.headers['content-type'].startsWith('text/plain') && 
                    result.payload === 'pubcomp' && 
                    result.headers.id == packetid
                    );
        }

        return {headers, payload, resultCheck}
    },

    "1.0" : (packetid) => {
        let payload = ""; 
        let headers = {...standardHeaderText, version: '1.0'}
        if (packetid !== undefined) {
            headers.packetid = packetid;
        }

        let resultCheck = (result) => {
            let success;
            let statusOk = result.statusCode === 204;
            let packetIdMatches = result.headers.packetid == packetid;
            let packetNameOk = result.headers.packet === 'pubcomp';
            return statusOK && packetIdMatches && packetNameOk;
        }
        return {headers, payload, resultCheck}
    }
}

var onPubrel = {
    "0.0": 
        /**
         * creates the return types for a receive pubrel message
         * @param {object} headers input headers
         */
        headers => {
            let version = '0.0';
            let result =  {
                headers: { "content-type": "text/plain; charset=UTF-8", version},
                payload: "pubcomp",
                statusCode: 200
            }
            if (headers.id !== undefined) {
                result.headers.id = headers.id;
            }
            return result;
        },
    "1.0":
        /**
         * creates the return types for a receive message
         * @param {object} headers input headers
         */
        headers => {
            let version = '1.0';
            let packet = 'pubcomp';
            let packetid = headers.packetid;

            return result =  {
                headers: { "content-type": "text/plain; charset=UTF-8", version, packet, packetid},
                payload: "",
                statusCode: 204
            }
        } 
}

           
var subscribe = {
    /**
     * Subscribes to a client
     * @param {object} topics {topic: qos, ...}
     * @param {string} clientId unique client identifier
     * @param {number|undefined} packetid unique id of the package (not used on version 0.0)
     * @returns {object} {headers, payload, resultCheck(result)}
     */
    '0.0': (topics, clientId, packetid) => {
        const subscribe = { QoS: 0, topics: [] }
        for (const topic in topics) {
            subscribe.QoS = topics[topic]
            subscribe.topics.push(topic)
        }
        const payload = {
            clientId, subscribe
        }
        const headers = { ...standardHeaderJSON, version: '0.0' }

        const resultCheck = (result) => {
            return result.statusCode === 200 &&
                result.headers['content-type'].startsWith('text/plain') &&
                result.payload === 'suback'
        }

        return { headers, payload, resultCheck }
    },

    '1.0': (topics, clientId, packetid) => {
        const payload = {
            clientId, topics
        }
        const headers = { ...standardHeaderJSON, packetid, version: '1.0' }

        const resultCheck = (result) => {
            return result.statusCode === 200 &&
                result.headers['content-type'].startsWith('application/json') &&
                result.headers.packet === 'suback' &&
                Number(result.headers.packetid) === packetid
        }
        return { headers, payload, resultCheck }
    }
}

var onSubscribe = {
    /**
     * Creates the subscribe result objects
     * @param {object} headers input headers
     * @param {array} qosArray quality of service reply array
     * @returns {object} {headers, payload, statusCode, packetid}
     */
    '0.0': (headers, qosArray) => {
        return {
            headers: { 'content-type': 'text/plain; charset=UTF-8', version: '0.0' },
            payload: 'suback',
            statusCode: 200,
            packetid: headers.id
        }
    },

    '1.0': (headers, qosArray) => {
        const packetid = headers.packetid === undefined ? 0 : headers.packetid

        return {
            headers: { 'content-type': 'application/json; charset=UTF-8', version: '1.0', packet: 'suback', packetid },
            payload: JSON.stringify({ qos: qosArray }),
            statusCode: 200,
            packetid: headers.packetid
        }
    }
}

var unsubscribe = {
    /**
     * Subscribes to a client
     * @param {Array} topics array of topic strings
     * @param {string} clientId unique client identifier
     * @param {number|undefined} packetid unique id of the package (not used on version 0.0)
     * @returns {object} {headers, payload, resultCheck(result)}
     */
    '0.0': (topics, clientId, packetid) => {
        const payload = { topics, clientId }
        const headers = { ...standardHeaderText, version: '0.0' }

        const resultCheck = (result) => {
            return result.statusCode === 200 &&
                result.headers['content-type'].startsWith('text/plain') &&
                result.payload === 'unsuback'
        }

        return { headers, payload, resultCheck }
    },

    '1.0': (topics, clientId, packetid) => {
        const payload = { topics, clientId }
        const headers = { ...standardHeaderJSON, packetid, version: '1.0' }

        const resultCheck = (result) => {
            return result.statusCode === 204 &&
                result.headers['content-type'].startsWith('application/json') &&
                result.headers.packet === 'unsuback' &&
                Number(result.headers.packetid) === packetid
        }
        return { headers, payload, resultCheck }
    }
}

var onUnsubscribe = {
    /**
     * creates the return types for a unsubscribe request
     * @param {object} headers input headers
     * @returns {object} {headers, payload, statusCode, packetid}
     */
    '0.0': (headers) => {
        return {
            headers: { 'content-type': 'text/plain; charset=UTF-8', version: '0.0' },
            payload: 'unsuback',
            statusCode: 200,
            packetid: headers.id
        }
    },

    '1.0': (headers) => {
        const packetid = headers.packetid === undefined ? 0 : headers.packetid
        return {
            headers: { 'content-type': 'application/json; charset=UTF-8', packet: 'unsuback', version: '1.0', packetid },
            payload: '',
            statusCode: 204,
            packetid: headers.packetid
        }
    }
}

var connect = {
    /**
     * Creates the objects to connect ot a broker
     * @param {string} clientId unique client identifier
     * @param {string} host host name of the client host
     * @param {number} port port number of the clien listening port
     * @param {bool} clean true, if the connection is cleaned up after disconnect
     * @returns {object} {headers, payload, resultCheck(result)}
     */
    '0.0': (clientId, host, port, clean) => {
        const payload = {
            clientId, host, port, clean
        }
        const headers = { ...standardHeaderJSON, version: '0.0' }

        const resultCheck = (result) => {
            return result.statusCode === 200 &&
                result.headers['content-type'].startsWith('text/plain') &&
                result.payload === 'connack'
        }

        return { headers, payload, resultCheck }
    },

    '1.0': (clientId, host, port, clean) => {
        const payload = {
            clientId, host, port, clean
        }
        const headers = { ...standardHeaderJSON, version: '1.0' }

        const resultCheck = (result) => {
            return result.statusCode === 200 &&
                result.headers['content-type'].startsWith('application/json') &&
                result.headers.packet === 'connack'
        }

        return { headers, payload, resultCheck }
    }
}

var onConnect = {
    /**
     * Creates the return types for a connect request
     * @param {object} payload payload to return
     * @returns {object} {headers, payload, statusCode}
     */
    '0.0': (payload) => {
        return {
            headers: { 'content-type': 'text/plain; charset=UTF-8', version: '0.0' },
            payload: 'connack',
            statusCode: 200
        }
    },

    '1.0': (payload) => {
        return {
            headers: { 'content-type': 'application/json; charset=UTF-8', packet: 'connack', version: '1.0' },
            payload: JSON.stringify(payload),
            statusCode: 200
        }
    }
}

var disconnect = {
    /**
     * Creates the objects to disconnect from a broker
     * @param {string} clientId unique client identifier
     * @returns {object} {headers, payload, resultCheck(result)}
     */
    '0.0': (clientId) => {
        const payload = {
            clientId
        }
        const headers = { ...standardHeaderText, version: '0.0' }

        const resultCheck = (result) => {
            return result.statusCode === 204
        }

        return { headers, payload, resultCheck }
    },

    '1.0': (clientId) => {
        const payload = {
            clientId
        }
        const headers = { ...standardHeaderJSON, version: '1.0' }

        const resultCheck = (result) => {
            return result.statusCode === 204
        }

        return { headers, payload, resultCheck }
    }
}

var onDisconnect = {
    /**
     * creates the return types for a disconnect request
     * @returns {object} {headers, payload, statusCode}
     */
    '0.0': () => {
        return {
            headers: { 'content-type': 'text/plain; charset=UTF-8', version: '0.0' },
            payload: '',
            statusCode: 204
        }
    },

    '1.0': () => {
        return {
            headers: { 'content-type': 'application/json; charset=UTF-8', version: '1.0' },
            payload: '',
            statusCode: 204
        }
    }
}

/**
 * Extracts the version from a headers object
 * @param {object} headers object with member version
 * @returns {string} version string
 */
function getVersion (headers) {
    const version = headers.version === undefined ? '0.0' : headers.version
    if (onPublish[version] === undefined) {
        throw 'undefined version ' + version
    }
    return version
}

module.exports = {
    /**
     * Creates the objects to publish to a client
     * @param {string} version interface version ('0.0' or '1.0')
     * @param {string} token connection token
     * @param {object} message payload
     * @param {number} qos quality of service (0,1,2)
     * @param {number} dup duplicate flag 1 (true) or 0 (false). Identifies duplicate packages
     * @param {number} retain flag 1 (true) or 0 (false). Requrests to retain the message
     * @param {number} packetid unique id of the package
     * @returns {object} {headers, payload, resultCheck(result)}
     */
    publish: (version, token, message, qos, dup, retain, packetid) => {
        return publish[version](token, message, qos, dup, retain, packetid)
    },
    /**
     * creates the return types for a receive message
     * @param {object} headers input headers
     * @returns {object} {headers, payload, statusCode, packetid}
     */
    receive: (headers) => {
        return onPublish[getVersion(headers)](headers)
    },
    onPublish: (headers) => {
        return onPublish[getVersion(headers)](headers)
    },
    /**
     * creates the return types for a receive pubrel message
     * @param {string} version interface version ('0.0' or '1.0')
     * @param {string} token connection token
     * @param {number} packetid of the packet (must be the same id as send by publish!)
     * @returns {object} {headers, payload, resultCheck(result)}
     */
    pubrel: (version, token, packetid) => {
        return pubrel[version](token, packetid)
    },
    /**
     * Creates the objects for a qos=2 commit message "pubcomp"
     * @param {object} headers pubrel message headers
     * @returns {object} {headers, payload, statusCode, packetid}
     */
    onPubrel: (headers) => {
        return onPubrel[getVersion(headers)](headers)
    },
    /**
     * Subscribes to a client
     * @param {string} version interface version ('0.0' or '1.0')
     * @param {object} topics {topic: qos, ...}
     * @param {string} clientId unique client identifier
     * @param {number|undefined} packetid unique id of the package (not used on version 0.0)
     * @returns {object} {headers, payload, resultCheck(result)}
     */
    subscribe: (version, topics, clientId, packetid) => {
        return subscribe[version](topics, clientId, packetid)
    },
    /**
     * Creates the subscribe result objects
     * @param {object} headers input headers
     * @param {array} qosArray quality of service reply array
     * @returns {object} {headers, payload, statusCode, packetid}
     */
    onSubscribe: (headers, qos) => {
        return onSubscribe[getVersion(headers)](headers, qos)
    },
    /**
     * Creats the objects to unsubscribe from a client
     * @param {string} version interface version ('0.0' or '1.0')
     * @param {Array} topics array of topic strings
     * @param {string} clientId unique client identifier
     * @param {number|undefined} packetid unique id of the package (not used on version 0.0)
     * @returns {object} {headers, payload, resultCheck(result)}
     */
    unsubscribe: (version, topics, clientId, packetid) => {
        return unsubscribe[version](topics, clientId, packetid)
    },
    /**
     * creates the return types for a disconnect request
     * @param {object} headers message headers
     * @returns {object} {headers, payload, statusCode, packetid}
     */
    onUnsubscribe: (headers) => {
        return onUnsubscribe[getVersion(headers)](headers)
    },
    /**
     * Creates the objects to connect ot a broker
     * @param {string} clientId unique client identifier
     * @param {string} host host name of the client host
     * @param {number} port port number of the clien listening port
     * @param {bool} clean true, if the connection is cleaned up after disconnect
     * @returns {object} {headers, payload, resultCheck(result)}
     */
    connect: (version, clientId, host, port, clean) => {
        return connect[version](clientId, host, port, clean)
    },
    /**

    * Creates the return types for a connect request
     * @param {object} headers message headers
     * @param {object} payload payload to return
     * @returns {object} {headers, payload, statusCode}
     */
    onConnect: (headers, payload) => {
        return onConnect[getVersion(headers)](payload)
    },
    /**
     * Creates the objects to disconnect from a broker
     * @param {string} clientId unique client identifier
     * @returns {object} {headers, payload, resultCheck(result)}
     */
    disconnect: (version, clientId) => {
        return disconnect[version](clientId)
    },
    /**
     * creates the return types for a disconnect request
     * @param {object} headers message headers
     * @returns {object} {headers, payload, statusCode}
     */
    onDisconnect: (headers) => {
        return onDisconnect[getVersion(headers)]()
    }
}
