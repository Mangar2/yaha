/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview Interface to the opensense map service. Use it to send data to opensense map.
 */

'use strict'

const HttpsClient = require('@mangar2/httpservice').HttpsClient
const Message = require('@mangar2/message')

/**
 * @description
 * Sensor information
 * @typedef {Object} Sensor
 * @property {string} name name of the sensor
 * @property {string} unit unit of the sensor
 * @property {string} topic topic the sensor is matched to
 * @property {string} id opensensmap unique id
 */

/**
 * List of Sensors
 * @typedef {Sensor[]} Sensors
 */

/**
 * @private
 * @description
 * Searches a sensor-id in the "sensors" configuration
 * @param {Sensors} sensors array of sensor objects with "topic" and "id" attributes
 * @param {string} topic topic to search for
 * @returns {string|undefined} opensensmap unique id of the sensor or undefined if not found
 */
function lookupSensorId (sensors, topic) {
    let sensorId
    for (const sensor of sensors) {
        if (sensor.topic === topic) {
            sensorId = sensor.id
            break
        }
    }
    return sensorId
}

/**
 * Gets the subscriptions for the service
 * @param {Object} config configuration (sensors, ...)
 * @param {Sensors} config.sensors opensensemap sensor configuration
 * @param {number} config.qos quality of service for message transport
 * @returns {string[]} array of subscriptions
 */
function getSubscriptions (config) {
    const subscriptions = {}
    for (const sensor of config.sensors) {
        subscriptions[sensor.topic] = config.qos
    }
    return subscriptions
}

/**
 * @private
 * @description
 * Gets the topic to return
 * @param {number} statusCode http status code
 * @param {Reason} messageReason reason of the status
 * @param {string} resultReason result information from opensensemap
 * @returns {Message} result message
 */
function getReturnMessage (statusCode, messageReason, resultReason) {
    let result
    switch (statusCode) {
    case 201: result = new Message('$SYS/opensensemap/success', statusCode, messageReason); break
    case 404: result = new Message('$SYS/opensensemap/error', statusCode, messageReason); break
    case 422: result = new Message('$SYS/opensensemap/error', statusCode, messageReason); break
    default: result = new Message('$SYS/opensensemap/error', statusCode, messageReason); break
    }
    result.addReason(resultReason)
    result.qos = 1
    return result
}

/**
 * Publishes a value to opensensemap (you need an account to do this)
 * Publish data provided as Message to opensensemap. You need an account on opensensemap.org
 * The message topic is mapped to the sensor id provided in the config object. The message value it the value to publish
 * @param {Message} message the data to publish on the opensensemap
 * @param {string} message.topic the topic is used to select the sensor id from config
 * @param {number} message.value the value to publish to the sensor
 * @param {Object} config configuration (sensors, ...)
 * @param {string} [config.station] name of the station
 * @param {string} config.id sensebox id (provided by open sens map)
 * @param {string} config.host host of open sense map
 * @param {port} [config.port=443] portnumer of open sense map (usually 443)
 * @param {Sensors} config.sensors opensensemap sensor configuration
 * @returns {Message} message containing the status. Send it back to the broker
 * @example
 * const config =
 * {
 *   "station" : "your station name (optional)",
 *   "id" : "your station id",
 *   "host": "ingress.opensensemap.org",
 *   "port": 443,
 *   "sensors": [{
 *           "name": "temperature",
 *           "uint": "°C",
 *           "topic" : "topic/used/for/the/sensor",
 *           "id": "your sensor id"
 *    }]
 * }
 * let result = await Opensensemap.publish(
 *    new Message('topic/used/for/the/sensor', 2.61, 'test value' },
 *    config
 * )
 */
async function publish (message, config) {
    const { host, port = 443 } = config
    const { topic, value, reason: messageReason } = message
    const httpsClient = new HttpsClient(host, port)
    const sensorId = lookupSensorId(config.sensors, topic)
    if (sensorId === undefined) {
        throw Error('topic ' + topic + ' not found in open map sensors configuraiton ')
    }
    const data = { value }
    const payload = JSON.stringify(data)
    const headers = { 'content-type': 'application/json; charset=UTF-8' }
    const path = '/boxes/' + config.id + '/' + sensorId

    const httpResult = await httpsClient.send(path, 'POST', payload, headers)
    let resultReason = payload
    if (headers['content-type'].startsWith('application/json')) {
        const jsonPayload = JSON.parse(httpResult.payload)
        resultReason = jsonPayload.message !== undefined ? jsonPayload.message : jsonPayload
        resultReason = topic + '(' + value + '): ' + resultReason
    }

    const returnMessage = getReturnMessage(httpResult.statusCode, messageReason, resultReason)
    return returnMessage
}

module.exports = { publish, getSubscriptions }
