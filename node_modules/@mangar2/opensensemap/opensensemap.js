/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      opensensemap.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

'use strict'

const HttpsClient = require('@mangar2/httpservice').HttpsClient
const Message = require('@mangar2/message')

/**
 * @typedef {object} Sensor
 * @property {string} name name of the sensor
 * @property {string} unit unit of the sensor
 * @property {string} topic topic the sensor is matched to
 * @property {string} id opensensmap unique id
 */

/**
 * @typedef {Sensor[]} Sensors array of sensors
 */

/**
 * @private
 * Searches a sensor-id in the "sensors" configuration
 * @param {Sensors} sensors array of sensor objects with "topic" and "id" attributes
 * @param {string} topic topic to search for
 * @returns {string|undefined} opensensmap unique id of the sensor or undefined if not found
 */
function lookupSensorId (sensors, topic) {
    let sensorId
    for (const sensor of sensors) {
        if (sensor.topic === topic) {
            sensorId = sensor.id
            break
        }
    }
    return sensorId
}

/**
 * Gets the subscriptions for the service
 * @param {object} config configuration (sensors, ...)
 * @param {Sensors} config.sensors opensensemap sensor configuration
 * @param {number} config.qos quality of service for message transport
 * @returns {string[]} array of subscriptions
 */
function getSubscriptions (config) {
    const subscriptions = {}
    for (const sensor of config.sensors) {
        subscriptions[sensor.topic] = config.qos
    }
    return subscriptions
}

/**
 * @private
 * Gets the topic to return
 * @param {number} statusCode http status code
 * @param {Reason} messageReason reason of the status
 * @param {string} resultReason result information from opensensemap
 * @returns {Message} result message
 */
function getReturnMessage (statusCode, messageReason, resultReason) {
    let result
    switch (statusCode) {
    case 201: result = new Message('$SYS/opensensemap/success', statusCode, messageReason); break
    case 404: result = new Message('$SYS/opensensemap/error', statusCode, messageReason); break
    case 422: result = new Message('$SYS/opensensemap/error', statusCode, messageReason); break
    default: result = new Message('$SYS/opensensemap/error', statusCode, messageReason); break
    }
    result.addReason(resultReason)
    return result
}

/**
 * @public
 * Publishes a value to opensensemap (you need an account to do this)
 * @param {Message} message the data to publish on the opensensemap
 * @param {string} message.topic the topic is used to select the sensor id from config
 * @param {number} message.value the value to publish to the sensor
 * @param {object} config configuration (sensors, ...)
 * @param {string} config.id sensebox id (provided by open sens map)
 * @param {string} config.host host of open sense map
 * @param {port} [config.port=443] portnumer of open sense map (usually 443)
 * @param {Sensors} config.sensors opensensemap sensor configuration
 * @returns {Message} message containing the status. Send it back to the broker
 */
async function publish (message, config) {
    const { host, port = 443 } = config
    const { topic, value, reason: messageReason } = message
    const httpsClient = new HttpsClient(host, port)
    const sensorId = lookupSensorId(config.sensors, topic)
    if (sensorId === undefined) {
        throw Error('topic ' + topic + ' not found in open map sensors configuraiton ')
    }
    const data = { value }
    const payload = JSON.stringify(data)
    const headers = { 'content-type': 'application/json; charset=UTF-8' }
    const path = '/boxes/' + config.id + '/' + sensorId

    const httpResult = await httpsClient.send(path, 'POST', payload, headers)
    let resultReason = payload
    if (headers['content-type'].startsWith('application/json')) {
        const jsonPayload = JSON.parse(httpResult.payload)
        resultReason = jsonPayload.message !== undefined ? jsonPayload.message : jsonPayload
    }

    const returnMessage = getReturnMessage(httpResult.statusCode, messageReason, resultReason)
    return returnMessage
}

module.exports = { publish, getSubscriptions }
