/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * Provides a service to invoke broker messages from external networks. Allows only configured messages.
 */

'use strict'

const { errorLog, Callbacks } = require('@mangar2/utils')
const sanitizeConfiguration = require('@mangar2/rasbperry/configuration')
const Gpio = require('onoff').Gpio 

const DEBUG = true

/**
 * Creates a remote service
 * @param {Object} [options={}] service configuration
 * @param {Service[]} options.switches gpio switch configuration
 */
class Raspberry {
    constructor (options = {}) {
        this._options = sanitizeConfiguration(options)
        this._callbacks = new Callbacks(['publish'])
    }

    /**
     * Sets a callback.
     * @param {string} event event name (not case sensitive) for the callback
     * @param {function} callback function(...parameter)
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on (event, callback) {
        this._callbacks.on(event, callback)
    }

    /**
     * 
     * @param {number} pin number of the pin to set
     * @param {boolean} value new status of the pin
     */
    _setGpio(pinNo, value) {
        var pin = new Gpio(pinNo, 'out') //use GPIO pin 4, and specify that it is output
        if (value === true || value === 'on' || value === 1 || value === '1') {
            pin.writeSync(1)
        } else {
            pin.writeSync(0)
        }
        pin.unexport()
    }

    /**
     * Maps a topic to an associated pin configuration
     * @param {string} topic topic provided by the message
     * @returns {{ gpio:integer, invers:boolean }} gpio number and invers logic flag associated to this topic
     */
    _topicToConfig(topic) {
        const switches = this._options.switches
        const gpioConfig = switches[topic]
        if (gpioConfig === undefined) {
            throw 'Unknown topic: ' + topic
        }
        return gpioConfig
    }

    /**
     * 
     * @param {string|boolean|integer} value value of the switch
     * @param {boolean} config.invers true, if the switch logig is invers
     */
    _calcGpioValue(value, config) {
        let resultValue = value === 'on' || value === true || value === 'true' || value === 1 || value === '1'
        if (config.invers) {
            resultValue = !resultValue
        }
        return resultValue === true ? 1 : 0
    }

    /**
     * Processes an incoming mqtt message
     * @param {Message} message mqtt message
     */
    handleMessage (message) {
        try {
            const { topic, value } = message
            const config = this._topicToConfig(topic)
            const { gpio } = config
            const gpioValue = this._getValue(value, config)
            this._setGpio(gpio, gpioValue)

        } catch (err) {
            errorLog(err, DEBUG)
        }
    }
    
    /**
     * 
     */
    async close () {
    }
}

module.exports = Raspberry
