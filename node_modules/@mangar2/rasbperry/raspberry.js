/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * Provides a service to invoke broker messages from external networks. Allows only configured messages.
 */

'use strict'

const { errorLog, Callbacks } = require('@mangar2/utils')
const Message = require('@mangar2/message')
const sanitizeConfiguration = require('@mangar2/rasbperry/configuration')
var Gpio = require('onoff').Gpio; //include onoff to interact with the GPIO

/**
 * Service configuration
 * @typedef {Object} Service
 * @property {string} path path of the service
 * @property {string} reason service usage information used as reason string
 * @property {number} [qos = 1] quality of service
 * @property {Object} devices key: topic list
 */

/**
 * Creates a remote service
 * @param {Object} [options={}] remote server parameter
 * @param {Service[]} options.services list of supported services
 */
class Raspberry {
    constructor (options = {}) {
        this._options = sanitizeConfiguration(options)
        this._callbacks = new Callbacks(['publish'])
    }

    /**
     * Sets a callback.
     * @param {string} event event name (not case sensitive) for the callback
     * @param {function} callback function(...parameter)
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on (event, callback) {
        this._callbacks.on(event, callback)
    }

    /**
     * 
     * @param {number} pin number of the pin to set
     * @param {boolean} value new status of the pin
     */
    _setPin(pinNo, value) {
        var pin = new Gpio(pinNo, 'out'); //use GPIO pin 4, and specify that it is output
        if (value === true || value === 'on' || value === 1 || value === '1') {
            pin.writeSync(1)
        } else {
            pin.writeSync(0)
        }
        pin.unexport()
    }

   /**
     * Processes an incoming mqtt message
     * @param {Message} message mqtt message
     */
    handleMessage (message) {
        try {
            const { topic, value, reason } = message
            if (this._options.switches !== undefined) {
                const pin = this._options.switches[topic]
                if (pin !== undefined) {

                }
            }
        } catch (err) {
            errorLog(err, DEBUG)
        }
    }
    

    /**
     * Publishes a command based on a service definition
     * @param {string} deviceId identifier of the device
     * @param {string|number} value value to publish
     * @param {Service} service service definition
     * @private
     */
    _publish (deviceId, value, deviceToken, service) {
        const { reason = 'remote command', qos = 1, devices } = service
        if (deviceId === undefined) {
            throw Error('DeviceId is undefined')
        }
        if (value === undefined) {
            throw Error('Value is undefined')
        }
        const topic = devices[deviceId]
        if (topic === undefined) {
            throw Error('Unknown device id %s with token %s', deviceId, deviceToken)
        }
        const message = new Message(topic, value, reason)
        message.qos = qos
        this._callbacks.invokeCallback('publish', message)
    }

     /**
     * 
     */
    async close () {
    }
}

module.exports = Raspberry
