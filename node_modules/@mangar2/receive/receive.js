/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      receive.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

'use strict';

const Log = require('@mangar2/logfilter');
const Message = require('@mangar2/message')
const Server = require('@mangar2/httpserver');
const mqttVersion = require("@mangar2/mqttversion");

module.exports = class Receive {
    
    /**
     * Creates a new server receiving messages
     * @param {number} listenerPort port to listen on
     */
    constructor(listenerPort) {
        this.log = new Log();
        this.server = new Server(listenerPort);
        this.callbacks = {};
        this.qos2Queue = {};
        let result;

        this.server.on("PUT", (payload, headers, path, res) => {
            if (path === "/publish") {
                result = this.onPublish(JSON.parse(payload), headers, res);
            } else if (path === "/log") {
                result = this.onLog(JSON.parse(payload), headers, res);
            } else {
                throw("illegal interface " + path);
            }
        })
        return result;
    }

    /**
     * Starts to listen and wait for input
     */
    listen() {
        this.server.listen();
    }

    /**
     * Callcs a callback stored to an event, if registered
     * @param {string} event event for callback
     * @param  {...any} param parameters to pass to the callback
     */
    invokeCallback(event, ...param) {
        if (this.callbacks[event] !== undefined) {
            this.callbacks[event](...param);
        }
    }

    /**
     * Sets a callback
     * @param {string} event RESTful http verb (POST, GET, PUT, PATCH, DELETE)
     * @param {function} callback(payload, qos) 
     * where payload is the http payload, headers the http headers, res the result structure and path is 
     * is the http path as string
     */
    on(event, callback) {
        let eventLowerCase = event.toLowerCase();
        if (typeof(callback === 'function')) {
            this.callbacks[eventLowerCase] = callback;
        }
    }
    
    /**
     * Receives a pubrel message
     * @param {object} payload transfer payload supposed to be empty.
     * @param {object} headers headers of the message
     * @param {object} res http result structure
     */
    onPubrel(payload, headers, res) {
        let packetid = headers.version === '1.0' ? headers.packetid : headers.id;
        let result = mqttVersion.onPubrel(headers);

        res.writeHead(result.statusCode, result.headers);
        res.end(result.payload);
    }
    
    /**
     * Stores a qos2 publish message to check for a pubrel call
     * @param {string} topic topic of the message
     * @param {number} packetid id of the packet
     */
    rememberMessage(topic, packetid) {
    }
   
    /**
     * Receives a published message
     * @param {Message} message received
     * @param {object} headers headers of the message
     * @param {object} res http result structure
     */
    onPublish(message, headers, res) {

        Message.validate(message);
        let dup = headers.dup === "1" || headers.dup === "true";
        let packetid = headers.version === '1.0' ? headers.packetid : headers.id;

        if (this.log.getLogLevel("received", message.topic) !== undefined)  {
            let reason = message.reason === undefined ? "" : message.reason[0].message;
            let dupStr = dup ? ",dup" : "";
            let qos = headers.qos;
            let valueStr = message.value === "" || message.value === undefined ? "" : "=" + message.value;
            console.log("%s (qos%s%s) received %s%s [%s]", new Date().toLocaleString(), qos, dupStr, message.topic, valueStr, reason);
        }
        
        if (headers.qos === 2 && !dup) {
            this.rememberMessage(message.topic, packetid);
        }

        if (headers.qos < 2 || !dup) {
            this.invokeCallback("publish", message, headers.qos, dup);
        }

        let result = mqttVersion.receive(headers);

        res.writeHead(result.statusCode, result.headers);
        res.end(result.payload);
    }

    /**
     * Receives a logging request
     * @param {topics} payload content received
     * @param {object} headers headers of the message
     * @param {object} res http result structure
     */
    onLog(topics, payload, res) {
        this.log.changePattern(payload);
        res.writeHead(204, {'Content-Type': 'application/json'});
        res.end('');
    }

    /**
     * Closes all connections
     */
    close() {
        this.server.close();
    }
}

