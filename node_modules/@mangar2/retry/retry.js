/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview asyncronously retries function calls several times with delay inbetween
 * Prevents parallel retry loops with the same topic.
 */

'use strict'

const Callbacks = require('@mangar2/callbacks')

/**
 * @private
 * @description
 * Helper function; sets a "topic call number" that increases with each call to retry with
 * the same topic
 * @param {Object} topicCalledList list of topics asked to retry
 * @param {string} topic name of the topic to retry
 * @returns {number} current amount of calls/retries for a topic
 */
function increaseTopicCallNumber (topicCalledList, topic) {
    if (topicCalledList[topic] === undefined) {
        topicCalledList[topic] = 0
    } else {
        topicCalledList[topic]++
    }
    return topicCalledList[topic]
}

/**
 * Waits for a period of milliseconds
 * @param {number} timeout timeout of the delay in milliseconds
 * @returns {Promise}
 * @private
 */
function delay (timeout) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve()
        }, timeout)
    })
}

/**
 * Checks, if the current retry loop is the newest retry loop for a topic
 * @param {Object} topicCalledList list of topics asked to retry
 * @param {string} topic name of the topic to retry
 * @param {number} callNumber current number of call for a topic
 * @returns {boolean} true, if the current retry loop is the newest retry loop for a topic
 * @private
 */
function isNewestTopicCall (topicCalledList, topic, callNumber) {
    return topicCalledList[topic] === callNumber
}

/**
 * Class providing a retry facility calling a callback "count" times asyncronously with a delay inbetween
 * Additionally providing a "topic" based retry ("topicRetry") with the following functionality:
 * - Asynchronously calles a global callback "count" times with a delay inbetween
 * - If no global callback is provided, it calls a callback prior registrated to the topic
 * - If topicRetry is called with a still running existing retry loop for the same topic, this existing is terminated.
 * @param {boolean} [immediateFirstCall=true] true, if the first call should happen immediately
 * @example
 * const retry = new Retry()
 * // prints 5 times hello world, with a delay of 1 second between each output
 * retry.retry(5, 1000, () => console.log("hello world"))
 * // prints hello1, world, hello2, world, hello2
 * retry.topicRetry('hello', 2, 1000, () => console.log("hello1"))
 * retry.topicRetry('world', 2, 1000, () => console.log("world"))
 * retry.topicRetry('hello', 2, 1000, () => console.log("hello2"))
 */
class Retry {
    constructor (immediateFirstCall = true) {
        this._topicCalledList = {}
        this._callbacks = new Callbacks()
        this._immediateFirstCall = immediateFirstCall
    }

    /**
     * Registers a callback for a topic
     * @param {string} topic topic to register a callback
     * @param {function()} callback called on matching topic on retries
     * @throws {Error} if the callback is not 'function'
     */
    on (topic, callback) {
        this._callbacks.on(topic, callback)
    }

    /**
     * Calls a callback function multiple times and waits between the calls.
     * @param {number} count quantity of retries
     * @param {number} delayInMilliseconds amount of milliseconds to wait between retries
     * @param {function(loopNumber)} callback function called on each retry
     * @returns {Promise} promise resolving, when all callbacks are done
     */
    async retry (count, delayInMilliseconds, callback) {
        let terminateLoop = false
        if (!this._immediateFirstCall) {
            await delay(delayInMilliseconds)
        }
        for (let loop = 0; (loop < count) && !terminateLoop; loop++) {
            if (callback !== undefined) {
                terminateLoop = await callback(loop)
            }
            await delay(delayInMilliseconds)
        }
    }

    /**
     * Stops a retry loop
     * @param {string} topic name of the retry topic
     */
    stopRetry (topic) {
        increaseTopicCallNumber(this._topicCalledList, topic)
    }

    /**
     * Calls a callback function multiple times and waits between the calls.
     * If you call "retry" with the same topic a second time, it will stop the running retry loop with the same topic
     * @param {string} topic name of the topic to retry
     * @param {number} count quantity of retries
     * @param {number} delayInMilliseconds amount of milliseconds to wait between retries
     * @param {function()} callback function called on each retry
     * @returns {Promise} promise resolving, when all callbacks are done
     */
    async topicRetry (topic, count, delayInMilliseconds, callback) {
        const topicCalledNumber = increaseTopicCallNumber(this._topicCalledList, topic)
        if (!this._immediateFirstCall) {
            await delay(delayInMilliseconds)
        }
        for (let loop = 0; (loop < count); loop++) {
            let terminateLoop = false
            if (!isNewestTopicCall(this._topicCalledList, topic, topicCalledNumber)) {
                terminateLoop = true
            } else if (callback !== undefined) {
                terminateLoop = await callback(loop)
            } else if (this.callbackList[topic] !== undefined) {
                terminateLoop = this._callbacks.invokeCallback(topic, loop)
            }
            if (terminateLoop) {
                break
            }
            await delay(delayInMilliseconds)
        }
    }
}

module.exports = Retry
