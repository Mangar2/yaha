/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const types = require('@mangar2/types')
const TopicMatch = require('@mangar2/topicmatch')
const CheckResult = require('./checkresult')

/**
 * @private
 * @description Checks, if the events map contains all required topics
 * @param {Array} topics list of required topics
 * @param {Object} events map (topic: timestamp) of recent topics
 * @returns {CehckResult} check result
 */
function _isAllIncluded (topics, events) {
    const result = new CheckResult(false, '')
    if (types.isArray(topics)) {
        result.check = true
        for (const topic of topics) {
            result.andCheck(events[topic] !== undefined, topic)
            if (!result.check) {
                break
            }
        }
    } else if (types.isString(topics)) {
        result.setCheck(events[topics] !== undefined, topics)
    }
    return result
}

/**
 * @private
 * @description Checks, if the events map matches any topics
 * @param {Array} topics list of any topics
 * @param {Object} events map (topic: timestamp) of recent topics
 * @returns {CehckResult} check result
 */
function _isAnyIncluded (topics, events) {
    const result = new CheckResult(false, '')
    const topicMatch = new TopicMatch(topics)
    for (const event in events) {
        if (topicMatch.getFirstMatch(event) !== undefined) {
            result.setCheck(true, event)
            break
        }
    }

    return result
}

/**
 * @private
 * @description Checks, if the events map is a subset of the allowed topics
 * @param {Array} allow topics of allowed topics
 * @param {Object} events map (topic: timestamp) of recent topics
 * @returns {boolean} check result
 */
function _isSubset (topics, events) {
    let result = true
    const topicMatch = new TopicMatch(topics)
    for (const event in events) {
        if (topicMatch.getFirstMatch(event) === undefined) {
            result = false
            break
        }
    }
    return result
}

/**
 * @private
 * @description Adds topics to the topic array
 * @param {string[]} topics array of topics
 * @param {string|string[]} add topics to acc
 * @returns {string[]} array of strings
 */
function _addTopics (topics, add) {
    if (types.isArray(add)) {
        topics.push(...add)
    } else if (types.isString(add)) {
        topics.push(add)
    }
    return topics
}

/**
 * @private
 * @description Checks if a list of events matches the rule
 * @param {Object} rule rule object to check events
 * @param {Array} rule.allOf list of required events
 * @param {Array} rule.anyOf list of events at least one is required
 * @param {Array} rule.noneOf list of not allowed events
 * @param {Array} rule.allow list of allowed events (if provided events not allowed and required are not allowed)
 * @param {Object} [events] map {topic: timestamp} of events
 * @returns {boolean} true, if the list of events matches the rule or if 'events' is undefined
 */
module.exports = (rule, events) => {
    let result = new CheckResult(true)
    if (events !== undefined) {
        result = _isAllIncluded(rule.allOf, events)
        if (!result.check) {
            result = _isAnyIncluded(rule.anyOf, events)
        }
        if (result.check && _isAnyIncluded(rule.noneOf, events).check) {
            result.setCheck(false)
        }
        if (result.check && types.isArray(rule.allow)) {
            const allow = [...rule.allow]
            _addTopics(allow, rule.allOf)
            _addTopics(allow, rule.anyOf)
            if (!_isSubset(allow, events)) {
                result.setCheck(false)
            }
        }
    }
    return result
}
