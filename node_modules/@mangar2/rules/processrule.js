/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const types = require('@mangar2/types')
const Decision = require('@mangar2/decision')
const Message = require('@mangar2/message')
const TopicMatch = require('@mangar2/topicmatch')
const { stringToSeconds, dateToTimeOfDayInSeconds } = require('@mangar2/time')
const { sunrise, sunset } = require('@mangar2/sun')

/**
 * Processes rules based on a set of variables
 * @param {Object} [variables={}] key/value map where key is the variable name (usually a topic string)
 * @param {Date} [date=now] current date
 */
class ProcessRule {
    constructor (variables = {}, date = new Date()) {
        this.date = date
        this.variables = variables
        this._usedVariables = {}
        this._updateVariables = true
    }

    /**
     * Sets all variables
     * @param {Object} variables key/value object containing a list of variables
     */
    set variables (variables) {
        this._variables = variables
        this._updateVariables = true
    }

    /**
     * Sets a single variable
     * @param {string} name name of the variable to set
     * @param {*} value value of the variable to set
     */
    setVariable (name, value) {
        this._variables[name] = value
    }

    /**
     * Gets the current date/time
     * @returns {Date} current date/time
     */
    get date () { return this._date }

    /**
     * Sets the current date/time
     * @param {Date} date current date
     */
    set date (date) {
        this._date = date
        this._updateVariables = true
    }

    /**
     * @private
     * Sets the calculated sun variables (sunrise/sunset/dusk/dawn)
     */
    _setDefaultVariables () {
        this._variables['/time'] = this.date
        this._variables['/sunrise'] = sunrise(this._longitude, this._latitude, this.date)
        this._variables['/civildawn'] = sunrise(this._longitude, this._latitude, this.date, 96)
        this._variables['/nauticaldawn'] = sunrise(this._longitude, this._latitude, this.date, 102)
        this._variables['/astronomicaldawn'] = sunrise(this._longitude, this._latitude, this.date, 108)
        this._variables['/sunset'] = sunset(this._longitude, this._latitude, this.date)
        this._variables['/civiltdusk'] = sunset(this._longitude, this._latitude, this.date, 96)
        this._variables['/nauticaldusk'] = sunset(this._longitude, this._latitude, this.date, 102)
        this._variables['/astronomicaldusk'] = sunset(this._longitude, this._latitude, this.date, 108)
    }

    /**
     * @private
     * Gets a value from a rule property, either directly or using the map provided by the rule
     * @param {Object|string|number} property rule property
     * @param {string|number} defaultValue value to return, if the property is not defined
     * @throws {Error} If the property includes a referenct to a variable that is not defined
     * @returns {string|number|undefined} property value
     */
    _getPropertyValue (property, defaultValue) {
        let value
        if (types.isArray(property)) {
            const result = this._eval(property)
            value = result.value
        } else if (types.isString(property) || types.isNumber(property) || types.isBoolean(property)) {
            value = property
        } else if (property !== undefined) {
            throw Error('Array, string, number, boolean expected: ' + JSON.stringify(property))
        }
        if (value === undefined || value === null) {
            value = defaultValue
        }
        return value
    }

    /**
     * @private
     * Checks, if the rule has a time constrains. The rule is valid if
     * it has a time constrains defining a time span and the current time is in the time span or it
     * has no time constrains
     * @param {Object} rule rule to check
     * @param {string} [rule.time] time of day to activate the time
     * @param {string} [rule.duration='6:00'] duration of the rule
     * @returns {boolean} true, if the rule is currently valid based on the time of day stored
     */
    _checkTime (rule) {
        let result = rule.time === undefined
        const timeString = this._getPropertyValue(rule.time)
        const ONE_DAY_IN_SECONDS = 24 * 60 * 60
        if (timeString !== undefined) {
            const durationString = this._getPropertyValue(rule.duration, '6:00')
            const timeInSeconds = stringToSeconds(timeString)
            const durationInSeconds = stringToSeconds(durationString)
            const timeOfDayInSeconds = dateToTimeOfDayInSeconds(this.date)
            const laterSameDay = timeOfDayInSeconds >= timeInSeconds && timeOfDayInSeconds < durationInSeconds + timeInSeconds
            const earlierNextDay = timeOfDayInSeconds < durationInSeconds + timeInSeconds - ONE_DAY_IN_SECONDS
            result = laterSameDay || earlierNextDay
        }

        return result
    }

    /**
     * Evaluates a JSON formatted program
     * @param {Array|boolean|string|number} term term to evaluate
     */
    _eval (term) {
        const decisionMaker = new Decision(this._variables)
        const result = decisionMaker.eval(term)
        this._usedVariables = { ...this._usedVariables, ...result.variables }
        return result
    }

    /**
     * @private
     * Evaluates the rule 'check' constrains.
     * @param {Object} rule rule to check
     * @param {string} [rule.check] check function in JSON format
     * @throws {Error} on error in the decision rule
     * @returns {boolean} true, if rule has no 'check' property or the 'check' property evaluates to true
     */
    _checkDecision (rule) {
        const value = rule.check === undefined
        const reason = ''
        let result = { value, reason }
        if (rule.check !== undefined) {
            result = this._eval(rule.check)
        }
        return result
    }

    /**
     * @private
     * Checks, if the events map contains all required topics
     * @param {Array} required list of required topics
     * @param {Object} events map (topic: timestamp) of recent topics
     */
    _isAllIncluded (required, events) {
        let result = false
        if (types.isArray(required)) {
            result = true
            for (const topic of required) {
                if (events[topic] === undefined) {
                    result = false
                    break
                }
            }
        } else if (types.isString(required)) {
            result = events[required] !== undefined
        }
        return result
    }

    /**
     * @private
     * Checks, if the events map contains any denied topics
     * @param {Array} any list of any topics
     * @param {Object} events map (topic: timestamp) of recent topics
     */
    _isAnyIncluded (any, events) {
        let result = false
        const topicMatch = new TopicMatch(events)
        if (types.isArray(any)) {
            for (const topic of any) {
                if (topicMatch.getFirstMatch(topic) !== undefined) {
                    result = true
                    break
                }
            }
        } else if (types.isString(any)) {
            result = topicMatch.getFirstMatch(any) !== undefined
        }

        return result
    }

    /**
     * @private
     * Checks, if the events map is a subset of the allowed topics
     * @param {Array} allow list of allowed topics
     * @param {Object} events map (topic: timestamp) of recent topics
     */
    _isSubset (allow, events) {
        let result = true
        const topicMatch = new TopicMatch(allow)
        for (const topic in events) {
            if (topicMatch.getFirstMatch(topic) === undefined) {
                result = false
                break
            }
        }
        return result
    }

    /**
     * Adds topics
     * @param {string[]} rules array of topics
     * @param {string|string[]} add topics to acc
     * @returns {string[]} array of strings
     */
    _addTopics (topics, add) {
        if (types.isArray(add)) {
            topics.push(...add)
        } else if (types.isString(add)) {
            topics.push(add)
        }
        return topics
    }

    /**
     * Checks if a list of events matches the rule
     * @param {Object} rule rule object to check events
     * @param {Array} rule.require list of required events
     * @param {Array} rule.deny list of not allowed events
     * @param {Array} rule.allow list of allowed events (if provided events not allowed and required are not allowed)
     * @param {Object} [events] map {topic: timestamp} of events
     * @returns {boolean} true, if the list of events matches the rule or if 'events' is undefined
     */
    _checkEvents (rule, events) {
        let result = true
        if (events !== undefined) {
            result = false
            if (this._isAllIncluded(rule.requireAll, events) || this._isAnyIncluded(rule.requireAny, events)) {
                if (!this._isAnyIncluded(rule.deny, events)) {
                    result = true
                    if (types.isArray(rule.allow)) {
                        const allow = [...rule.allow]
                        this._addTopics(allow, rule.requireAll)
                        this._addTopics(allow, rule.requireAny)
                        result = this._isSubset(allow, events)
                    }
                }
            }
        }
        return result
    }

    /**
     * Adds a list of topics to the used variables
     * @param {Array} topics list of topics to add
     */
    _addToUsedVariables (topics) {
        if (types.isArray(topics)) {
            for (const topic of topics) {
                const value = this._variables[topic]
                this._usedVariables[topic] = value
            }
        }
    }

    /**
     * Gets a list of needed variables for the rule
     * @param {Object} rule rule to check
     */
    determineNeededVariables (rule) {
        this._checkTime(rule)
        this._checkDecision(rule)
        this._getPropertyValue(rule.value)
        this._addToUsedVariables(rule.require)
        this._addToUsedVariables(rule.allow)
        this._addToUsedVariables(rule.deny)
        return this._usedVariables
    }

    /**
     * @private
     * Checks if there are any unknown variables
     * @param {Object} usedVariables key/value map of used variables
     * @returns {boolean} true, if any variable is unknown
     */
    _includesUnknownVariables (usedVariables) {
        let result = false
        for (const variable in usedVariables) {
            if (usedVariables[variable] === undefined) {
                result = true
                break
            }
        }
        return result
    }

    /**
     * Creates messages based on a rule
     * @param {Object} rule rule to check
     * @param {Object} decisionResult evaluation result of the rule "check" property
     * @param {string} decisionResult.reason expains the rule evaluation
     * @returns {{messages: Message[], usedVariables}} Array of messages and object of variables used.
     */
    _getMessagsFromRule (rule, decisionResult) {
        const result = { usedVariables: {}, messages: [] }
        const { topic, name } = rule
        const value = this._getPropertyValue(rule.value)
        let reason = 'Rule: ' + name
        if (decisionResult.reason !== '') {
            reason += ', ' + decisionResult.reason
        }
        if (types.isArray(topic)) {
            for (const oneTopic of topic) {
                result.messages.push(new Message(oneTopic, value, reason, this._date))
            }
        } else {
            result.messages.push(new Message(topic, value, reason, this._date))
        }
        return result
    }

    /**
     * Processes a rule and if the rule demands, create a message
     * @param {Object} rule rule to check
     * @param {Object} [events] map {topic: timestamp} of events
     * @throws {Error} on error in the decision rule
     * @returns {{messages: Message[], usedVariables}} Array of messages and object of variables used.
     */
    check (rule, events) {
        if (this._updateVariables) {
            this._setDefaultVariables()
        }
        let result = { usedVariables: {}, messages: [] }

        if (this._checkTime(rule)) {
            const decisionResult = this._checkDecision(rule)
            if (decisionResult.value) {
                if (this._checkEvents(rule, events)) {
                    result = this._getMessagsFromRule(rule, decisionResult)
                }
            }
        }
        result.usedVariables = this._usedVariables
        return result
    }
}

module.exports = ProcessRule
