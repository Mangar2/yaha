/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */
'use strict'

const types = require('@mangar2/types')
const checkRule = require('./checkrule')

/**
 * @typedef {Object} Rule
 * @property {string} name name of the rule
 * @property {object|string} time time, when the rule will be activated
 * @property {integer} doLog true, if the rule shall be logged
 */

/**
 * @description Creates an object holding automation rules
 * @param {Object} rulesTree rules tree
 * @param {CheckInput} check definition to check the validity of a rule
 * @example
 * const rulesTree =
 *  {
 *       location1: {
 *           rules: {
 *               rule1: {
 *                   title: 'hello'
 *               },
 *               rule2: {
 *                   title: 'world'
 *               }
 *           }
 *       },
 *       location2: {
 *           rule1: {
 *               error: 'faulty rule'
 *           }
 *       }
 *   }
 * const checkRule = new CheckInput({ type: 'object', properties: { title: { type: string } }, required: ['title'] })
 * const rules = new Rules(rulesTree, checkRules)
 * console.log(rules.rules.length) // prints 1, we have one correct rule
 * console.log(rules.invalidRules[0].messages) // prints the error messages for rule 'location2'
 */
class Rules {
    constructor (rulesTree) {
        this._rules = {}
        this._parseRules(rulesTree)
    }

    /**
     * @description Get the valid rules list
     * @returns {Rule[]} array of rules
     */
    get rules () { 
        const result = []
        for (const index in this.rules) {
            const rule = this.rules[index]
            result.push(rule)
        }
        return result 
    }

    /**
     * @description Get the invalid rules list
     * @returns {Rule[]} array of invalid rules 
     */
    get invalidRules () { 
        const result = []
        for (const index in this.rules) {
            const rule = this.rules[index]
            if (rule.isValid === false) {
                result.push(rule)
            }
        }
        return result
    }

    /**
     * Finds a rule in the rule list
     * @param {string} name name of the rule
     * @returns {Rule | null} rule found or null
     */
    findRule(name) {
        for (const index in this.rules) {
            const rule = this.rules[index]
            if (rule.name === name) {
                return rule
            } 
        }
        return null
    }

    /**
     * @description Invalidates a rule, because it generates an error
     * @param {string} name name of the rule to invalidate
     * @param {string[]} [messages] error messages
     */
    invalidateRule(name, messages = []) {
        if (!this.rules[name]) {
            return
        }
        this.rules[name].isValid = false
        this.rules[name].errors = messages
    }

    /**
     * Deletes a rule
     * @param {Rule} rule rule to delete
     */
    deleteRule(rule) {
        delete this.rules[rule.name]
    }

    /**
     * Adds or updates a rule to the list of rules, checks its validity and sets a "isValid" property accordingly
     * @param {Rule} rule to set
     * @returns true, if the rule is valid
     */
    setRule(rule) {
        const isValid = checkRule.validate(rule)
        this.rules[rule.name] = rule
        if (!isValid) {
            this.invalidateRule(rule.name, checkRule.messages)
        }
        return rule.isValid
    }

    /**
     * Adds a rule to a tree node recursively
     * @param {Object} node current tree node
     * @param {string[]} nameChunks remaining chunks of the rule name
     * @param {Rule} rule rule
     */
    _addToNodeRec(node, nameChunks, rule) {
        const chunks = [...nameChunks]
        if (chunks.length > 1) {
            const curChunk = chunks.shift()
            if (node[curChunk] === undefined) {
                node[curChunk] = {}
            }
            this._addToNodeRec(node[curChunk], chunks, rule)
        } else if (chunks.length === 1) {
            const curChunk = chunks[0]
            if (node['rules'] === undefined) {
                node['rules'] = {}   
                node['rules'][curChunk] = rule
            }
        }
        return node
    }

    /**
     * Returns all rules in a tree of rules
     * @returns all rules organized in a tree based on the names 
     */
    getRuleTree() {
        const result = {}
        for (const index in this._rules) {
            const rule = this._rules[index]
            const nameChunks = rule.name.split('/')
            this._addToNodeRec(result, nameChunks, rule)
        }
        return result
    }

    /**
     * @private
     * @description Parses a tree of rules and puts every rule in an array
     * @param {Object} node node in the rule tree
     * @param {string} link path to current node in the rule tree
     */
    _parseRules (node, link = '') {
        if (types.isObject(node)) {
            for (const key in node) {
                if (key === 'rules') {
                    for (const ruleIndex in node[key]) {
                        const rule = node[key][ruleIndex]
                        rule.name = link === '' ? ruleIndex : link + '/' + ruleIndex
                        this.setRule(rule)
                    }
                } else {
                    const childNode = node[key]
                    const childLink = link + '/' + key
                    this._parseRules(childNode, childLink)
                }
            }
        }
    }


}

module.exports = Rules
