/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */
'use strict'

const VERBOSE = false
const { ProcessRule } = require('@mangar2/rules')
const { timeOfDayStringToDate } = require('@mangar2/time')

const Testrun = require('@mangar2/testrun')
const testrun = new Testrun(VERBOSE)

/**
 * Gets an event list in the right format {topic:date, ...}
 * @param {Array} events array of events
 * @param {Date} date test date/time
 * @returns {Object} event list in right format
 */
function formatEvents (events, date) {
    const result = {}
    if (events !== undefined) {
        for (const event of events) {
            result[event] = date
        }
    }
    return result
}

testrun.on('prepare', testcase => {
    const processRule = new ProcessRule(new Date())
    let { rule, rules } = testcase
    rules = rules ? rules : { 'rule': rule }
    return { processRule, rules }
})

function runTest (test, testObjects) {
    const { processRule, rules } = testObjects
    const checkTime = test.time !== undefined ? timeOfDayStringToDate(test.time) : new Date()
    // const testRules = new Rules(rules, checkRule)
    const motionEvents = formatEvents(test.motionEvents, checkTime)
    const nonMotionEvents = formatEvents(test.nonMotionEvents, true)
    processRule.variables = test.variables
    processRule.date = checkTime
    const result = { messages: [], usedVariables: {}}
    for (const index in rules) {
        const rule = rules[index]
        processRule.determineNeededVariables(rule)
        const check = processRule.check(rule, motionEvents, nonMotionEvents)
        result.messages = [...result.messages, ...check.messages]
        result.usedVariables = {...result.usedVariables, ...check.usedVariables}
    }
    testrun.unitTest.replaceRec(test.expected, { '<time>': checkTime })
    return result
}

testrun.on('run', (test, testObjects) => {
    return runTest(test, testObjects)
})

testrun.on('break', (test, testObjects) => {
    runTest(test, testObjects)
})


testrun.run(
    [
        'isactive',
        'activation',
        'cooldown',
        'delay',
        'time',
        'value',
        'variables',
        'require',
        'allow',
        'deny',
        'timecalc'
    ],
    __dirname, 98)

