/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */
'use strict'

const VERBOSE = true
const types = require('@mangar2/types')
const { checkRule, Rules, ProcessRule } = require('@mangar2/rules')
const { timeOfDayStringToDate } = require('@mangar2/time')

const Testrun = require('@mangar2/testrun')
const testrun = new Testrun(VERBOSE)

const rulesTree =
{
    motion: {
        rules: {
            setReceived: {
                anyOf: [
                    '$SYS/presence/set', 'system/presence/set'
                ],
                topic: {
                    '$SYS/presence': ['switch', '$SYS/presence/set', {
                        0: 'absent', 1: 'awake', absent: 'absent', sleeping: 'sleeping', awake: 'awake'
                    }],
                    'system/presence': ['switch', '$SYS/presence/set', {
                        0: 'absent', 1: 'awake', absent: 'absent', sleeping: 'sleeping', awake: 'awake'
                    }],
                    'outdoor/garden/main/switch/lightstairs/blink': ['switch', '$SYS/presence/set', {
                        0: '1', 1: '2', absent: '1', sleeping: '0', awake: '2'
                    },
                    {
                        '$SYS/alarm': 'off'
                    }]
                }
            },
            sleeping: {
                durationWithoutMovementInMinutes: 15,
                allOf: [
                    'ground/motion'
                ],
                allow: [
                    'first/motion'
                ],
                topic: 'system/presence',
                value: 'sleeping'
            },
            awake: {
                durationWithoutMovementInMinutes: 0,
                noneOf: [
                    'ground/motion'
                ],
                topic: 'system/presence',
                value: 'awake'
            },
            absent: {
                type: 'motion',
                durationWithoutMovementInMinutes: 15,
                allOf: [
                    'ground/motion'
                ],
                allow: [
                    'first/motion'
                ],
                topic: 'system/presence',
                value: 'absent'
            }
        }
    }
}

const rules = new Rules(rulesTree, checkRule)
testrun.unitTest.assertEqual(rules.rules.length, 2, 'two legal rules')
testrun.unitTest.assertEqual(rules.invalidRules.length, 2, 'two invalid rules')

rules.invalidateRule('/motion/sleeping', 'syntax error')
testrun.unitTest.assertEqual(rules.rules.length, 1, 'one legal rule')
testrun.unitTest.assertEqual(rules.invalidRules.length, 3, 'two invalid rules')
testrun.unitTest.assertEqual(rules.invalidRules[2].messages, 'syntax error', 'two invalid rules')

/**
 * checks a property result of a test case
 * @param {string} property name of the property to check
 * @param {Message[]} messages list of result messages to check
 * @param {Object} test test case to check
 */
function checkResult (property, messages, test) {
    if (test[property] !== undefined) {
        const testArray = types.isArray(test[property]) ? test[property] : [test[property]]
        if (messages.length >= testArray.length) {
            for (const index in testArray) {
                const curTest = testArray[index]
                const message = messages[index]
                testrun.unitTest.assertEqual(message[property], curTest, test.name)
            }
        } else {
            testrun.unitTest.fail('not enough messages provided ' + test.name)
        }
    }
}

/**
 * Gets an event list in the right format {topic:date, ...}
 * @param {Array} events array of events
 * @param {Date} date test date/time
 * @returns {Object} event list in right format
 */
function formatEvents (events, date) {
    const result = {}
    if (events !== undefined) {
        for (const event of events) {
            result[event] = date
        }
    }
    return result
}

testrun.on('prepare', testcase => {
    const process = new ProcessRule(new Date())
    return { process, rule: testcase.rule }
})

function runTest (test, testObjects) {
    const { process, rule } = testObjects
    const checkTime = test.time !== undefined ? timeOfDayStringToDate(test.time) : new Date()
    const testRules = new Rules({ rules: { rule } }, checkRule)
    const motionEvents = formatEvents(test.motionEvents, checkTime)
    const nonMotionEvents = formatEvents(test.nonMotionEvents, true)
    process.variables = test.variables
    process.date = checkTime
    process.determineNeededVariables(testRules.rules[0])
    const check = process.check(testRules.rules[0], motionEvents, nonMotionEvents)
    return { testRules, check }
}

testrun.on('run', (test, testObjects) => {
    return runTest(test, testObjects)
})

testrun.on('break', (test, testObjects) => {
    runTest(test, testObjects)
})

testrun.on('validate', (test, result, path) => {
    const { testRules, check } = result
    let validate = true
    validate &&= testrun.unitTest.assertEqual(testRules.invalidRules.length, 0, 'Invalid test rule(s): "' + path)
    validate &&= testrun.unitTest.assertEqual(testRules.rules.length, 1, 'Must have exactly one valid rule "' + path)
    validate &&= testrun.unitTest.assertEqual(check.messages.length, test.messages, 'False result message amount ' + path)
    if (check.messages.length <= 1) {
        if (test.value !== undefined) {
            validate &&= testrun.unitTest.assertEqual(test.value, check.messages[0].value, 'Value does not match ' + path)
        }
        if (test.topic !== undefined) {
            validate &&= testrun.unitTest.assertEqual(test.topic, check.messages[0].topic, 'Topic does not match ' + path)
        }
    } else {
        if (test.value !== undefined) {
            test.value.forEach((value, index) => {
                validate &&= testrun.unitTest.assertEqual(value, check.messages[index].value, 'message: ' + index + ' Value does not match ' + path)
            })
        }
        if (test.topic !== undefined) {
            test.topic.forEach((topic, index) => {
                validate &&= testrun.unitTest.assertEqual(topic, check.messages[index].topic, 'message: ' + index + ' Topic does not match ' + path)
            })
        }
    }

    if (!validate) {
        testrun.runAgain()
    }

    checkResult('topic', check.messages, 'topic ' + path)
    checkResult('value', check.messages, 'value ' + path)
    checkResult('qos', check.messages, 'qos ' + path)
})

testrun.run(
    [
        'activation',
        'cooldown',
        'delay',
        'time',
        'value',
        'variables',
        'require',
        'allow',
        'deny',
        'timecalc'
    ],
    __dirname)

testrun.unitTest.showResult(327)
