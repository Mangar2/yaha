/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * Interface service to communicate with several arduino or similar microcontroller based on a serial interface
 */

'use strict'
const DEBUG = false
const { Callbacks, errorLog, delay } = require('@mangar2/utils')
const { SerialConnection } = require('@mangar2/serialhelper')
const ParseSerialData = require('./parseserialdata')
const SerialDNS = require('./serialdns')
const RS485Schedule = require('./rs485schedule')
const sanitizeConfiguration = require('./configuration')
const Actions = require('./actions')
const deriveSubscribes = require('./derivesubscribes')
const MatchMessages = require('@mangar2/matchmessages')

/**
 * Callback to publish messages to the mqtt broker
 * @callback Publish
 * @param {Message} message message to publish
 */

/**
 * Creates a service class to communicate with several arduino over a serial bus
 * @param {Object} options configuration options
 * @param {string} options.serialPortName name of the port to use
 * @param {integer} [options.baudrate=57600] baud rate to be used
 * @param {integer} [options.tickDelay=100] inner clock managing the token, every action is calculated
 * @param {0|1|2} [options.qos=1] quality of service to send messages
 * @param {string} [options.trace='messages'] trace level, supported errors, messages, token
 */
class SerialDevice {
    constructor (options) {
        options = sanitizeConfiguration(options)
        this._serial = new SerialConnection()
        this._callbacks = new Callbacks(['publish'])
        this._parser = new ParseSerialData()
        this._serialDNS = new SerialDNS(options)

        this._schedule = new RS485Schedule(options)
        this._actions = new Actions(options)
        this._matchMessages = new MatchMessages()
        this._options = options
        this._timeOfDayDelayInSeconds = options.timeOfDayDelayInSeconds
        this._close = false
    }

    /**
     * Sets a callback.
     * @param {string} event event name (not case sensitive) for the callback (supported: 'publish')
     * @param {Publish} callback function(...parameter)
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on (event, callback) {
        this._callbacks.on(event, callback)
    }

    /**
     * Publishes mqtt messages to the broker
     * @param {Message[]} mqttMessages messages to publish
     * @private
     */
    _publish (mqttMessages) {
        for (let message of mqttMessages) {
            message = this._matchMessages.matchAndUpdateReplyMessage(message)
            message.qos = this._options.qos
            this._callbacks.invokeCallback('publish', message)
        }
    }

    /**
     * Processes a received serial message
     * @param {Object} receivedObject received object
     * @private
     */
    _processReceivedObject (receivedObject) {
        try {
            if (receivedObject) {
                const mqttMessages = this._serialDNS.toMqttMessages(receivedObject)
                this._actions.storeState(mqttMessages)
                this._publish(mqttMessages)
            }
        } catch (err) {
            errorLog(err, DEBUG)
        }
    }

    /**
     * Traces serial input
     * @param {Object} receivedObject
     * @private
     */
    _traceInfo (receivedObject) {
        const { sender, receiver, key, value } = receivedObject
        const { trace } = this._options
        if (trace === 'objects') {
            const now = new Date()
            console.log('%s %s => %s %s = %s', now.toLocaleTimeString(), sender, receiver, key, value)
        }
    }

    /**
     * Sends data to a serial device
     * @param {Array} byteArray array of bytes
     * @private
     */
    async _sendDataToSerial (byteArray) {
        try {
            await this._serial.sendData(byteArray)
        } catch (err) {
            errorLog(err, DEBUG)
            this._openSerialInterface()
        }
    }

    /**
     * Opens the serial interface
     * @private
     */
    async _openSerialInterface () {
        const RETRY = 10
        const DELAY_FOR_RETRY_IN_SECONDS = 15
        let loop = 1
        if (this._isSerialInterfaceOpen) {
            await this._serial.close()
            this._isSerialInterfaceOpen = false
        }
        while (!this._isSerialInterfaceOpen) {
            try {
                await this._serial.open(this._options.serialPortName, this._options.baudrate)
                this._isSerialInterfaceOpen = true
            } catch (err) {
                errorLog(err, DEBUG)
                await this._serial.listAvailablePorts()
                console.log('Retry in %s seconds %s/%s', DELAY_FOR_RETRY_IN_SECONDS, loop, RETRY)
                loop++
                if (loop >= RETRY) {
                    throw err
                }
                await delay(DELAY_FOR_RETRY_IN_SECONDS * 1000)
            }
        }
    }

    /**
     * Starts the server
     */
    async run () {
        this._serial.on('data', (byteArray) => {
            const receivedObject = this._parser.parse(byteArray)
            if (receivedObject !== null) {
                this._traceInfo(receivedObject)
                this._processReceivedObject(receivedObject)
            }
        })
        try {
            await this._openSerialInterface()
            this._schedule.on('send', async (byteArray) => {
                return this._sendDataToSerial(byteArray)
            })
            this._schedule.on('trace', serialInfo => {
                this._traceInfo(serialInfo)
            })
            this._runSendTimeOfDay()
            this._schedule.run()
            console.log('rs485 service running')
        } catch (err) {
            errorLog(err, DEBUG)
            this.close()
        }
    }

    /**
     * Stops the service
     */
    async close () {
        this._close = true
        try {
            await this._schedule.close()
            await this._serial.close()
        } catch (err) {
            errorLog(err, DEBUG)
        }
        console.log('rs485 service closed')
    }

    /**
     * Processes an incoming mqtt message
     * @param {Message} message mqtt message
     */
    processMessage (message) {
        try {
            if (message.topic === '$SYS/rs485Interface/trace/set') {
                this._options.trace = message.value
            } else {
                message.addReason('received by RS485Interface service')
                this._matchMessages.addReceivedMessage(message)
                this._actions.processMessage(message, (actionMessage) => {
                    try {
                        const serialMessage = this._arduinoDNS.toSerialMessage(actionMessage)
                        serialMessage.reply = true
                        this._schedule.sendMessage(serialMessage)
                    } catch (err) {
                        errorLog(err, DEBUG)
                    }
                })
            }
        } catch (err) {
            errorLog(err, DEBUG)
        }
    }

    /**
     * Gets the list of required subscriptions for this service
     * @returns {{topic: string, qos: number}[]} list of subscription strings
     */
    getSubscriptions () {
        return deriveSubscribes(this._options)
    }
}

module.exports = SerialDevice
