/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * Interface service to communicate with several arduino or similar microcontroller based on a serial interface
 */

'use strict'
const DEBUG = false
const { Callbacks, errorLog, delay } = require('@mangar2/utils')
const { SerialConnection } = require('@mangar2/serialhelper')
const MatchMessages = require('@mangar2/matchmessages')

const Actions = require('./actions')
const { deriveSubscribes } = require('./derivesubscribes')
const sanitizeConfiguration = require('./configuration')
const MQTTToSerial = require('./mqtttoserial')
const { serialMessageToString } = require('./serialMessageToString')

const SerialToMQTT = require('./serialtomqtt')
const ParseSerialData = require('./parseserialdata')

/**
 * Callback to publish messages to the mqtt broker
 * @callback Publish
 * @param {Message} message message to publish
 */

/**
 * Creates a service class to communicate with several arduino over a serial bus
 * @param {Object} options configuration options
 * @param {string} options.serialPortName name of the port to use
 * @param {integer} [options.baudrate=57600] baud rate to be used
 * @param {0|1|2} [options.qos=1] quality of service to send messages
 * @param {string} [options.trace='messages'] trace level, supported: errors, messages, internal
 */
class SerialDevice {
    constructor (options) {
        this._options = sanitizeConfiguration(options)
        this._callbacks = new Callbacks(['publish'])
        this._matchMessages = new MatchMessages()
        this._serial = new SerialConnection()

        this._mqttToSerial = new MQTTToSerial(this._options)
        this._parseSerialData = new ParseSerialData()
        this._serialToMqtt = new SerialToMQTT(this._options)
        this._actions = new Actions(this._options)
        this._close = false
    }

    /**
     * Sets a callback.
     * @param {string} event event name (not case sensitive) for the callback (supported: 'publish')
     * @param {Publish} callback function(...parameter)
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on (event, callback) {
        this._callbacks.on(event, callback)
    }

    /**
     * Publishes mqtt messages to the broker
     * @param {Message[]} mqttMessages messages to publish
     * @private
     */
    _publish (mqttMessages) {
        for (let message of mqttMessages) {
            message = this._matchMessages.matchAndUpdateReplyMessage(message)
            message.qos = this._options.qos
            this._callbacks.invokeCallback('publish', message)
        }
    }

    /**
     * Processes a received serial message
     * @param {string} serialData data received from serial interface
     * @private
     */
    _processReceivedData (serialData) {
        try {
            const serialMessage = this._parseSerialData.parse(serialData)
            this._traceInfo(serialMessage)
            if (serialMessage) {
                const mqttMessages = this._serialToMqtt.toMqttMessages(serialMessage)
                this._publish(mqttMessages)
            }
        } catch (err) {
            errorLog(err, DEBUG)
        }
    }

    /**
     * Traces serial input
     * @param {Object} receivedObject
     * @private
     */
    _traceInfo (serialMessage) {
        const { trace } = this._options
        if (trace === 'internal') {
            const now = new Date()
            console.log('%s %s', now.toLocaleTimeString(), serialMessage.toString())
        }
    }

    /**
     * Sends data to a serial device
     * @param {string} serialString array of bytes
     * @private
     */
    async _sendDataToSerial (serialString) {
        let retry = 3
        while (retry > 0) {
            try {
                await this._serial.send(serialString)
                retry = 0
            } catch (err) {
                errorLog(err, DEBUG)
                if (retry === 0) {
                    throw err
                }
                await this._openSerialInterface()
                retry--
            }
        }
    }

    /**
     * Opens the serial interface
     * @private
     */
    async _openSerialInterface () {
        const RETRY = 10
        const DELAY_FOR_RETRY_IN_SECONDS = 15
        let loop = 1
        if (this._isSerialInterfaceOpen) {
            await this._serial.close()
            this._isSerialInterfaceOpen = false
        }
        while (!this._isSerialInterfaceOpen) {
            try {
                await this._serial.open(this._options.serialPortName, this._options.baudrate)
                this._isSerialInterfaceOpen = true
            } catch (err) {
                errorLog(err, DEBUG)
                await this._serial.listAvailablePorts()
                console.log('Retry in %s seconds %s/%s', DELAY_FOR_RETRY_IN_SECONDS, loop, RETRY)
                loop++
                if (loop >= RETRY) {
                    throw err
                }
                await delay(DELAY_FOR_RETRY_IN_SECONDS * 1000)
            }
        }
    }

    /**
     * Starts the server
     */
    async run () {
        this._serial.on('data', (serialData) => {
            this._processReceivedData(serialData)
        })
        try {
            await this._openSerialInterface()
            console.log('Serial service is running')
        } catch (err) {
            errorLog(err, DEBUG)
            this.close()
        }
    }

    /**
     * Stops the service
     */
    async close () {
        this._close = true
        try {
            await this._serial.close()
        } catch (err) {
            errorLog(err, DEBUG)
        }
        console.log('serial device service closed')
    }

    /**
     * Processes an incoming mqtt message
     * @param {Message} mqttMessage mqtt message
     */
    processMessage (mqttMessage) {
        try {
            if (mqttMessage.topic === '$SYS/serialInterface/trace/set') {
                this._options.trace = mqttMessage.value
            } else {
                mqttMessage.topic = mqttMessage.topic.replace('/set', '')
                mqttMessage.addReason('received by RS485Interface service')
                this._matchMessages.addReceivedMessage(mqttMessage)
                this._actions.processMessage(mqttMessage, (actionMessage) => {
                    try {
                        const serialMessage = this._mqttToSerial.toSerialMessage(actionMessage)
                        const serialString = serialMessageToString(serialMessage)
                        this._sendDataToSerial(serialString)
                    } catch (err) {
                        errorLog(err, DEBUG)
                    }
                })
            }
        } catch (err) {
            errorLog(err, DEBUG)
        }
    }

    /**
     * Gets the list of required subscriptions for this service
     * @returns {{topic: string, qos: number}[]} list of subscription strings
     */
    getSubscriptions () {
        return deriveSubscribes(this._options)
    }
}

module.exports = SerialDevice
