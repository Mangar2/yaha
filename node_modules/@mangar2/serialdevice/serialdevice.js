/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const SerialConnection = require('./serialconnection')
const errorLog = require('@mangar2/errorlog')
const Retry = require('@mangar2/retry')
const Message = require('@mangar2/message')
const arduinoDNS = new (require('./arduinodns'))()

const Devices = require('@mangar2/devices')
const devicesConfig = require('../../../devices.json')

/**
 * @private
 * Check configuration
 */

const messageLog = {}

class SerialDevice {
    constructor (configuration) {
        this._serial = new SerialConnection(configuration)
        this._retry = new Retry()
        this._devices = new Devices(devicesConfig)

        this._serial.on('data', (object) => {
            try {
                processArduinoMessage(object, messageLog)
            } catch (err) {
                errorLog(err)
            }
        })
    }

    /**
     * @private
     * sends a command to the microcontoller attached over the serial connection
     * @param {Object} addressAndKey {address: address, key: key} address and key of the command
     * @param {Message} message message structure with topic, value and reason
     */
    _sendCommand (addressAndKey, message) {
        const { address, key } = addressAndKey
        const command = 'C' + address + key + message.value
        this._serial.send(command)
    }

    /**
     * @private
     * Sends a command for a microcontroller having a FS20 UART connected
     * @param {string} topic current topic
     * @param {string} reason message reason
     * @param {string} address FS20 address of the item
     * @param {number} retry amount of retries
     * @param {bool} value "on", swith on, "off", switch off
     * @returns {Message} reply message
     */
    async _sendFS20Command (topic, reason, address, retry, value) {
        const delayInSeconds = 5
        if (retry === undefined) {
            retry = 1
        }
        if (address === undefined || address === '') {
            throw 'address not defined'
        }
        const commandValue = value === 'on' ? '1' : '0'
        const command = 'G' + address + commandValue
        this._retry.topicRetry(address, retry, delayInSeconds * 1000, () =>
            this._serial.send(command)
        )

        const message = new Message(topic, value, reason)
        message.addReason('send FS20 remote command (unidirectional)')
        message.qos = 1
        return [message]
    }

    /**
     * @private
     * Switches a relay connected to the microcontroller
     * @param {number} index index of the relay
     * @param {string} value "on" or "off"
     */
    _switchReleay (index, value) {
        const commandValue = value === 'on' ? 'H' : 'L'
        const command = 's' + index + commandValue
        this._serial.send(command)
    }

    /**
     * @private
     * Switches a device on or off
     * @param {string} baseTopic topic string without "set"
     * @param {string} value "on" to switch on and "off" to switch off
     * @param {Object} reason array of reasons why switching
     * @returns {Message[]} array of messages to be sent to the broker
     */
    _switchDevice (baseTopic, value, reason) {
        const device = this._devices.topicToDevice(baseTopic)
        let messages = []
        if (device !== undefined) {
            if (device.fs20 !== undefined) {
                messages = this._sendFS20Command(baseTopic, reason, device.fs20, device.retry, value)
            } else if (device.arduinoSwitch !== undefined) {
                if (device.hibernateCommand !== undefined) {
                    messages = [new Message(baseTopic, 'hibernate', 'i2c: switch off received')]
                    hibernate(baseTopic, value, device.hibernateCommand, (value) => {
                        this._switchReleay(device.arduinoSwitch, value)
                    })
                } else {
                    this._switchReleay(device.arduinoSwitch, value)
                }
            } else {
                console.log('device not defined %s ', baseTopic)
                console.log(device)
            }
        }
        return messages
    }

    /**
     * Processes a message received from an i2c arduino
     * @param {Message} message received message with topic and value
     */
    processMessage (message) {
        const { topic, value, reason } = message

        const retry = 1
        console.log('%s received %s = %s (retry: %d)', new Date().toLocaleTimeString(), topic, value, retry)
        const baseTopic = topic.replace('/set', '')

        message.addReason('send to arduino')
        messageLog[baseTopic] = { timestamp: (new Date()).getTime(), message: message }

        const addressAndKey = arduinoDNS.getAddressAndKey(baseTopic)
        if (addressAndKey !== undefined) {
            this._sendCommand(addressAndKey, message)
        } else {
            this._switchDevice(baseTopic, value, reason)
        }
    }
}

module.exports = SerialDevice
