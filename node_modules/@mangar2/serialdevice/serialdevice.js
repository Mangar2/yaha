/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const SerialConnection = require('./serialconnection')
const errorLog = require('@mangar2/errorlog')
const Retry = require('@mangar2/retry')
const Message = require('@mangar2/message')
const TopicMap = require('@mangar2/topicmap')
const topicMapData = require('./topicmap.json')
const keyMap = require('./key.json')

/**
 * @private
 * Check configuration
 */

const messageLog = {}

class SerialDevice {
    constructor (configuration) {
        this._serial = new SerialConnection(configuration)
        this._retry = new Retry()
        this._topicMap = new TopicMap(topicMapData)

        this._serial.on('data', (object) => {
            try {
                processArduinoMessage(object, messageLog)
            } catch (err) {
                errorLog(err)
            }
        })
    }

    /**
     * @private
     * sends a command to the microcontoller attached over the serial connection
     * @param {string[]} topicChunks {address: address, key: key} address and key of the command
     * @param {number|string} value value to set
     */
    _sendCommand (topicChunks, value) {
        const address = topicChunks.shift()
        const keyTopic = topicChunks.join('/')
        const key = keyMap[keyTopic]
        if (address && key) {
            const command = 'C' + address + key + value
            this._serial.send(command)
        }
    }

    /**
     * @private
     * Sends a command for a microcontroller having a FS20 UART connected
     * @param {string[]} topicChunks current topic chunks (without first element)
     * @param {number} value 1, swith on, 0, switch off
     * @returns {Message} reply message
     */
    async _sendFS20Command (topicChunks, value) {
        const DELAY_IN_SECONDS = 5
        const address = topicChunks.shift()
        const retry = 3

        const command = 'G' + address + value
        this._retry.topicRetry(address, retry, DELAY_IN_SECONDS * 1000, () =>
            this._serial.send(command)
        )
    }

    /**
     * @private
     * Switches a device on or off
     * @param {string[]} topicChunks current topic chunks (without first element)
     * @param {number|string} value "on" to switch on and "off" to switch off
     */
    _switchDevice (topicChunks, value) {
        const relayNo = topicChunks.shift()
        if (arduinoSwitch !== undefined) {
            const messages = [new Message(baseTopic, 'hibernate', 'i2c: switch off received')]
            hibernate(baseTopic, value, device.hibernateCommand, (value) => {
                this._switchReleay(device.arduinoSwitch, value)
            })
        }
        const commandValue = value === 1 ? 'H' : 'L'
        const command = 's' + relayNo + commandValue
        this._serial.send(command)
    }

    /**
     * Send a message to the arduino
     * @param {Message} rawMessage received message with topic and value
     * @param {Message[]} array of messages to send back to the broker
     */
    sendMessage (rawMessage) {
        try {
            const baseTopic = rawMessage.topic.replace('/set', '')
            const message = new Message(baseTopic, rawMessage.value, rawMessage.reason)
            const result = []
            const value = message.value

            const internalTopic = this._topicMap.mapExternalToInternal(baseTopic)
            const topicChunks = internalTopic.split('/')
            const commandType = topicChunks.shift()

            switch (commandType) {
            case 'command':
                this._sendCommand(topicChunks, value)
                break
            case 'fs20':
                this._sendFS20(topicChunks, value)
                message.addReason('send FS20 remote command (unidirectional)')
                message.qos = 1
                result.push(message)
                break
            case 'switch':
                this._switchDevice(topicChunks, value)
                break
            default:
                // Do nothing, the message is not for me
            }
            return result
        } catch (err) {
            errorLog(err)
        }
    }
}

module.exports = SerialDevice
