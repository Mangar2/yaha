/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const types = require('@mangar2/types')
const TopicMatch = require('@mangar2/topicmatch')

/**
 * Creates a class to map topics from internal to external representation and vice versa if there
 * is a matching mapping rule in configuration. It keeps unchanged if there is no mapping rule
 * @param {Object} configuration mapping configuration with topic: map pairs that might be
 * organized in trees like { 1: {topic: map, ...}, 2: {topic: map, ...}}
 * @example
 * const configuration =
 *   fs20: {
 *       'fs20/2111': 'ground/livingroom/zwave/switch/multimedia/set'
 *   },
 *   location: {
 *       'location/33/#': 'first/bedroom/main/#'
 * }
 * const topicMap = new topicMap(configuration)
 * const map = topicMap('location/33/a/b') // returns 'first/bedroom/main/a/b'
 * const map = topicMap('anything/not/mapped') // returns 'anything/not/mapped'
 */
class TopicMap {
    constructor (configuration) {
        this._internalToExternal = {}
        this._externalToInternal = {}
        this._setMapsRec(configuration)
    }

    /**
     * @private
     * Get the part of the topic that matches the '#' wildchard
     * @param {Array} topicChunks elements of the topic
     * @param {Array} patternChunks elements of the pattern
     */
    _getTopicEnd (topicChunks, patternChunks) {
        let result = ''
        while (patternChunks.length > 0) {
            if (patternChunks[0] === '#') {
                result = topicChunks.join('/')
                break
            }
            if (patternChunks[0] !== topicChunks[0]) {
                throw Error('fatal matching error, should not happen')
            }
            patternChunks.shift()
            topicChunks.shift()
        }
        return result
    }

    /**
     * @private
     * Maps a topic to a map controlled by an input pattern supporting wildcards in input and map
     * @param {string} topic - The topic to map
     * @param {string} pattern - The input pattern
     * @param {string} map - The output pattern
     * @returns {string} The mapped (transformed) topic
     */
    _createMapResult (topic, pattern, map) {
        const topicChunks = topic.split('/')
        const patternChunks = pattern.split('/')
        const mapChunks = map.split('/')

        let result = mapChunks.map((mapChunk, index) => {
            const topicChunk = topicChunks[index]
            if (mapChunk === '#') {
                return this._getTopicEnd(topicChunks, patternChunks)
            } else if (mapChunk === '%') {
                return topicChunk
            } else {
                return mapChunk
            }
        }).join('/')
    
        return result
    }

    /**
     * Recursively sets the internal and external mappings of topics based on a configuration object.
     * The configuration object can have nested key-value pairs where the keys represent internal topics and 
     * the values represent their corresponding external topics.
     * @private
     * @param {Object} configuration The configuration object
     */
    _setMapsRec (configuration) {
        for (const key in configuration) {
            const value = configuration[key]
            if (types.isString(value)) {
                this._internalToExternal[key] = value
                this._externalToInternal[value] = key
            } else if (types.isObject(value)) {
                this._setMapsRec(value)
            }
        }
    }

    /**
     * Tries to map a topic to one of the topic map entries of a patternMap array and returns the mapped result
     * @param {string} topic topic to map
     * @param {Object} patternMap key/value map of topic mappings
     * @returns {string} the mapped (transformed) topic
     * @private
     */
    _map (topic, patternMap) {
        let result = topic
        for (const pattern in patternMap) {
            const topicMatch = new TopicMatch()
            topicMatch.addPattern(pattern, 0)
            if (topicMatch.getFirstMatch(topic) !== undefined) {
                const map = patternMap[pattern]
                result = this._createMapResult(topic, pattern, map)
                break
            }
        }
        return result
    }

    /**
     * Maps a topic from internal representation to external representation
     * @param {string} topic internal topic to map
     * @returns {string} external topic
     */
    mapInternalToExternal (topic) {
        const result = this._map(topic, this._internalToExternal)
        return result
    }

    /**
     * Maps a topic from external representation to internal representation
     * @param {string} topic external topic to map
     * @returns {string} internal topic
     */
    mapExternalToInternal (topic) {
        const result = this._map(topic, this._externalToInternal)
        return result
    }
}

module.exports = TopicMap
