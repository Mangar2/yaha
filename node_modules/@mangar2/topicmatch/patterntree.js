/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

class PatternTree {
    constructor () {
        this._tree = {}
    }

    /**
     * Adds a pattern to a pattern tree. The pattern has '/' as separator
     * @param {string} pattern pattern string with '/' as separator
     * @param {number} [value=0] pattern value
     */
    addPattern (pattern, value = 0) {
        const patternChunks = pattern.split('/')
        let node = this._tree
        for (const chunk of patternChunks) {
            if (!node[chunk]) {
                node[chunk] = {}
            }
            node = node[chunk]
        }
        node[0] = value
    }

    /**
     * Recursively removes a pattern (exact match) from the tree
     * @param {string[]} topicChunks topic chunks to search for
     * @param {Object} node current node in the pattern tree
     * @param {number} [index = 0] current index (depth) in the topic array
     */
    _deletePatternRec (topicChunks, node, index = 0) {
        const chunk = topicChunks[index]
        if (chunk === undefined) {
            if (node[0] !== undefined) {
                delete node[0]
            }
            return
        }
        const childNode = node[chunk]
        if (childNode !== undefined) {
            this._deletePatternRec(topicChunks, childNode, index + 1)
            if (Object.keys(childNode).length === 0) {
                delete node[chunk]
            }
        }
    }

    /**
     * Searches for a topic in a pattern tree, returns the first match
     * @param {string[]} topicChunks topic chunks to search for
     * @param {Object} node current node in the pattern tree
     * @param {number} [index = 0] current index (depth) in the topic array
     */
    _getFirstMatchRec (topicChunks, node, index = 0) {
        const topic = topicChunks[index]
        if (topic === undefined) {
            return node[0]
        }
        const isSystemChunk = (index === 0) && topic.charAt(0) === '$'
        if (!isSystemChunk) {
            if (node['#']) {
                return node['#'][0]
            }
            if (node['+']) {
                const result = this._getFirstMatchRec(topicChunks, node['+'], index + 1)
                if (result !== undefined) return result
            }
        }
        if (node[topic]) {
            const result = this._getFirstMatchRec(topicChunks, node[topic], index + 1)
            if (result !== undefined) return result
        }
        return undefined
    }

    /**
     * Gets the maximum of two elements that are either a number or undefined. Undefined values are ignored
     * _max(undefined, undefined) = undefined
     * _max(undefined, b) = b
     * @param {function(a,b)} isBetter returns true, if a is better than b
     * @param {number|undefined} a first element
     * @param {number|undefined} b second element
     */
    _max (isBetter, a, b) {
        if (a === undefined) {
            return b
        }
        if (b === undefined) {
            return a
        }
        return isBetter(a, b) ? a : b
    }

    /**
     * Searches for a topic in a pattern tree, returns the best match (match with highest value)
     * @param {function(a,b)} isBetter returns true, if a is better than b
     * @param {string[]} topicChunks topic chunks to search for
     * @param {Object} node current node in the pattern tree
     * @param {number} [index = 0] current index (depth) in the topic array
     */
    _getBestMatchRec (isBetter, topicChunks, node, index = 0) {
        const topic = topicChunks[index]
        if (topic === undefined) {
            return node[0]
        }
        const isSystemChunk = (index === 0) && topic.charAt(0) === '$'
        let result
        if (!isSystemChunk) {
            if (node['#']) {
                result = this._max(isBetter, result, node['#'][0])
            }
            if (node['+']) {
                const cur = this._getBestMatchRec(isBetter, topicChunks, node['+'], index + 1)
                result = this._max(isBetter, result, cur)
            }
        }
        if (node[topic]) {
            const cur = this._getBestMatchRec(isBetter, topicChunks, node[topic], index + 1)
            result = this._max(isBetter, result, cur)
        }
        return result
    }

    /**
     * Gets the first match of a topic
     * @param {string} topic topic to search for
     */
    getFirstMatch (topic) {
        const topicChunks = topic.split('/')
        return this._getFirstMatchRec(topicChunks, this._tree)
    }

    /**
     * Gets the first match of a topic
     * @param {string} topic topic to search for
     * @param {function(a,b)} isBetter returns true, if a is better than b
     */
    getBestMatch (topic, isBetter) {
        const topicChunks = topic.split('/')
        return this._getBestMatchRec(isBetter, topicChunks, this._tree)
    }

    /**
     * Delete a pattern from the tree
     * @param {string} pattern pattern to delete
     */
    deletePattern (pattern) {
        const topicChunks = pattern.split('/')
        return this._deletePatternRec(topicChunks, this._tree)
    }
}

module.exports = PatternTree
