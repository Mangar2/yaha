/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const types = require('@mangar2/types')
const PatternTree = require('./patterntree')

/**
 * Contructs a new class
 * Checks, if a topic matches a list of patterns. The pattern is bases on the MQTT
 * pattern design. Every pattern has an associated value (used for QoS in MQTT)
 * Topic structure slashes with strings in between:  /string1/string2/string3/...
 * Pattern is like topic with the following whildcards: "+" and "#". The "+" matches
 * any string, the "#" matches the rest of the topic.
 * @example
 * const topicMatch = new TopicMatch()
 * topicMatch.setPattern('#', 0)
 * topicMatch.getFirstMatch('hello') // returns 0
 * topicMatch.removePattern('#')
 * topicMatch.setPattern('/+', 1)
 * topicMatch.getFirstMatch('hello') // returns undefined
 * topicMatch.getFirstMatch('/hello') // returns 1
 * topicMatch.getFirstMatch('/hello/world') // returns undefined
 * @param {Object|Array|string} [pattern={}] pattern data structure {pattern: value, pattern: value, ...}
 */
class TopicMatch {
    constructor (pattern = {}) {
        this.addPattern(pattern)
        this._tree = new PatternTree()
    }

    /**
     * Clears the pattern tree
     */
    clear () {
        this._tree = new PatternTree()
    }

    /**
     * Adds a pattern string to the patternlist (if not already included)
     * @param {string|Array|Object} pattern single pattern or list of pattern
     * @param {any} [value=0] value associated with the pattern
     * @throws {Error} if pattern is not string or value is not provided
     */
    addPattern (pattern, value = 0) {
        if (types.isObject(pattern)) {
            for (const topic in pattern) {
                this._tree.addPattern(topic, pattern[topic])
            }
        } else if (types.isArray(pattern)) {
            for (const topic of pattern) {
                this._tree.addPattern(topic, value)
            }
        } else if (types.isString(pattern)) {
            this._tree.addPattern(pattern, value)
        } else {
            throw Error('pattern must be string, Array or Object')
        }
    }

    /**
     * Delete a pattern from the tree
     * @param {Array|string} patternList string or array of strings containing patterns to delete
     */
    deletePattern (patternList) {
        if (patternList === undefined) {
            throw Error('undefined pattern in removePattner')
        }
        if (!Array.isArray(patternList)) {
            patternList = [patternList]
        }
        for (const pattern of patternList) {
            this._tree.deletePattern(pattern)
        }
    }

    /**
     * Sets, adds and/or removes pattern.
     * @param {Object} patternCommand object with attributes "set, remove, add" and a pattern list
     */
    changePattern (patternCommand) {
        if (patternCommand.set !== undefined) {
            this._tree = new PatternTree()
            this.addPattern(patternCommand.set.pattern, patternCommand.set.value)
        } else if (patternCommand.remove !== undefined) {
            this.removePattern(patternCommand.remove)
        }
        if (patternCommand.add !== undefined) {
            this.addPattern(patternCommand.add.pattern, patternCommand.add.value)
        }
    }

    /**
     * Gets the value of the first matching pattern.
     * @param {string} searchTopic topic to search for
     * @return {any|undefined} value associated with the found topic or undefined, if nothing matches
     */
    getFirstMatch (searchTopic) {
        return this._tree.getFirstMatch(searchTopic)
    }

    /**
     * Gets the best value of all matching pattern according the compare function.
     * If no compare function is provided, the values of the patterns are compared with the ">" operator
     * @param {string} searchTopic topic to search for
     * @param {function(newValue, currentValue)} isBetter(a, b) function deciding, if "a" is better than "b"
     * @return {any} value associated with the best found topic or undefined, if nothing matches
     */
    getBestMatch (searchTopic, isBetter = (a, b) => { return a > b }) {
        return this._tree.getBestMatch(searchTopic, isBetter)
    }
}

module.exports = TopicMatch
