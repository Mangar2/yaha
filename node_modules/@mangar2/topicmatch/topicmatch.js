/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const types = require('@mangar2/types')

/**
 * @private
 * Checks, if the pattern does not match the topic due to the special rule that a wildchard
 * at the beginning of pattern does not match a topic beginning with a $
 * @param {string} topic topic to match
 * @param {string} pattern pattern to match
 * @returns {boolean} returns true, if a pattern does not match due to the $SYS topic rule
 */
function notMatchingDueToSysTopic (topic, pattern) {
    const isSysTopic = topic.charAt(0) === '$'
    const startsWithWildchard = ['#', '+'].includes(pattern.charAt(0))
    return isSysTopic && startsWithWildchard
}

/**
 * @private
 * Checks, if topics matches
 * @param {string} topic topic to check
 * @param {string} pattern topic with wildchards to pattern
 */
function isTopicMatching (topic, pattern) {
    const topicElements = topic.split('/')
    const patternElements = pattern.split('/')
    const patternIsLonger = patternElements.length > topicElements.length
    const patternIsShorter = patternElements.length < topicElements.length
    let matches = !patternIsLonger && !notMatchingDueToSysTopic(topic, pattern)

    for (let index = 0; (index < patternElements.length) && matches; index++) {
        const curPatternElement = patternElements[index]
        const curTopicElement = topicElements[index]
        const isLastElementInPatternList = (index === patternElements.length - 1)
        if (curPatternElement === '#') {
            break
        } else if (isLastElementInPatternList && patternIsShorter) {
            matches = false
        } else if (curPatternElement !== '+' && curPatternElement !== curTopicElement) {
            matches = false
        } else if (curTopicElement === '#') {
            matches = false
        }
    }
    return matches
}
/**
 * Contructs a new class
 * Checks, if a topic matches a list of patterns. The pattern is bases on the MQTT
 * pattern design. Every pattern has an associated value (used for QoS in MQTT)
 * Topic structure slashes with strings in between:  /string1/string2/string3/...
 * Pattern is like topic with the following whildcards: "+" and "#". The "+" matches
 * any string, the "#" matches the rest of the topic.
 * @example
 * const topicMatch = new TopicMatch()
 * topicMatch.setPattern('#', 0)
 * topicMatch.getFirstMatch('hello') // returns 0
 * topicMatch.removePattern('#')
 * topicMatch.setPattern('/+', 1)
 * topicMatch.getFirstMatch('hello') // returns undefined
 * topicMatch.getFirstMatch('/hello') // returns 1
 * topicMatch.getFirstMatch('/hello/world') // returns undefined
 * @param {Object|Array|string} [pattern={}] pattern data structure {pattern: value, pattern: value, ...}
 */
class TopicMatch {
    constructor (pattern = {}) {
        this.setPattern(pattern)
    }

    /**
     * Adds a pattern string to the patternlist (if not already included)
     * @param {string|Array|Object} pattern single pattern or list of pattern
     * @param {any} [value=0] value associated with the pattern
     * @throws {Error} if pattern is not string or value is not provided
     */
    setPattern (pattern, value = 0) {
        this.topicPatternList = {}
        if (types.isObject(pattern)) {
            this.topicPatternList = pattern
        } else if (types.isArray(pattern)) {
            for (const curPattern of pattern) {
                this.topicPatternList[curPattern] = value
            }
        } else if (types.isString(pattern)) {
            this.topicPatternList[pattern] = value
        } else {
            throw Error('pattern must be string, Array or Object')
        }
    }

    /**
     * Removes all pattern from the list matching the provided patterns. A "removePattern("#")" will for
     * example remove all stored patterns
     * @param {Array|string} pattern string or array of strings containing patterns to delete
     */
    removePattern (pattern) {
        if (pattern === undefined) {
            throw Error('undefined pattern in removePattner')
        }
        if (!Array.isArray(pattern)) {
            pattern = [pattern]
        }
        for (const deletePattern of pattern) {
            for (const curPattern in this.topicPatternList) {
                if (isTopicMatching(curPattern, deletePattern)) {
                    delete this.topicPatternList[curPattern]
                }
            }
        }
    }

    /**
     * Sets, adds and/or removes pattern.
     * @param {Object} patternCommand object with attributes "set, remove, add" and a pattern list
     */
    changePattern (patternCommand) {
        if (patternCommand.set !== undefined) {
            this.removePattern('#')
            this.setPattern(patternCommand.set.pattern, patternCommand.set.value)
        } else if (patternCommand.remove !== undefined) {
            this.removePattern(patternCommand.remove)
        }
        if (patternCommand.add !== undefined) {
            this.setPattern(patternCommand.add.pattern, patternCommand.add.value)
        }
    }

    /**
     * Gets a list of matching pattern
     * @param {string} searchTopic topic to search for
     * @returns {Object} all matching topics {topic1: value, topic2: value, ...}
     */
    getAllMatchingPattern (searchTopic) {
        const result = {}
        for (const curPattern in this.topicPatternList) {
            if (isTopicMatching(searchTopic, curPattern)) {
                result[curPattern] = this.topicPatternList[curPattern]
            }
        }
        return result
    }

    /**
     * Gets the value of the first matching pattern.
     * @param {string} searchTopic topic to search for
     * @return {any|undefined} value associated with the found topic or undefined, if nothing matches
     */
    getFirstMatch (searchTopic) {
        let result
        for (const curPattern in this.topicPatternList) {
            if (isTopicMatching(searchTopic, curPattern)) {
                result = this.topicPatternList[curPattern]
                break
            }
        }
        return result
    }

    /**
     * Gets the best value of all matching pattern according the compare function.
     * If no compare function is provided, the values of the patterns are compared with the ">" operator
     * @param {string} searchTopic topic to search for
     * @param {function(newValue, currentValue)} isBetter(a, b) function deciding, if "a" is better than "b"
     * @return {any} value associated with the best found topic or undefined, if nothing matches
     */
    getBestMatch (searchTopic, isBetter) {
        let result
        for (const curPattern in this.topicPatternList) {
            if (isTopicMatching(searchTopic, curPattern)) {
                const curValue = this.topicPatternList[curPattern]
                if (result === undefined) {
                    result = curValue
                } else if (isBetter === undefined && curValue > result) {
                    result = curValue
                } else if (isBetter(curValue, result)) {
                    result = curValue
                }
            }
        }
        return result
    }
}

module.exports = TopicMatch
