/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      topictree.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

'use strict';

/**
 * Checks, if a function is a string
 * @param {any} x 
 */
function isString(x) {
    return Object.prototype.toString.call(x) === "[object String]"
}

/**
 * Savely gets a property from an object. Sets the property, if it is not defined
 * @param {object} object to get entry from
 * @param {string} propertyName name of the property to retrieve
 * @param {any} propertyValue value to set to the property, if the property is undefined
 * @result property of the object or undefined, if the property is not retrievable
 */
function getFromObject(object, propertyName, addIfUndefined) {
    var result;
    if (object !== undefined && propertyName !== undefined && isString(propertyName)) {
        if (!object.hasOwnProperty(propertyName) && propertyValue !== undefined) {
            object[propertyName] = propertyValue;
        }
        result = object[propertyName];
    }
    return result;
}

module.exports = class TopicTree {

    /**
     * Safely sets a configuration option, if the option is included in configuration and it is a number
     * Strings with numbers are converted to integer
     * @param {string} propertyName name of the property to set
     * @param {object} configuration object with property propertyName
     */
    setFromConfiguration(propertyName, configuration) {
        if (configuration !== undefined && !isNaN(configuration[propertyName])) {
            if (typeof(configuration[propertyName]) === 'string') {
                this.configuration[propertyName] = parseInt(configuration[propertyName]);
            }
        }
    }

    /**
     * Sets the property values of the class
     * @param {string} directory directory to persist the message tree
     * @param {string} fileName name of the persistent file
     * @param {object} configuration configuration for the tree
     */
    constructor(directory, fileName, configuration)  {
        this.directory = directory === undefined ? "." : directory;
        if (fileName === undefined) {
            throw Error("filename is undefined but required");
        }
        this.fileName = fileName;
        this.configuration = {
            maxHistoryLength = 120,
            historyHysterese = 20
        }
        this.setFromConfiguration('maxHistoryLength', configuration);
        this.setFromConfiguration('historyHysterese', configuration);

        this.tree = {};
    }

    /**
     * Checks if a node is a leaf node
     * @param {object} node node of the message tree
     */
    static isLeaf(node) {
        return node.hasOwnProperty("current");
    }

    /**
     * Initializes a leaf node
     * @param {object} node 
     */
    static initLeafNode(node) {
        if (!node.hasOwnProperty("current")) {
            node.current = {};
        }
        if (!node.hasOwnProperty("history")) {
            node.history = [];
        }
    }

    /**
     * Gets the payload (current and history) of the node
     * @param {object} node tree node
     */
    static getPayload(node) {
        return {current: node.current, history: node.history}
    }


    /**
     * Searches a node in the message tree corresponding to the topic. 
     * @param {string} topic topic to store the data
     * @returns {any} data to store
     */
    getNode(topic) {
        let pathArray = topic.split("/");
        let childNode = this.tree;
        for (let property of pathArray) {
            childNode = getFromObject(childNode, property);
            if (childNode === undefined) {
                break;
            }
        }
        return childNode;
    }

    /**
     * Searches a node in the message tree corresponding to the topic. Creates empty nodes along the topic if 
     * the nodes are not yet available.
     * @param {string} topic topic to store the data
     * @returns {object} node in the tree
     */
    getAndCreateLeafNode(topic) {
        let topicCunks = topic.split("/");
        let node = this.tree;
        for (let topicChunk of topicCunks) {
            node = getFromObject(node.childs, topicChunk, {childs:{}});
        }
        TopicTree.initLeafNode();
        return node;
    }

    /**
     * Updates the data of a node. Stores the old data to a history array and sets the new data to current
     * The new history entry is added to the beginning of the queue. If the history length exceeds the 
     * maximal length, it will be reduces by "historyHysterese" amount of elements
     * @param {object} node node to update
     * @param {object} current new current node content
     * @param {number} maxHistoryLength maximal amount of entries in the history
     * @param {number} historyHysterese amount of entries to delete, if history exeeds max length
     */
    static updateData(node, current, maxHistoryLength, historyHysterese) {
        let oldData = node.current.data;

        node.current = current;
        node.history = [oldData, ...node.history];

        if (node.history.length > maxHistoryLength) {
            var newLength = maxHistoryLength - historyHysterese;
            if (newLength <= 0) {
                newLength = 1;
            }
            node.history = node.history.slice(0, newLength);
        }
    }

    /**
     * Adds data to the three node matching to the topic path. 
     * It will store the current data (descrition and data) to the "current" property of the node and
     * the former data entry of the "current" property to the "history" property array.
     * @param {string} topic path to the node
     * @param {any} description additional description for the data
     * @param {any} data data to add
     */
    addData(topic, description, data) {
        let node = this.getAndCreateLeafNode(topic);
        TopicTree.udateData(node, {description, data}, 
            this.configuration.maxHistoryLength, this.configuration.historyHysterese);
    };

    /**
     * Gets several levels of child nodes in one flat object structure
     * @param {object} node node of the message tree
     * @param {string} topic current topic
     * @param {Number} level amount of child levels to include
     */
    static getSectionRec(node, topic, levelAmount) {
        let result = {topics:[], payload:{}};

        if (topic === undefined || topic === "" || !isString(topic)) {
            topic = "/";
        }
        result.topics.push(topic);
        
        if (TopcTree.isLeaf(node)) {
            result.payload[topic] = TopicTree.getPayload(node);
        }

        if (levelAmount > 0) {
            for(let childName in node.childs) {
                let childNode = node.childs[childName];
                let childTopic = topic === "/" ? "/" + childName : topic + "/" + childName;
                let subChildNodes = getSectionRec(childNode, childTopic, levelAmount - 1);
                result = {
                    topics: [...result.topics, ...subChildNodes.topics],
                    payload: {...result.payload, ...subChildNodes.payload}
                }
            }
        }
        return result;
    }

    /**
     * Gets several levels of child nodes in one flat object structure
     * @param {string} topic start topic of the section
     * @param {number} levelAmount amount of levels to get
     */
    getSection(topic, levelAmount) {
        let node = TopicTree.getNode(topic);
        let result = TopicTree.getSectionRec(node, topic, levelAmount);
        return result;
    }

}

