/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview This module provides a simple class to support unit tests, this is not a framework.
 * Use "testrun", as a simple uinit test framework
 */

'use strict'

const assert = require('assert')
const { errorLog, Types } = require('@mangar2/utils')

/**
 * Creates an object supporting unit tests
 * @param {boolean} verbose true to give more output
 * @param {bool} debug true, to print a stack trace on fail
 * @example
 * const unitTest = new UnitTest(true, true)
 * unitTest.assertEqual('1', '1', 'equal')
 * unitTest.assertTrue(true, 'true')
 * unitTest.assertFalse(false, 'false')
 * unitTest.success('success')
 * unitTest.log('just a log')
 * unitTest.assertDeepEqual({ a: 'b' }, { a: 'b' })
 * unitTest.expectException(() => { throw new Error('Hello World') }, 'Error', 'message')
 */
class UnitTest {
    constructor(verbose = false, debug = false) {
        this._successAmount = 0
        this._failAmount = 0
        this._verbose = verbose
        this._debug = debug
    }

    /**
     * Set verbose to true to print all success infos
     * @type {bool}
     */
    set verbose(verbose) { this._verbose = verbose }
    get verbose() { return this._verbose }

    /**
     * Set debug to true, to print a stack trace on fail
     * @type {bool}
     */
    set debug(debug) { this._debug = debug }
    get debug() { return this._debug }

    /**
     * Calculate the overall test result.
     * @param {number} expectedSuccess - The expected number of positive test cases in the current run.
     * @param {number} expectedFail - The expected number of negative test cases in the current run.
     * @throws {Error} Throws an error if the expected amount is not met or if there are any test failures.
     * @returns {Object} The result code and message.
     */
    getResult(expectedSuccess, expectedFail = 0) {
        let resultMsg = `success: ${this._successAmount}, failed: ${this._failAmount}`
        let failed = false

        if (expectedSuccess !== undefined && expectedSuccess !== this._successAmount) {
            resultMsg += `\nFailed! We expected ${expectedSuccess} success messages but have ${this._successAmount}`
            failed = true
        } else if (expectedFail !== undefined && expectedFail !== this._failAmount) {
            resultMsg += `\nFailed! We expected ${expectedFail} fail messages but have ${this._failAmount}`
            failed = true           
        } else {
            resultMsg += '\nPASSED!'
        }

        return {
            message: resultMsg,
            failed: failed
        }
    }

    /**
     * Shows the overall test result and exits the process with code 1 if there are any failures.
     * @param {number} expectedSuccess - The expected number of positive test cases in the current run.
     * @param {number} expectedFail - The expected number of negative test cases in the current run.
     */
    showResult(expectedSuccess, expectedFail = 0) {
        const result = this.getResult(expectedSuccess, expectedFail)
        console.log(result.message)

        if (result.failed) {
            process.exit(1)
        }
    }

    /**
     * Join the results of multiple tests.
     * @param {...Object} results - A variable number of result objects from multiple tests.
     * @returns {Object} The joined result.
     */
    static joinMultipleResults(...results) {
        let resultMsg = ''
        let failed = false

        results.forEach(result => {
            resultMsg += `${result.message}\n`
            failed = failed || result.failed
        })

        return {
            message: resultMsg,
            failed: failed
        }
    }

    /**
     * Gets the result functions 
     * @param {number} expectedSuccess - The expected number of positive test cases in the current run.
     * @param {number} expectedFail - The expected number of negative test cases in the current run.
     */
    getResultFunctions(expectedAmount, expectedFail = 0) {
        return {
            showResult: () => this.showResult(expectedAmount, expectedFail),
            getResult: () => this.getResult(expectedAmount, expectedFail)
        }
    }

    /**
     * Adds a failure and prints an error message.
     * If `_debug` is `true`, also prints the stack trace.
     * @param {string} message The message to print on failure.
     */
    fail(message) {
        this._failAmount++
        message = message || ''
        if (this._verbose) {
            console.error(`${this._failAmount} Failed: ${message}`)
        }
        if (this._debug) {
            console.log(new Error().stack)
        }
        if ((this._verbose || this._debug) && this._failAmount > 10) {
            console.error('Too many errors, terminating program')
            process.exit(1)
        }
    }

    /**
     * Adds a success
     * @param {string} message message to print on success (if verbose is true)
     */
    success(message) {
        this._successAmount++
        message = message || ''
        if (this._verbose) {
            this.log(`${this._successAmount} success: ${message}`)
        }
    }

    /**
     * Tests a value for beeing true, fails if the value is false
     * @param {boolean} test test value
     * @param {string} message info message on success/fail
     * @returns {boolean} true/false based on success
     */
    assertTrue(test, message) {
        message = message ? message + ' - ' : ''
        if (test) {
            this.success(message + ' Value is true')
        } else {
            this.fail(message + ' Expected true but got false.')
        }
        return test
    }

    /**
     * Tests a value for beeing unefined, fails if the value is not
     * @param {boolean} test test value
     * @param {string} message info message on success/fail
     * @returns {boolean} true/false based on success
     */
    assertUndefined(test, message) {
        return this.assertEqual(test, undefined, message)
    }

    /**
     * Tests a value for beeing false, fails if the value is true
     * @param {boolean} test test value
     * @param {string} message info message on success/fail
     * @returns {boolean} true/false based on success
     */
    assertFalse(test, message) {
        message = message ? message + ' - ' : ''
        const result = !test
        if (result) {
            this.success(message + ' Value is false')
        } else {
            this.fail(message + ' Expected false but got true.')
        }
        return result
    }

    /**
     * Compares two values using "===" operator, fails if they are not equal
     * @param {any} a first value
     * @param {any} b second value
     * @param {string} message info message on success/fail
     * @returns {boolean} true/false based on success
     */
    assertEqual(a, b, message) {
        if (message === undefined || message === null) {
            message = ''
        }
        const result = (a === b)
        if (result) {
            this.success(message)
        } else {
            this.fail(`Expected "${b}", but got "${a}" ${message}`)
        }
        return result
    }

         
    /**
     * Asserts that the provided callback does not throw an exception.
     * 
     * @param {Function} callback - The callback function to be executed.
     * @param {string} message - The message to be displayed if the callback throws an exception.
     * @returns {boolean} - Returns true if the callback does not throw an exception, false otherwise.
     */
    assertNoException(callback, message) {
        try {
            callback()
            this.success(message)
            return true
        } catch (err) {
            this.fail(`${message} ${err}`)
            return false
        }
    }
    
    /**
     * Validates a result object against an expected object. It validates with
     * exact equality, ensuring that "result" has all object properties of expected
     * and that expected has all object properties of "result" (if `exact` is true).
     * @param {Object} result object to be validated
     * @param {Object} expected expected object
     * @param {string} path path to be displayed on success/error
     * @param {boolean} [exact=false] true, if result may not have additional properties
     * @returns {boolean} true, if the test is ok
     */
    validateResult(result, expected, path, exact = false) {
        let resultStatus = true
        for (const property in expected) {
            if (result[property] !== expected[property]) {
                resultStatus = false
                this.fail(`${path}/${property}`)
            }
        }
        if (exact) {
            for (const property in result) {
                if (result[property] !== expected[property]) {
                    resultStatus = false
                    this.fail(`${path}/${property}`)
                }
            }
        }
        if (resultStatus) {
            this.success(path)
        }
        return resultStatus
    }

    /**
     * Recursively replaces substrings in an object, array, or string.
     * @param {object | array | string} input - The input value to replace substrings in.
     * @param {{ [index: string]: string }} replacements - An object containing the search and replacement strings.
     * @returns {object | array | string} - The input value with the specified substrings replaced.
     */
    replaceRec(input, replacements) {
        if (input === null || input === undefined) {
            return input
        } else if (Types.isArray(input)) {
            for (const index in input) {
                const elem = input[index]
                input[index] = this.replaceRec(elem, replacements)
            }
        } else if (Types.isObject (input)) {
            for (const index in input) {
                input[index] = this.replaceRec(input[index], replacements)
            }
        } else {
            for (const searchValue in replacements) {
                const replaceValue = replacements[searchValue]
                if (input === searchValue) {
                    input = replaceValue
                } else if (Types.isString (input) && Types.isString(replaceValue)) {
                    input = input.replaceAll(searchValue, replaceValue)
                }
            }
        }
        return input
    }

    /**
     * @description
     * Recursively validates an element against an expected element. 
     * If "exact" === false, it will only validate values that are specified in "expected"
     * and ignore additional data in the "toValidate" element. This allows us to specify only the values that we want to check
     * in the test cases.
     *
     * @param {any} toValidate element to be validated
     * @param {any} expected expected element
     * @param {string} path path to the element to compare
     * @param {boolean} [exact=false] true, if the "toValidate" element may not have additional properties
     *
     * @throws {string} the first difference between "toValidate" and "expected"
     */
    validateRec(toValidate, expected, path, exact = false) {
        if (toValidate === expected) {
            return
        }
        else if (toValidate === undefined) {
            throw `${path}: undefined`
        } else if (Types.getType(toValidate) !== Types.getType(expected)) {
            throw `${path}: types are different ${Types.getType(toValidate)} !== ${Types.getType(expected)}`
        }
        else if (Types.isArray(expected)) {
            if (toValidate.length !== expected.length) {
                throw `${path}: arrays have different length`
            }
            for (const index in toValidate) {
                this.validateRec(toValidate[index], expected[index], `${path}/${index}`)
            }
        } else if (Types.isObject(expected)) {
            for (const index in expected) {
                this.validateRec(toValidate[index], expected[index], `${path}/${index}`)
            }
            if (exact) {
                for (const index in toValidate) {
                    if (expected[index] === undefined) {
                        throw `${path}: additional property ${index}`
                    }
                }
            }
        } else {
            throw `${path}: elements have different value: ${toValidate} !== ${expected}`
        }
    }

 
    /**
     * @private
     * @description
     * Recursively compares two elements for equality, including nested objects and arrays
     * @param {any} a first element to compare
     * @param {any} b second element to compare
     * @param {string} path path to the element to compare
     * @throws {string} description of the difference including the path to the element
     */
    _deepEqualRec(a, b, path) {
        if (a === b) {
            return
        }
        if (Types.getType(a) !== Types.getType(b)) {
            throw `${path}: types are different ${Types.getType(a)} !== ${Types.getType(b)}`
        }
        this._compareTypes(a, b, path)
        assert.deepStrictEqual(a, b, path)
    }

    /**
     * @private
     * @description
     * Compares two elements of the same type for equality
     * @param {any} a first element to compare
     * @param {any} b second element to compare
     * @param {string} path path to the element to compare
     * @throws {string} description of the difference including the path to the element
     */
    _compareTypes(a, b, path) {
        if (Types.isDate(a)) {
            this._compareDates(a, b, path)
        } else if (Types.isSet(a)) {
            this._compareSets(a, b, path)
        } else if (Types.isMap(a)) {
            this._compareMaps(a, b, path)
        } else if (Types.isArray(a)) {
            this._compareArrays(a, b, path)
        } else if (Types.isRegExp(a)) {
            this._compareRegex(a, b, path)
        } else if (Types.isObject(a)) {
            this._compareObjects(a, b, path)
        } else {
            throw `${path}: elements have different value: ${a} !== ${b} or types ${Types.getType(a)} != ${Types.getType(b)}}`
        }
    }

    /**
     * @private
     * @description
     * Compares two Date objects for equality
     * @param {Date} a first Date object to compare
     * @param {Date} b second Date object to compare
     * @param {string} path path to the Date objects to compare
     * @throws {string} description of the difference including the path to the element
     */
    _compareDates(a, b, path) {
        if (a.getTime() !== b.getTime()) {
            throw `${path}: not both dates or dates are different`
        }
    }

    /**
     * @private
     * @description
     * Compares two Set objects for equality
     * @param {Set} a first Set object to compare
     * @param {Set} b second Set object to compare
     * @param {string} path path to the Set objects to compare
     * @throws {string} description of the difference including the path to the element
     */
    _compareSets(a, b, path) {
        if (a.size !== b.size) {
            throw `${path}: sets have different size`
        }            
        for (const elem of a) {
            if (!b.has(elem)) {
                throw `${path}: missing element ${elem}`
            }
        }
    }

    /**
     * @private
     * @description
     * Compares two Map objects recursively
     * @param {Map} a first map to compare
     * @param {Map} b second map to compare
     * @param {string} path path to the element to compare
     * @throws {string} description of the difference including the path to the element
     */
    _compareMaps(a, b, path) {
        if (a.size !== b.size) {
            throw `${path}: maps have different size`
        }
        for (const key of a.keys()) {
            if (!b.has(key)) {
                throw `${path}: missing property ${key}`
            } else {
                this._deepEqualRec(a.get(key), b.get(key), `${path}/${key}`)
            }
        }
    }

    /**
     * @private
     * @description
     * Compares two arrays for equality, including nested objects and arrays
     * @param {Array} a first array to compare
     * @param {Array} b second array to compare
     * @param {string} path path to the array to compare
     * @throws {string} description of the difference including the path to the array
     */
    _compareArrays(a, b, path) {
        if (a.length !== b.length) {
            throw `${path}: arrays have different length`
        }
  
        for (let i = 0; i < a.length; i++) {
            this._deepEqualRec(a[i], b[i], `${path}[${i}]`)
        }
    }
  
    /**
     * @private
     * @description
     * Compares two regular expressions for equality
     * @param {RegExp} a first regular expression to compare
     * @param {RegExp} b second regular expression to compare
     * @param {string} path path to the regular expression to compare
     * @throws {string} description of the difference including the path to the regular expression
     */
    _compareRegex(a, b, path) {
        if (a.toString() !== b.toString()) {
            throw `${path}: regular expressions are different: ${a} !== ${b}`
        }
    }
  
    /**
     * @private
     * @description
     * Compares two objects for equality, including nested objects and arrays
     * @param {Object} a first object to compare
     * @param {Object} b second object to compare
     * @param {string} path path to the object to compare
     * @throws {string} description of the difference including the path to the object
     */
    _compareObjects(a, b, path) {
        const aKeys = Object.keys(a)
        const bKeys = Object.keys(b)
  
        if (aKeys.length !== bKeys.length) {
            throw `${path}: objects have different amount of properties`
        }
  
        for (let i = 0; i < aKeys.length; i++) {
            const key = aKeys[i]
  
            if (!Object.prototype.hasOwnProperty.call(b, key)) {
                throw `${path}: missing property ${key}`
            }
  
            this._deepEqualRec(a[key], b[key], `${path}.${key}`)
        }
  
        if (a.constructor.name !== b.constructor.name) {
            throw `${path}: objects have different constructor names: ${a.constructor.name} !== ${b.constructor.name}`
        }
    }

    /**
     * Compares two objects deeply
     * @param {any} a first object to compare
     * @param {any} b second object to compare
     * @param {string} [message=''] message to show
     * @returns {boolean} true/false based on success
     */
    assertDeepEqual(a, b, message = '') {
        let result = true
        message = message || ''
        try {
            this._deepEqualRec(a, b, '')
            assert.deepStrictEqual(a, b, message)
            this.success(message)
        } catch (err) {
            this.fail(`${message} ${err}`)
            result = false
        }
        return result
    }

    /**
     * Runs a function and checks for a thrown exception of a certain type.
     * @param {Function} callback - The function that is expected to throw an exception.
     * @param {Function} expectedException - The expected exception constructor.
     * @param {string} [message=''] - The message to display on success or failure.
     * @returns {boolean} - True if the expected exception is thrown, false otherwise.
     */
    expectException(callback, expectedException, message = '') {
        try {
            callback()
        } catch (err) {
            const isExpectedException = expectedException === undefined 
                || err.constructor.name === expectedException.name
                || (Types.isString(err) && Types.isString(expectedException))
            if (isExpectedException) {
                if (Types.isString(err)) {
                    message = `${message}${err}`
                }
                this.success(message)
                return true
            } else {
                this.fail(`Expected exception ${expectedException.name}, but got ${err.constructor.name}. ${message}`)
            }
            return true
        }
        this.fail(`No exception was thrown. ${message}`)
        return false
    }

    /**
     * Logs a message if verbose mode is enabled
     * @param {string} message message to log
     */
    log(message) {
        if (this._verbose) {
            console.log(message)
        }
    }

    /**
     * Logs an error message or object if verbose mode is enabled
     * @param {Error|string} error error message or object to log
     */
    logError(error) {
        if (this._verbose) {
            errorLog(error, this._debug)
        }
    }
}

module.exports = UnitTest
