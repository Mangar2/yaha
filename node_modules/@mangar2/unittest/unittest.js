/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview This module provides a simple class to support unit tests, this is not a framework.
 * Use "testrun", as a simple uinit test framework
 */

'use strict'

const assert = require('assert')
const errorlog = require('@mangar2/errorlog')

/**
 * Creates an object supporting unit tests
 * @param {boolean} verbose true to give more output
 * @param {bool} debug true, to print a stack trace on fail
 * @example
 * const unitTest = new UnitTest(true, true)
 * unitTest.assertEqual('1', '1', 'equal')
 * unitTest.assertTrue(true, 'true')
 * unitTest.assertFalse(false, 'false')
 * unitTest.success('success')
 * unitTest.log('just a log')
 * unitTest.assertDeepEqual({ a: 'b' }, { a: 'b' })
 * unitTest.expectException(() => { throw new Error('Hello World') }, 'Error', 'message')
 */
class UnitTest {
    constructor(verbose = false, debug = false) {
        this._successAmount = 0
        this._failAmount = 0
        this._verbose = verbose
        this._debug = debug
    }

    /**
     * Set verbose to true to print all success infos
     * @type {bool}
     */
    set verbose(verbose) { this._verbose = verbose }
    get verbose() { return this._verbose }

    /**
     * Set debug to true, to print a stack trace on fail
     * @type {bool}
     */
    set debug(debug) { this._debug = debug }
    get debug() { return this._debug }

    /**
     * Show the overall test result. Exits the process with "1" on failure
     * @param {number} expectedAmount expected amount of positive test in the current run
     */
    showResult(expectedAmount) {
        console.log('success: %s, failed: %s', this._successAmount, this._failAmount)
        if (expectedAmount !== undefined && expectedAmount !== this._successAmount) {
            console.error('Failed! We expected ' + expectedAmount + ' success messages but have ' + this._successAmount)
            process.exit(1)
        } else if (this._failAmount !== 0) {
            console.error('Failed!')
            process.exit(1)
        } else {
            console.log('passed!')
        }
    }

    /**
     * Adds a failure
     * @param {string} message message to print on failure
     */
    fail(message) {
        this._failAmount++
        if (message === undefined || message === null) {
            message = ''
        }
        console.error('failed: ' + message)
        if (this._debug) {
            console.log(new Error().stack)
        }
    }

    /**
     * Adds a success
     * @param {string} message message to print on success (if verbose is true)
     */
    success(message) {
        this._successAmount++
        if (message === undefined || message === null) {
            message = ''
        }
        if (this._verbose) {
            console.log('success: ' + message)
        }
    }

    /**
     * Tests a value for beeing true, fails if the value is false
     * @param {boolean} test test value
     * @param {string} message info message on success/fail
     * @returns {boolean} true/false based on success
     */
    assertTrue(test, message) {
        if (message === undefined || message === null) {
            message = ''
        }
        if (test) {
            this.success(message)
        } else {
            this.fail(test + ' is not true ' + message)
        }
        return test
    }

    /**
     * Tests a value for beeing false, fails if the value is true
     * @param {boolean} test test value
     * @param {string} message info message on success/fail
     * @returns {boolean} true/false based on success
     */
    assertFalse(test, message) {
        if (message === undefined || message === null) {
            message = ''
        }
        const result = !test
        if (result) {
            this.success(message)
        } else {
            this.fail(test + ' is not false ' + message)
        }
        return result
    }

    /**
     * Compares two values, fails if they are not equal "=="
     * @param {any} a first value
     * @param {any} b second value
     * @param {string} message info message on success/fail
     * @returns {boolean} true/false based on success
     */
    assertEqual(a, b, message) {
        if (message === undefined || message === null) {
            message = ''
        }
        const result = (a === b)
        if (result) {
            this.success(message)
        } else {
            this.fail(a + ' != ' + b + ' ' + message)
        }
        return result
    }

    /**
     * Validates a result object against an expected object. It validates with
     * exact equal, that "result" has all object properties of expected.
     * @param {Object} result object to be validated
     * @param {Object} expected expected object
     * @param {string} path path to be displayed on success/error
     * @param {boolean} [exact=false] true, if result may not have additional properties
     * @returns {boolean} true, if the test is ok
     */
    validateResult(toValidate, expected, path, exact = false) {
        let result = true
        for (const property in expected) {
            if (toValidate[property] !== expected[property]) {
                result = false
                this.fail(path + '/' + property)
            }
        }
        if (exact) {
            for (const property in toValidate) {
                if (toValidate[property] !== expected[property]) {
                    result = false
                    this.fail(path + '/' + property)
                }
            }
        }
        if (result) {
            this.success(path)
        }
        return result
    }

    /**
     * Recursively replaces substrings
     * @param { object | array | string } toReplace 
     * @param {{ [index:string]: string }} strRepl replace string by string
     * @returns object with replaced values in strings
     */
    replaceRec(toReplace, strRepl) {
        if (toReplace === null || toReplace === undefined) {
            return toReplace
        } else if (Array.isArray(toReplace)) {
            for (const index in toReplace) {
                const elem = toReplace[index]
                toReplace[index] = this.replaceRec(elem, strRepl)
            }
        } else if (typeof (toReplace) === 'object') {
            for (const index in toReplace) {
                toReplace[index] = this.replaceRec(toReplace[index], strRepl)
            } 
        } else if (typeof (toReplace) === 'string') {
            for (const searchValue in strRepl) {
                const replaceValue = strRepl[searchValue]
                if (toReplace === searchValue) {
                    toReplace = replaceValue
                } else if (typeof(replaceValue) === 'string') {
                    toReplace = toReplace.replace(searchValue, replaceValue)
                }
            }
        }
        return toReplace
    }

    /**
     * @description
     * Checks an element recursively for differences. It only checks values that are specified in "expected"
     * and ignores additional data in result. This enables us to specify only the values that we like to check
     * in the test cases.
     * @param {any} toValidate element to be validated
     * @param {any} expected description of expected element
     * @param {string} path path to the element to compare
     * @param {string} [exact=false]
     * @throws {string} first difference
     */
    validateRec(toValidate, expected, path, exact = false) {
        if (toValidate === expected) {
            return
        }
        else if (toValidate === undefined) {
            throw path + ': undefined'
        } else if (typeof (toValidate) !== typeof (expected) || Array.isArray(toValidate) !== Array.isArray(expected)) {
            throw path + ': types are different '
        }
        else if (Array.isArray(expected)) {
            if (toValidate.length !== expected.length) {
                throw path + ': arrays have different length'
            }
            for (const index in toValidate) {
                this.validateRec(toValidate[index], expected[index], path + '/' + index)
            }
        } else if (typeof (expected) === 'object') {
            for (const index in expected) {
                this.validateRec(toValidate[index], expected[index], path + '/' + index)
            } 
            if (exact) {
                for (const index in toValidate) {
                    if (expected[index] === undefined) {
                        throw `${path}: additional property ${index}`
                    }
                }
            }
        } else {
            throw path + ': elements have different value: ' + toValidate + ' !== ' + expected
        }
    }

    /**
     * @private
     * @description
     * Checks an element "deeply" for differences
     * @param {any} a first element to compare
     * @param {any} b second element to compare
     * @param {string} path path to the element to compare
     * @throws {string} description of the difference including the path to the element
     */
    _deepEqualRec(a, b, path) {
        if (a === b) {
            return
        }
        if (typeof (a) !== typeof (b) || Array.isArray(a) !== Array.isArray(b)) {
            throw path + ': types are different '
        }
        if (Array.isArray(a)) {
            if (a.length !== b.length) {
                throw path + ': arrays have different length'
            }
            for (const index in a) {
                this._deepEqualRec(a[index], b[index], path + '/' + index)
            }
        } else if (typeof (a) === 'object') {
            if (Object.keys(a).length !== Object.keys(b).length) {
                throw path + ': objects have different amount of properties'
            }
            if (a.constructor.name !== b.constructor.name) {
                throw path + ': objects have different constructor names: ' + a.constructor.name + ' != ' + b.constructor.name
            }
            for (const index in a) {
                this._deepEqualRec(a[index], b[index], path + '/' + index)
            }
        } else {
            throw path + ': elements have different value: ' + a + ' !== ' + b
        }
        assert.deepStrictEqual(a, b, path)
    }

    /**
     * Compares two objects deeply
     * @param {any} a first object to compare
     * @param {any} b second object to compare
     * @param {string} message message to show
     * @returns {boolean} true/false based on success
     */
    assertDeepEqual(a, b, message) {
        let result = true
        if (message === undefined || message === null) {
            message = ''
        }
        try {
            this._deepEqualRec(a, b, '')
            assert.deepStrictEqual(a, b, message)
            this.success(message)
        } catch (err) {
            this.fail(message + ' ' + err)
            result = false
        }
        return result
    }

    /**
     * Runs a function and checks for a returned expection
     * @param {function} callback function causing the expection
     * @param {string} instance instance of the exception
     * @returns {boolean} true on expection
     */
    expectException(callback, instance, message) {
        try {
            callback()
        } catch (err) {
            const isInstance = instance === undefined || err.constructor.name === instance
            if (isInstance) {
                this.success(message)
            } else {
                this.fail('Wrong assertion ' + message)
            }
            return true
        }
        this.fail('No assertion ' + message)
        return false
    }

    /**
     * Pauses the execution for a while (needs to "wait") for the result.
     * @param {number} timeInMilliseconds delay in milliseconds
     * @returns {Promise} to wait for
     */
    delay(timeInMilliseconds) {
        if (this._verbose) {
            console.log('wait ' + timeInMilliseconds / 1000 + ' seconds...')
        }
        return new Promise(resolve => setTimeout(resolve, timeInMilliseconds))
    }

    /**
     * Logs a string, if verbose
     * @param {string} info info to log
     */
    log(info) {
        if (this._verbose) {
            console.log(info)
        }
    }

    /**
     * Logs an error usually from a catch section
     * @param {Error|string} err error information
     */
    logError(err) {
        if (this._verbose) {
            errorlog(err, this._debug)
        }
    }
}

module.exports = UnitTest
