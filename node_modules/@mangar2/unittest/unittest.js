/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview This module provides a simple class to support unit tests, this is not a framework.
 * Use "testrun", as a simple uinit test framework
 */

'use strict'

const assert = require('assert')
const errorlog = require('@mangar2/errorlog')

/**
 * Creates an object supporting unit tests
 * @param {boolean} verbose true to give more output
 * @param {bool} debug true, to print a stack trace on fail
 * @example
 * const unitTest = new UnitTest(true, true)
 * unitTest.assertEqual('1', '1', 'equal')
 * unitTest.assertTrue(true, 'true')
 * unitTest.assertFalse(false, 'false')
 * unitTest.success('success')
 * unitTest.log('just a log')
 * unitTest.assertDeepEqual({ a: 'b' }, { a: 'b' })
 * unitTest.expectException(() => { throw new Error('Hello World') }, 'Error', 'message')
 */
class UnitTest {
    constructor (verbose = false, debug = false) {
        this._successAmount = 0
        this._failAmount = 0
        this._verboase = verbose
        this._debug = debug
    }

    /**
     * Set verbose to true to print all success infos
     * @type {bool}
     */
    set verbose (verbose) { this._verbose = verbose }
    get verbose () { return this._verbose }

    /**
     * Set debug to true, to print a stack trace on fail
     * @type {bool}
     */
    set debug (debug) { this._debug = debug }
    get debug () { return this._debug }

    /**
     * Show the overall test result. Exits the process with "1" on failure
     * @param {number} expectedAmount expected amount of positive test in the current run
     */
    showResult (expectedAmount) {
        console.log('success: %s, failed: %s', this._successAmount, this._failAmount)
        if (expectedAmount !== undefined && expectedAmount !== this._successAmount) {
            console.error('Failed! We expected ' + expectedAmount + ' success messages but have ' + this._successAmount)
            process.exit(1)
        } else if (this._failAmount !== 0) {
            console.error('Failed!')
            process.exit(1)
        } else {
            console.log('passed!')
        }
    }

    /**
     * Adds a failure
     * @param {string} message message to print on failure
     */
    fail (message) {
        this._failAmount++
        if (message === undefined || message === null) {
            message = ''
        }
        console.error('failed: ' + message)
        if (this._debug) {
            console.log(new Error().stack)
        }
    }

    /**
     * Adds a success
     * @param {string} message message to print on success (if verbose is true)
     */
    success (message) {
        this._successAmount++
        if (message === undefined || message === null) {
            message = ''
        }
        if (this._verboase) {
            console.log('success: ' + message)
        }
    }

    /**
     * Tests a value for beeing true, fails if the value is false
     * @param {boolean} test test value
     * @param {string} message info message on success/fail
     * @returns {boolean} true/false based on success
     */
    assertTrue (test, message) {
        if (message === undefined || message === null) {
            message = ''
        }
        if (test) {
            this.success(message)
        } else {
            this.fail(test + ' is not true ' + message)
        }
        return test
    }

    /**
     * Tests a value for beeing false, fails if the value is true
     * @param {boolean} test test value
     * @param {string} message info message on success/fail
     * @returns {boolean} true/false based on success
     */
    assertFalse (test, message) {
        if (message === undefined || message === null) {
            message = ''
        }
        const result = !test
        if (result) {
            this.success(message)
        } else {
            this.fail(test + ' is not false ' + message)
        }
        return result
    }

    /**
     * Compares two values, fails if they are not equal "=="
     * @param {any} a first value
     * @param {any} b second value
     * @param {string} message info message on success/fail
     * @returns {boolean} true/false based on success
     */
    assertEqual (a, b, message) {
        if (message === undefined || message === null) {
            message = ''
        }
        const result = (a === b)
        if (result) {
            this.success(message)
        } else {
            this.fail(a + ' != ' + b + ' ' + message)
        }
        return result
    }

    /**
     * @private
     * Checks an element "deeply" for differences
     * @param {any} a first element to compare
     * @param {any} b second element to compare
     * @param {string} path path to the element to compare
     * @throws {string} description of the difference including the path to the element
     */
    _deepEqualRec (a, b, path) {
        if (typeof (a) !== typeof (b) || Array.isArray(a) !== Array.isArray(b)) {
            throw path + ': types are different '
        }
        if (Array.isArray(a)) {
            if (a.length !== b.length) {
                throw path + ': arrays have different length'
            }
            for (const index in a) {
                this._deepEqualRec(a[index], b[index], path + '/' + index)
            }
        } else if (typeof (a) === 'object') {
            if (Object.keys(a).length !== Object.keys(b).length) {
                throw path + ': objects have different amount of properties'
            }
            if (a.constructor.name !== b.constructor.name) {
                throw path + ': objects have different constructor names: ' + a.constructor.name + ' != ' + b.constructor.name
            }
            for (const index in a) {
                this._deepEqualRec(a[index], b[index], path + '/' + index)
            }
        } else if (a !== b) {
            throw path + ': elements have different value: ' + a + ' !== ' + b
        }
        assert.deepStrictEqual(a, b, path)
    }

    /**
     * Compares two objects deeply
     * @param {any} a first object to compare
     * @param {any} b second object to compare
     * @param {string} message message to show
     * @returns {boolean} true/false based on success
     */
    assertDeepEqual (a, b, message) {
        let result = true
        if (message === undefined || message === null) {
            message = ''
        }
        try {
            this._deepEqualRec(a, b, '')
            assert.deepStrictEqual(a, b, message)
            this.success(message)
        } catch (err) {
            this.fail(message + ' ' + err)
            result = false
        }
        return result
    }

    /**
     * Runs a function and checks for a returned expection
     * @param {function} callback function causing the expection
     * @param {string} instance instance of the exception
     * @returns {boolean} true on expection
     */
    expectException (callback, instance, message) {
        try {
            callback()
        } catch (err) {
            const isInstance = instance === undefined || err.constructor.name === instance
            if (isInstance) {
                this.success(message)
            } else {
                this.fail('Wrong assertion ' + message)
            }
            return true
        }
        this.fail('No assertion ' + message)
        return false
    }

    /**
     * Pauses the execution for a while (needs to "wait") for the result.
     * @param {number} timeInMilliseconds delay in milliseconds
     * @returns {Promise} to wait for
     */
    delay (timeInMilliseconds) {
        if (this._verboase) {
            console.log('wait ' + timeInMilliseconds / 1000 + ' seconds...')
        }
        return new Promise(resolve => setTimeout(resolve, timeInMilliseconds))
    }

    /**
     * Logs a string, if verbose
     * @param {string} info info to log
     */
    log (info) {
        if (this._verboase) {
            console.log(info)
        }
    }

    /**
     * Logs an error usually from a catch section
     * @param {Error|string} err error information
     */
    logError (err) {
        if (this._verboase) {
            errorlog(err, this._debug)
        }
    }
}

module.exports = UnitTest
