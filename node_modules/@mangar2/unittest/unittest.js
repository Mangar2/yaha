/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      unittest.js
 * Purpouse:  provides a simple class supporting unit tests
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

'use strict'

const assert = require('assert')

module.exports = class UnitTest {
    /**
     * Creates an object to support unit tests
     * @param {boolean} verbose true to give more output
     * @param {bool} debug true, to print a stack trace on fail
     */
    constructor (verbose = false, debug = false) {
        this.successAmount = 0
        this.failAmount = 0
        this.verbose = verbose
        this.debug = debug
    }

    /**
     * @param {bool} verbose true, to print all success infos
     */
    set verbose (verbose) { this._verbose = verbose }
    get verbose () { return this._verbose }

    /**
     * @param {bool} debug true, to print a stack trace on fail
     */
    set debug (debug) { this._debug = debug }
    get debug () { return this._debug }

    /**
     * Show the overall test result. Exits the process with "1" on failure
     * @param {number} expectedAmount expected amount of positive test in the current run
     */
    showResult (expectedAmount) {
        console.log('success: %s, failed: %s', this.successAmount, this.failAmount)
        if (expectedAmount !== undefined && expectedAmount !== this.successAmount) {
            console.error('Failed! We expected ' + expectedAmount + ' success messages but have ' + this.successAmount)
            process.exit(1)
        } else if (this.failAmount !== 0) {
            console.error('Failed!')
            process.exit(1)
        } else {
            console.log('passed!')
        }
    }

    /**
     * Adds a failure
     * @param {string} message message to print on failure
     */
    fail (message) {
        this.failAmount++
        console.error('failed: ' + message)
        if (this.debug) {
            console.log(new Error().stack)
        }
    }

    /**
     * Adds a success
     * @param {string} message message to print on success (if verbose is true)
     */
    success (message) {
        this.successAmount++
        if (this.verbose) {
            console.log('success: ' + message)
        }
    }

    /**
     * Tests a value for beeing true, fails if the value is false
     * @param {boolean} test test value
     * @param {string} message info message on success/fail
     */
    assertTrue (test, message) {
        if (test) {
            this.success(message)
        } else {
            this.fail(test + ' is not true ' + message)
        }
    }

    /**
     * Tests a value for beeing false, fails if the value is true
     * @param {boolean} test test value
     * @param {string} message info message on success/fail
     */
    assertFalse (test, message) {
        if (!test) {
            this.success(message)
        } else {
            this.fail(test + ' is not false ' + message)
        }
    }

    /**
     * Compares two values, fails if they are not equal "=="
     * @param {any} a first value
     * @param {any} b second value
     * @param {string} message info message on success/fail
     */
    assertEqual (a, b, message) {
        if (a === b) {
            this.success(message)
        } else {
            this.fail(a + ' != ' + b + ' ' + message)
        }
    }

    /**
     * Checks an element "deeply" for differences
     * @param {any} a first element to compare
     * @param {any} b second element to compare
     * @param {string} path path to the element to compare
     * @throws {string} description of the difference including the path to the element
     */
    _deepEqualRec (a, b, path) {
        if (typeof (a) !== typeof (b) || Array.isArray(a) !== Array.isArray(b)) {
            throw path + ': types are different '
        }
        if (Array.isArray(a)) {
            if (a.length !== b.length) {
                throw path + ': arrays have different length'
            }
            for (const index in a) {
                this._deepEqualRec(a[index], b[index], path + '/' + index)
            }
        } else if (typeof (a) === 'object') {
            if (Object.keys(a).length !== Object.keys(b).length) {
                throw path + ': objects have different amount of properties'
            }
            if (a.constructor.name !== b.constructor.name) {
                throw path + ': objects have different constructor names: ' + a.constructor.name + ' != ' + b.constructor.name
            }
            for (const index in a) {
                this._deepEqualRec(a[index], b[index], path + '/' + index)
            }
        } else if (a !== b) {
            throw path + ': elements have different value: ' + a + ' !== ' + b
        }
        assert.deepStrictEqual(a, b, path)
    }

    /**
     * Compares two objects deeply
     * @param {any} a first object to compare
     * @param {any} b second object to compare
     * @param {string} message message to show
     */
    assertDeepEqual (a, b, message) {
        try {
            this._deepEqualRec(a, b, '')
            assert.deepStrictEqual(a, b, message)
            this.success(message)
        } catch (err) {
            this.fail(message + ' ' + err)
        }
    }

    /**
     * Runs a function and checks for a returned expection
     * @param {function causing the exception} callback
     * @param {string} instance instance of the exception
     */
    expectException (callback, instance, message) {
        try {
            callback()
        } catch (err) {
            const isInstance = instance === undefined || err.constructor.name === instance
            if (isInstance) {
                this.success(message)
            } else {
                this.fail('Wrong assertion ' + message)
            }
            return true
        }
        this.fail('No assertion ' + message)
        return false
    }

    /**
     * Pauses the execution for a while (needs to "wait") for the result.
     * @param {number} timeInMilliseconds delay in milliseconds
     */
    delay (timeInMilliseconds) {
        if (this.verbose) {
            console.log('wait ' + timeInMilliseconds / 1000 + ' seconds...')
        }
        return new Promise(resolve => setTimeout(resolve, timeInMilliseconds))
    }

    /**
     * Logs a string, if verbose
     * @param {string} info info to log
     */
    log (info) {
        if (this.verbose) {
            console.log(info)
        }
    }
}
