/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview asyncronously retries function calls several times with delay inbetween
 * Prevents parallel retry loops with the same topic.
 */

'use strict'

const Callbacks = require('./callbacks')
const Types = require('./types')
const delay = require('./delay')

/**
 * Helper function that sets a "topic call number" that increases with each call to retry with the same topic.
 * 
 * @param {Object} topicCalledList - A list of topics that have been asked to retry.
 * @param {string} topic - The name of the topic to retry.
 * @returns {number} - The current number of calls/retries for a topic.
 * @private
 */
function increaseTopicCallNumber (topicCalledList, topic) {
    if (topicCalledList[topic] === undefined) {
        topicCalledList[topic] = 0
    } else {
        topicCalledList[topic]++
    }
    return topicCalledList[topic]
}


/**
 * Checks if the current retry loop is the newest retry loop for a topic.
 * 
 * @param {Object} topicCalledList - A list of topics that have been asked to retry.
 * @param {string} topic - The name of the topic to retry.
 * @param {number} callNumber - The current number of calls/retries for a topic.
 * @returns {boolean} - `true` if the current retry loop is the newest retry loop for a topic, `false` otherwise.
 * @private
 */
function isNewestTopicCall (topicCalledList, topic, callNumber) {
    return topicCalledList[topic] === callNumber
}

/**
 * Class providing a retry facility calling a callback "count" times asyncronously with a delay inbetween
 * Additionally providing a "topic" based retry ("topicRetry") with the following functionality:
 * - Asynchronously calles a global callback "count" times with a delay inbetween
 * - If no global callback is provided, it calls a callback prior registrated to the topic
 * - If topicRetry is called with a still running existing retry loop for the same topic, this existing is terminated.
 * @param {boolean} [immediateFirstCall=true] true, if the first call should happen immediately
 * @example
 * const retry = new Retry()
 * // prints 5 times hello world, with a delay of 1 second between each output
 * retry.retry(5, 1000, () => console.log("hello world"))
 * // prints hello1, world, hello2, world, hello2
 * retry.topicRetry('hello', 2, 1000, () => console.log("hello1"))
 * retry.topicRetry('world', 2, 1000, () => console.log("world"))
 * retry.topicRetry('hello', 2, 1000, () => console.log("hello2"))
 */
class Retry {
    constructor (immediateFirstCall = true) {
        this._topicCalledList = {}
        this._callbacks = new Callbacks()
        this._immediateFirstCall = immediateFirstCall
    }

    /**
     * Registers a callback function for a specific topic.
     * 
     * @param {string} topic - The name of the topic to register the callback for.
     * @param {function()} callback - The function to be called when the topic is matched on retries.
     * @throws {Error} If the callback is not a function.
     */
    on (topic, callback) {
        this._callbacks.on(topic, callback)
    }

    /**
     * Calls a callback function multiple times and waits between the calls.
     * 
     * @param {number} count - The number of times to call the callback function.
     * @param {number} delayInMilliseconds - The amount of time, in milliseconds, to wait between each call.
     * @param {function(loopNumber): Promise<boolean>} callback - The function to be called on each retry.
     * @returns {Promise} - A promise that resolves when all callbacks are done.
     */
    async retry (count, delayInMilliseconds, callback) {
        let terminateLoop = false
        if (!this._immediateFirstCall) {
            await delay(delayInMilliseconds)
        }
        for (let loop = 0; (loop < count) && !terminateLoop; loop++) {
            if (callback !== undefined) {
                terminateLoop = await callback(loop)
            }
            await delay(delayInMilliseconds)
        }
    }

    /**
     * Stops a retry loop for a specific topic by increasing the topic's call number.
     * 
     * @param {string} topic - The name of the retry topic to stop.
     */
    stopRetry (topic) {
        increaseTopicCallNumber(this._topicCalledList, topic)
    }

    /**
     * Calls a callback function multiple times and waits between the calls for a specific topic.
     * If `topicRetry` is called with the same topic more than once, it will stop the running retry loop with the same topic.
     * 
     * @param {string} topic - The name of the topic to retry.
     * @param {number} count - The number of times to call the callback function.
     * @param {number} delayInMilliseconds - The amount of time, in milliseconds, to wait between each call.
     * @param {function(loopNumber): Promise<boolean>} callback - The function to be called on each retry.
     * @returns {Promise} - A promise that resolves when all callbacks are done.
     */
    async topicRetry (topic, count, delayInMilliseconds, callback) {
        const topicCalledNumber = increaseTopicCallNumber(this._topicCalledList, topic)
        if (!this._immediateFirstCall) {
            await delay(delayInMilliseconds)
        }
        for (let loop = 0; (loop < count); loop++) {
            let terminateLoop = false
            if (!isNewestTopicCall(this._topicCalledList, topic, topicCalledNumber)) {
                terminateLoop = true
            } else if (Types.isFunction(callback)) {
                terminateLoop = await callback(loop)
            } else if (this._callbacks.hasCallback(topic)) {
                terminateLoop = await this._callbacks.invokeCallbackAsync(topic, loop)
            } else {
                throw new Error('No callback provided in topicRetry')
            }
            if (terminateLoop) {
                break
            }
            await delay(delayInMilliseconds)
        }
    }
}

module.exports = Retry
