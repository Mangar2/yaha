/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview This module provides a class to manage callbacks. Use it in Classes to support setting
 * callbacks.
 */
import { Types } from './types';

/**
 * A class for managing callback functions for events.
 * This class provides methods to register, check, invoke, and asynchronously invoke callbacks for specific events.
 *
 * @class Callbacks
 * @example
 * const callbacks = new Callbacks(['publish']);
 * // register a callback
 * callbacks.on('publish', (param) => { console.log('called publish with ' + param) });
 * // invoke a callback
 * callbacks.invokeCallback('publish', 'a parameter');
 */
export class Callbacks {
    private _supportedEvents: string[] | undefined;
    private _callbacks: { [key: string]: (...args: any[]) => any };

    constructor(supportedEvents: string[] | undefined = undefined) {
        this._supportedEvents = supportedEvents;
        this._callbacks = {};
    }

    /**
     * Registers a callback function for an event.
     * 
     * @param {string} event - The name of the event.
     * @param {function} callback - The callback function.
     * @throws {Error} - Throws an error if the event is not supported or if the callback is not a function.
     */
    on(event: string, callback: (...args: any[]) => any): void {
        const eventLowerCase = event.toLowerCase();
        if (Array.isArray(this._supportedEvents) && !this._supportedEvents.includes(eventLowerCase)) {
            throw Error('Event not supported: ' + event);
        }
        if (!Types.isAnyFunction(callback)) {
            throw Error('Tried to register a callback that is not a function: ' + event);
        }    
        this._callbacks[eventLowerCase] = callback;
    }

    /**
     * Checks if a callback is registered for a particular event.
     * 
     * @param {string} name - The name of the callback to look for, not case sensitive.
     * @returns {boolean} - True, if the callback is registered, false otherwise.
     */
    hasCallback(name: string): boolean {
        if (Types.isString(name)) {
            return Object.prototype.hasOwnProperty.call(this._callbacks, name.toLowerCase());
        } else {
            return false;
        }
    }

    /**
     * Invokes a callback function for an event.
     * 
     * @param {string} event - The event name (not case sensitive) for the callback.
     * @param {...any} params - Any parameters to pass to the callback function.
     * @returns {any} - Returns the result of the callback function.
     * @throws {Error} - Throws an error if the event is not supported or if the callback is not a function.
     */
    invokeCallback(event: string, ...params: any[]): any {
        const eventLowerCase = event.toLowerCase();
        if (Array.isArray(this._supportedEvents) && !this._supportedEvents.includes(eventLowerCase)) {
            throw Error('Event not supported: ' + event);
        }
        const callback = this._callbacks[eventLowerCase];
        if (!Types.isAnyFunction(callback)) {
            throw Error('No callback registered for event: ' + event);
        }
        return callback(...params);
    }

    /**
     * Asynchronously invokes a callback function for an event.
     * This is useful when the callback function is async and you want to wait for its completion.
     *
     * @param {string} event - The event name (not case sensitive) for the callback.
     * @param {...any} params - Any parameters to pass to the callback function.
     * @returns {Promise<any>} - A Promise that resolves to the result of the callback, or null if no callback is registered.
     * @throws {Error} - If the event is not supported or if no callback is registered for the event.
     */
    async invokeCallbackAsync(event: string, ...params: any[]): Promise<any> {
        const eventLowerCase = event.toLowerCase();
        if (Array.isArray(this._supportedEvents) && !this._supportedEvents.includes(eventLowerCase)) {
            throw Error('Event not supported: ' + event);
        }
        const callback = this._callbacks[eventLowerCase];
        if (!Types.isAnyFunction(callback)) {
            throw Error('No callback registered for event: ' + event);
        }
        return callback ? Promise.resolve(callback(...params)) : null;
    }
}

