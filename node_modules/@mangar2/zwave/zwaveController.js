/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      zwavecontroller.js
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * ---------------------------------------------------------------------------------------------------
 */

'use strict'

var OpenZWave = require('openzwave-shared')
const Message = require('@mangar2/message')
const Devices = require('@mangar2/devices')
const errorLog = require('@mangar2/errorlog')
const Callbacks = require('@mangar2/callbacks')

const ZWAVE_CONFIGURATION = 0x70

const mapNotification = {
    0: 'message completed',
    1: 'timeout',
    2: 'nop',
    3: 'node awake',
    4: 'node sleep',
    5: 'node dead',
    6: 'node alive'
}

/**
 * Recursively searches for an object in the zwave node tree
 * @param {object} object object to search for the right zwave object
 * @param {string} label label of the zwave object to search for
 * @param {number} instance instance number of the zwave object to search for
 */
function getObjectByLabelRec (object, label, instance) {
    let result
    if (typeof (object) === 'object') {
        if (object.class_id) {
            if (object.label === label && object.instance === instance) {
                result = object
            }
        } else {
            for (const element in object) {
                const subObject = object[element]
                result = getObjectByLabelRec(subObject, label, instance)
                if (result) {
                    break
                }
            }
        }
    }
    return result
}

/**
 * Gets a zwave controllable element by label
 * @param {object[]} nodes zwave nodes structure
 * @param {string} label label of the setting
 * @param {number} nodeId id of the node
 * @param {number} [instanceId=1] id of the instance
 */
function getObjectByLabel (nodes, label, nodeId, instanceId = 1) {
    const classes = nodes[nodeId].classes
    const result = getObjectByLabelRec(classes, label, instanceId)
    return result
}

class ZwaveController {
    /**
     * Constructs a new zwave controller and binds it to an input device
     * @param {object} config zwave controller configuration
     * @param {string} config.device zwave controller device (COM port)
     * @param {string} config.topic zwave controller topic to send messages
     * @param {Devices} deviceList device list
     */
    constructor (config, deviceList) {
        // this test assumes no actual ZWave controller exists on the system
        // and is just a rudimentary check that the driver can initialise itself.
        this._zwave = new OpenZWave({
            ConsoleOutput: false,
            Logging: true,
            SaveLogLevel: 3,
            QueueLogLevel: 3,
            DumpTriggerLevel: 3,
            SaveConfiguration: true,
            DriverMaxAttempts: 3,
            PollInterval: 500,
            SuppressValueRefresh: false
        })
        this.nodes = []
        this.homeId = null
        this._config = config
        this._deviceList = new Devices(deviceList)
        this._callbacks = new Callbacks(['publish'])

        this.registerZwaveCallbacks()
        this._zwave.connect(this._config.device)
        console.log('connected to ' + this._config.device)
    }

    /**
     * Register callbacks for zwave
     */
    registerZwaveCallbacks () {
        this._zwave.on('driver ready', (homeId) => {
            this.homeId = homeId
            console.log('scanning homeid=0x%s...', this.homeId.toString(16))
        })

        this._zwave.on('driver failed', () => {
            console.log('failed to start driver. Stopping module')
            process.exit()
        })

        this._zwave.on('scan complete', () => {
            console.log('scan complete')
        })
        this._zwave.on('notification', (nodeid, notif) => {
            console.log('notification: node:%d, %s (%s)', nodeid, mapNotification[notif], notif)
        })
        this._zwave.on('controller command', (r, s) => {
            console.log('controller commmand feedback: r=%d, s=%d', r, s)
        })
        this._zwave.on('node added', nodeId => this._addNode(nodeId))
        this._zwave.on('node ready', (nodeId, nodeInfo) => this.setNodeInfo(nodeId, nodeInfo))
        this._zwave.on('value added', (nodeId, comClass, value) => this._onValueAdded(nodeId, comClass, value))
        this._zwave.on('value removed', (nodeId, comClass, index) => this._onValueRemoved(nodeId, comClass, index))
        this._zwave.on('value changed', (nodeId, comClass, value) => this.publishValueChange(nodeId, comClass, value))
        this._zwave.on('value refreshed', (nodeid, commandclass, valueId) => {
            console.log('refreshed: node=%d, class=%d, valueId=%d', nodeid, commandclass, valueId)
        })
    }

    /**
     * Sets a callback.
     * @param {string} event event name (not case sensitive) for the callback
     * @param {function} callback(parameter)
     * @throws {Error} if the event is not supported
     * @throws {Error} if the callback is not 'function'
     */
    on (event, callback) {
        this._callbacks.on(event, callback)
    }

    /**
     * Adds a new zwave device node
     * @param {string} nodeId id of the zwave device node
     */
    _addNode (nodeId) {
        this.nodes[nodeId] = {
            manufacturer: '',
            manufacturerid: '',
            product: '',
            producttype: '',
            productid: '',
            type: '',
            name: '',
            loc: '',
            classes: {},
            ready: false
        }
    }

    /**
     * Logs the infos of a zwave device node to console
     * @param {string} nodeId id of the zwave device node
     */
    logNode (nodeId) {
        const nodeInfo = this.nodes[nodeId]
        const manufacturer = nodeInfo.manufacturer ? nodeInfo.manufacturer : 'id=' + nodeInfo.manufacturerid
        const product = nodeInfo.product ? nodeInfo.product : 'product=' + nodeInfo.productid
        const productType = nodeInfo.producttype

        console.log('node%d: %s, %s, type=%s', nodeId, manufacturer, product, productType)
        console.log('node%d: name="%s", type="%s", location="%s"', nodeId, nodeInfo.name, nodeInfo.type, nodeInfo.loc)

        for (const comclass in nodeInfo.classes) {
            var values = nodeInfo.classes[comclass]
            console.log('node%d: class %d', nodeId, comclass)
            for (const idx in values) {
                console.log('node%d:   %s=%s', nodeId, values[idx].label, values[idx].value)
            }
        }
    }

    /**
     * Sets the node info
     * @param {string} nodeId id of the zwave device node
     * @param {object} nodeInfo additional information for the node
     */
    setNodeInfo (nodeId, nodeInfo) {
        const node = this.nodes[nodeId]
        node.manufacturer = nodeInfo.manufacturer
        node.manufacturerid = nodeInfo.manufacturerid
        node.product = nodeInfo.product
        node.producttype = nodeInfo.producttype
        node.productid = nodeInfo.productid
        node.type = nodeInfo.type
        node.name = nodeInfo.name
        node.loc = nodeInfo.loc
        node.ready = true

        for (const comClass in node.classes) {
            switch (comClass) {
            case 0x25: // COMMAND_CLASS_SWITCH_BINARY
            case 0x26: // COMMAND_CLASS_SWITCH_MULTILEVEL
                this._zwave.enablePoll(nodeId, comClass)
                break
            }
        }

        // this.logNode(nodeId)
    }

    /**
     * Publishes a value
     * @param {string} nodeId id of the zwave device
     * @param {object} value new value information structure of the device class
     * @param {string} reasonString the reason string
     */
    publishValue (nodeId, value, reasonString) {
        try {
            const label = value.label
            let topic
            if (nodeId === 1) {
                topic = this._config.topic
            } else {
                const device = this._deviceList.attributeToDevice('node_id', nodeId)
                topic = device === undefined ? undefined : device.topic
            }
            if (topic !== undefined) {
                topic = topic + '/' + label
                const message = new Message(topic, value.value, reasonString)
                this._callbacks.invokeCallback('publish', message)
            }
        } catch (err) {
            console.log("Missing configuration entry for nodeId %s, value %s, reason %s", nodeId, value, reasonString)
            console.log(err)
        }
    }

    /**
     * Publishes a value change
     * @param {string} nodeId id of the zwave device
     * @param {string} comClass parameter class
     * @param {object} value new value information structure of the device class
     */
    publishValueChange (nodeId, comClass, value) {
        const node = this.nodes[nodeId]

        if (!node.classes[comClass]) {
            node.classes[comClass] = {}
        }
        node.classes[comClass][value.index] = value
        this.publishValue(nodeId, value, 'value changed id ' + value.value_id)
    }

    /**
     * Adds a value to the node tree
     * @param {string} nodeId id of the zwave device
     * @param {string} comClass parameter class
     * @param {string} value new value of the device class
     */
    _onValueAdded (nodeId, comClass, value) {
        const node = this.nodes[nodeId]

        if (!node.classes[comClass]) {
            node.classes[comClass] = {}
        }
        node.classes[comClass][value.index] = value
        // do not publish an added value. The value is the default value and not the value of
        // the device.
    }

    /**
     * Handles a value removed event by removing the value from the node tree
     * @param {string} nodeId id of the zwave device
     * @param {string} comClass parameter class
     * @param {string} index value index
     */
    _onValueRemoved (nodeId, comClass, index) {
        const node = this.nodes[nodeId]
        if (node.classes[comClass] && node.classes[comClass][index]) {
            delete node.classes[comClass][index]
        }
    }

    /**
     * Sets a value of a zwave object
     * @param {object} zwaveObject zwave object to set the value to
     * @param {string|number|boolean} value value to set
     */
    _setValue (zwaveObject, value) {
        if (zwaveObject.read_only) {
            throw Error('trying to set a value to a read only device')
        }
        /*
        if (zwaveObject.type === 'bool') {
            value = value === 'on' || value === '1' || value === 1 || value === true || value === 'true'
        }
        if (zwaveObject.type === 'byte') {
            value = Number(value)
        }
        */
        this._zwave.setValue(zwaveObject.node_id, zwaveObject.class_id, zwaveObject.instance, zwaveObject.index, value)
    }

    /**
     * Sets a parameter of a zwave node
     * @param {number} nodeId id of the node
     * @param {number} paramId id of the parameter to set
     * @param {number} value parameter value
     */
    setConfigParam (nodeId, paramId, value) {
        this._zwave.setConfigParam(nodeId, paramId, value)
    }

    /**
     * Sets a value
     * @param {string} topic name of the topic
     * @param {string|number|boolean} value to set
     */
    setValue (topic, value) {
        try {
            const topicArray = topic.split('/')
            const set = topicArray.pop()
            const objectLabel = topicArray.pop()
            const deviceTopic = topicArray.join('/')
            const device = this._deviceList.topicToDevice(deviceTopic)
            if (set !== 'set') {
                throw Error('set expected as last element in topic ' + topic)
            }
            if (device === undefined) {
                throw Error('zwave set value with unknown topic ' + topic)
            }
            if (device.zwavenode === undefined) {
                throw Error('device is not a zwave node (missing zwavenode property) ' + topic)
            }
            const zwaveObject = getObjectByLabel(this.nodes, objectLabel, device.zwavenode, device.instanceId)
            if (zwaveObject === undefined) {
                throw Error('zwave control not found (wrong node name)' + topic)
            }
            if (zwaveObject.class_id === ZWAVE_CONFIGURATION) {
                this.setConfigParam(zwaveObject.node_id, zwaveObject.index, value)
            } else {
                this._setValue(zwaveObject, value)
            }
        } catch (err) {
            errorLog(err)
        }
    }

    /**
     * Enable adding devices
     */
    addDevice () {
        this._zwave.beginControllerCommand('AddDevice', true)
    }

    /**
     * Disconnects from usb device
     */
    async close () {
        this._zwave.disconnect(this._config.device)
    }
}

module.exports = ZwaveController
