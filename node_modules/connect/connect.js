/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:      connect.js
 * Purpouse:
 * Sends a http request to a http server
 * Usage client = new HttpClient(host, port)
 * client.send(path, method, payload, headers)
 * 
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * Version:     1.0
 * ---------------------------------------------------------------------------------------------------
 */

'use strict';

const errorLog = require('@mangar2/errorlog');
const HttpClient = require('@mangar2/httpclient');
const os = require('os');

/**
 * Gets the IP v4 address of the current device
 * @returns {string} IP v4 address
 */
function getIPv4Address() {
    let networkInterfaces = os.networkInterfaces();
    let address;
    for (let network in networkInterfaces) {
        let networkInterface = networkInterfaces[network];
        networkInterface.forEach(function(info) {
            if ('IPv4' === info.family && info.internal === false) {
                address = info.address;
            }
        });
    }
    return address;
}


module.exports = class Connect {
 
    /**
     * Organises connections to broker
     * @param {string} clientId id of this client
     * @param {string} brokerHost hostname (or ip) of the broker
     * @param {number} brokerPort port of the broker
     * @param {number} listenerPort port to listen for published messages from broker
     */
    constructor(clientId, brokerHost, brokerPort, listenerPort) {
        this.clientId = clientId;
        this.listenerPort = listenerPort;;
        this.myAddress = getIPv4Address();
        this.isConnected = false;
        this.isSubscribed = false;
        this.client = new HttpClient(brokerHost, brokerPort);
    }

    /**
     * Sends an object via put as application/json message
     * @param {string} path path for the http PUT
     * @param {object} payload data to be transported via. PUT
     * @param {function} callback function to be called having an answer
     */
    putJsonMessage(path, headers, payload, callback) {
        this.client.on("result", callback);
        if (headers['Content-Type'] === undefined) {
            headers['Content-Type'] = 'application/json';
        }
        this.client.send(path, "put", payload, headers);
    }

    /**
     * Connects to the broker
     * @param {boolean} clean true, if a disconnect shall clean any connection information
     */
    connect(clean) {
        let promise = new Promise((resolve, reject) =>
        { 
            let payload = {
                clientId: this.clientId,
                clean,
                host: this.myAddress,
                port: this.listenerPort
            }
            this.putJsonMessage("/connect", {}, payload, (statusCode, myheaders, receivedPayload) => {
                
                if (statusCode === 200 && myheaders.packet === "connack") {
                    this.isConnected = true;
                    resolve(JSON.parse(receivedPayload));
                } else {
                    errorLog("Unable to connect to broker statuscode: " + statusCode);
                    reject(statusCode);
                }
            });
        })
        return promise;
    }

    /**
     * Disconnects from the broker
     */
    disconnect() {
        var promise = new Promise((resolve, reject) => {
            let payload = {
                clientId: this.clientId
            }
            this.putJsonMessage("/disconnect", {}, payload, statusCode => {
                if (statusCode < 300) {
                    this.isConnected = false;
                    resolve();
                } else {
                    errorLog("Cannot not disconnect from broker statuscode: " + statusCode);
                    reject(statusCode);
                }
            })
        })
        return promise;
    }

    /**
     * Subscribe to the broker
     * @param {object} topics topics to subscribe to {topic1: QoS1, topic2: QoS2, ...}
     */
    subscribe(topics) {
        let promise = new Promise((resolve, reject) => {
            let payload = {
                clientId: this.clientId,
                topics
            }
            this.putJsonMessage("/subscribe", {}, payload, (statusCode, header, payload) => {
                if (statusCode < 300 && header.packet === "suback") {
                    resolve(payload);
                } else {
                    errorLog("could not subscribe " + topic);
                    reject(payload);
                }
            }); 
        })
        return promise;
    }

        /**
     * Subscribe to the broker
     * @param {object} topics topics to subscribe to {topic1: QoS1, topic2: QoS2, ...}
     */
    unsubscribe(topics) {
        let promise = new Promise((resolve, reject) => {
            let payload = {
                clientId: this.clientId,
                topics
            }
            this.putJsonMessage("/unsubscribe", {}, payload, (statusCode, header, payload) => {
                if (statusCode << 300 && header.packet === "unsuback") {
                    resolve(payload);                    
                } else {
                    errorLog("could not unsubscribe " + topic);
                    reject(topic);
                }
            }); 
        })
        return promise;
    }

    /**
     * First connect, then subscribe
     * @param {boolean} clean true, if a disconnect shall clean any connection information
     * @param {object} topics topics to subscribe to {topic1: QoS1, topic2: QoS2, ...}
     */
    async connectAndSubscribe(clean, topics) {
        await this.connect(clean);
        if (this.isisConnected) {
            await this.subscribe(QoS, topics);
        }
    }


    /**
     * Closes the connection to the broker
     * @param {function} callback callback called on broker response
     */
    async close() {
        await this.client.close();
    }


}

