/**
 * ---------------------------------------------------------------------------------------------------
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * File:        client.js
 * Purpouse:    Hold one connection to a service/sensor
 *
 * Author:      Volker Böhm
 * Copyright:   Volker Böhm
 * Version:     1.0
 * ---------------------------------------------------------------------------------------------------
 */

'use strict';

const TopicMatch = require("@mangar2/topicmatch");
const MessageQueueEntry = require("./messageQueueEntry");

 module.exports = class Client {

    /**
     * Creates a new connection
     * @param {object} param {clientId, host, port} body of the http message
     */
    constructor(param) {
        for (let attrib in param) {
            this[attrib] = param[attrib];
        }
        if (this.subscribePattern !== undefined && this.subscribePattern.constructor.name !== "TopicMatch") {
            this.subscribePattern = new TopicMatch(this.subscribePattern);
        }
        this.rebuildMessageQueues();
        this.nextMessageId = 0;
    }

    rebuildMessageQueues() {
        if (this.QoS0Queue !== undefined) {
            for(let index in this.QoS0Queue) {
                let entry = this.QoS0Queue[index];
                this.QoS0Queue[index] = new MessageQueueEntry(entry.QoS, entry.payload);
            }
        }
        for (let topic in this.orderedTopicsQueue) {
            let queue = this.orderedTopicsQueue[topic];
            for (let index in queue) {
                let entry = queue[index];
                queue[index] = new MessageQueueEntry(entry.QoS, entry.payload);
            }
        }
    }

    /**
     * @returns {boolean} true, if the client is connected
     */
    isConnected() {
        return this.status === "connected";
    }

    /**
     * Gets the message queue
     * @returns {Array} array of queued elements
     */
    getMessageQueue() {
        return this.messageQueue;
    }

    /**
     * sets the connection to "connected", resets the unsuccessful counter to 0, starts with 
     * messageId 0 and stores the current timestamp.
     * @param {any} clientId id of the client
     * @param {string} host host name
     * @param {string} port port name
     * @param {bool} clean true, if the connection will be cleaned on disconnect
     */
    connect(clientId, host, port, clean) {
        this.status = "connected";
        this.sendWithoughSuccess = 0;    
        this.startToTransmitTimestamp = 0;
        
        if (this.clientId === undefined && clientId !== undefined)  {
            this.clientId = clientId;
        }

        if (this.clientId !== clientId) {
            throw Error("clientId does not match (" + clientId + ")");
        }
        
        if (host !== undefined) {
            this.host = host;
        }
        if (port !== undefined) {
            this.port = port;
        }
        if (this.subscribePattern === undefined) {
            this.subscribePattern = new TopicMatch();
        }
        this.QoS0Queue = [];
        if (this.orderedTopicsQueue === undefined) {
            this.orderedTopicsQueue = {}
        }
        
        if (clean !== undefined) {
            this.clean = (clean === true || clean === "true");
        } else if (this.clean === undefined) {
            this.clean = true;
        }

        this.clearRetryCount();
        this.validate();
        this.connectTimestamp = new Date().getTime();
    }

    /**
     * Disconnects a client
     * @param {any} clientId id of the client
     * @throws {Error} if clientId does not match
     */
    disconnect(clientId) {

        if (this.clientId !== clientId) {
            throw Error("clientId does not match (" + clientId + ")");
        }
        
        this.status = "disconnected";          
        this.QoS0Queue = [];
        if (this.clean) {
            this.orderedTopicsQueue = {};
            this.subscribePattern = new TopicMatch();
        }
       
    }

    /**
     * Validates a subscribe/unsubscribe parameter
     * @param {any} clientId id of the client
     * @throws {Error} if clientId does not match or subscription is not given
     */
    validateSubscribe(clientId, subscribe) {
        if (this.clientId !== clientId) {
            throw Error("clientId does not match (" + clientId + ")");
        }
        if (subscribe === undefined) {
            throw Error("Subsribe without giving subscribe strings");
        }
    }

    /**
     * Adds a subscription to the connection
     * @param {any} clientId id of the client
     * @param {object} subscribe {Qos, topics}
     * @throws {Error} if clientId does not match or subscription is not given
     */
    subscribe(clientId, subscribe) {
        this.validateSubscribe(clientId, subscribe);
        let QoS = this.convertQoSToValidQoS(subscribe.QoS);

        if (!Array.isArray(subscribe.topics)) {
            this.subscribePattern.setPattern(subscribe.topics, QoS);
        } else {
            subscribe.topics.forEach((topic) => {
                this.subscribePattern.setPattern(topic, QoS);
            });
        }
    }

    /**
     * removes subscriptions from a connection
     * @param {any} clientId id of the client
     * @param {object} subscribe {topics}
     * @throws {Error} if clientId does not match or subscription is not given
     */
    unsubscribe(clientId, subscribe) {
        this.validateSubscribe(clientId, subscribe);
        this.subscribePattern.removePattern(subscribe.topics);
    }

    /**
     * Adds a message to an ordered topic
     * @param {object} messageQueueEntry entry of the message queue
     */
    addMessageToOrderedTopic(messageQueueEntry) {
        const MAX_QUEUED_MESSAGES_PER_TOPIC = 100;
        let message = messageQueueEntry.payload;
        let topic = message.topic;

        if (!Array.isArray(this.orderedTopicsQueue[topic])) {
            this.orderedTopicsQueue[topic] = [];
        }
        this.orderedTopicsQueue[topic].push(messageQueueEntry);
        if (this.orderedTopicsQueue[topic].length > MAX_QUEUED_MESSAGES_PER_TOPIC) {
            this.orderedTopicsQueue[topic].slice(0, 1);
        }
    }

    /**
     * checks, if a message must be published 
     * @param {object} message message to add to a publish storage
     * @param {object} QoS quality of service received from published headers
     */
    checkAndSetMessagesToPublish(message, QoS) {
        let topic = message.topic;
        let matchQoS = this.subscribePattern.getBestMatch(topic);
        if (matchQoS !== undefined) {
            QoS = this.calcQoS(QoS, matchQoS);
            let messageQueueEntry = new MessageQueueEntry(QoS, message);
            if (QoS === 0) {
                this.QoS0Queue.push(messageQueueEntry);
            } else {
                messageQueueEntry.setId(this.genMessageId());
                this.addMessageToOrderedTopic(messageQueueEntry);
            }
    
        }
    }

    /**
     * Deletes a message from the message queue if the id matches
     * @param {string} topic topic to delete message from
     * @param {Number} id id of the message
     */
    deleteMessageById(topic, id) {
        let messageQueue = this.orderedTopicsQueue[topic];
        if (Array.isArray(messageQueue)) {
            for (let index in messageQueue) {
                let messageQueueEntry = messageQueue[index];
                if (messageQueueEntry.id === id) {
                    messageQueue.splice(index, 1);
                    break;
                }
            }
        }
    }

    /**
     * calculates the next message id
     * @returns {number} message id
     */
    genMessageId() {
        var result = this.nextMessageId;
        if (result >= 0 || result < 0xFFFF) {
            this.nextMessageId++;
        } else {
            result = 0;
            this.nextMessageId = 1;
        }
        return result;
    }

    /**
     * Converts a QoS to a valid QoS. (0,1,2) by converting it to Number and setting it to "0" on any invalid entry
     * @param {any} Qos QoS to transform
     * @return {Number} valid QoS
     */
    convertQoSToValidQoS(QoS) {
        var numberQoS = Number(QoS);
        if (numberQoS != 1 && numberQoS != 2) {
            numberQoS = 0;
        }
        return numberQoS;
    }

    /**
     * Calculates the resulting QoS from message an subscription
     * @param {Number} messageQoS QoS from message
     * @param {Number} subscribeQoS QoS from subscription
     */
    calcQoS(messageQoS, subscribeQoS) {
        var validMessageQoS = this.convertQoSToValidQoS(messageQoS);
        var validSubscribeQoS = this.convertQoSToValidQoS(subscribeQoS);
        var result = Math.min(validMessageQoS, validSubscribeQoS);
        return result;
    }

    /**
     * process entries for an ordered topic 
     * @param {string} topic topic of the messages
     * @param {number} inFlightWindow maximal amount of messages to process
     * @param {number} timeoutInMilliseconds timeout waiting for messages
     * @param {function} callback(entry) called for each entry
     */
    processOrderedTopicMessages(topic, inFlightWindow, timeoutInMilliseconds, callback) {
        let queue = [...this.orderedTopicsQueue[topic]];
        let count = 0;
        let now = (new Date()).getTime();
        for (let entry of queue) {
            if (entry.status === "new") {
                entry.status = "sending";
            } else if (entry.transmitTimestamp + timeoutInMilliseconds < now) {
                entry.status = "duplicate";
            } else {
                break;
            }
            entry.startTransmission();
            callback(entry);
            count++;
            if (count === inFlightWindow) break;            
        }
    }

    /**
     * Gets the maximal retry count for a client
     */
    getMaxRetryCount() {
        let result = 0;
        for (let topic in this.orderedTopicsQueue) {
            let queue = this.orderedTopicsQueue[topic];
            // We only check the first entry, as all following entries may not have a higher 
            // retry count 
            if (queue.length > 0) {
                let entry = queue[0];
                if (entry.retryCount > result) {
                    result = entry.retryCount;
                }
            }
        }
        return result;
    }

     /**
     * clears all retry counts
     */
    clearRetryCount() {
        for (let topic in this.orderedTopicsQueue) {
            let queue = this.orderedTopicsQueue[topic];
            for (let entry of queue) {
                entry.retryCount = 0;
            }
        }
    }

    /**
     * processes all entries of the QoS0Message queue and deletes the queue
     * @param {function} callback(entry)
     */
    processQoS0Messages(callback) {
        let QoS0Queue = [...this.QoS0Queue];
        this.QoS0Queue = [];
        for (let entry of QoS0Queue) {
            entry.status = "sending";
            callback(entry);
        }
    }

    /**
     * Validates the object, throws errors, on failure
     */
    validate() {
        if (this.clientId === undefined) {
            throw Error("Connection without client id (clientId)");
        }
        if (this.host === undefined) {
            throw Error("Connection without host");
        }
        if (this.port === undefined) {
            throw Error("Connection without port");
        }
        if (this.clean !== true && this.clean !== false) {
            throw Error("Illegal clean value " + this.clean)
        } 
    }

 };