/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const HttpClient = require('@mangar2/httpservice').HttpClient
const HttpServer = require('@mangar2/httpservice').HttpServer
const HttpsClient = require('@mangar2/httpservice').HttpsClient
const HttpsServer = require('@mangar2/httpservice').HttpsServer
const UnitTest = require('@mangar2/unittest')
const shutdown = require('@mangar2/shutdown')
const fs = require('fs')

const TEST_HTTPS = false

let httpClient = null 
const httpServer = new HttpServer(0)

let httpsClient = null
const httpsServer = new HttpsServer(0)

const unitTest = new UnitTest(false)

process.env.NODE_TLS_REJECT_UNAUTHORIZED = 0
const methods = ['put', 'get', 'post', 'delete', 'patch', 'options']

const DATA = {
    a: 'abcdefghijklmnopqrstuvwxyzäüöß',
    b: 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz',
    c: 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz',
    d: 'dabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz',
    e: 'eabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz',
    f: 'fabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz',
    g: 'gabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz',
    h: 'habcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz',
    i: 'habcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz'
}

async function testTimeout () {
    const httpTimeoutClient = new HttpClient('192.168.0.4', 9200)
    await httpTimeoutClient.getRequest('get')
}

/**
 * Registers a response function to be called, when the server receives data
 * @param {HttpServer} server server calling the method
 * @param {string} method http method (put, get, ...)
 */
const setResponseFunction = (server, method) => {
    const responseFunction = (payload, headers, path, res) => {
        res.writeHead(200, { 'Content-Type': 'application/json' })
        if (method === 'get') {
            payload = payload.toString()
        }
        const result = JSON.stringify({ method, payload, headers, path })
        res.end(result)
    }
    server.on(method, responseFunction)
}

/**
 * Sets listen functions to all http methods (get, put, ...)
 * @param {HttpServer} server server to listen for data
 * @param {Object} options http(s) options
 */
async function listen (server, options) {
    for (const method of methods) {
        setResponseFunction(server, method)
    }
    await server.listen(options)
}


let httpsOptions = {}

/**
 * Verifies the data returned
 * @param {Object} result returned data
 */
function verify (result, method) {
    const resultObject = JSON.parse(result.payload)
    const test1 = unitTest.assertEqual(result.statusCode, 200, method + ' statusCode')
    const test2 = unitTest.assertEqual(resultObject.method, method, method + ' payload')
    const test3 = method === 'get'
        ? unitTest.assertEqual(resultObject.payload, 'a=hello&b=world', method + ' payload')
        : unitTest.assertEqual(resultObject.payload, JSON.stringify(DATA), method + ' payload')
    const test4 = unitTest.assertEqual(result.headers['content-type'], 'application/json', method + ' payload')
    const test5 = unitTest.assertEqual(resultObject.path, '/clients', method + ' payload')

    if (!test1 || !test2 || !test3 || !test4 || !test5) {
        console.log(JSON.stringify(result, null, 2))
    }
}

/**
 * Sets a http and a https server to listen
 */
async function prepare () {
    await listen(httpServer)
    httpClient = new HttpClient('127.0.0.1', httpServer.address.port)
    // console.log('you need to provide a key.pem and a cert.pem file for the test')
    if (TEST_HTTPS) {
        httpsOptions = {
            key: fs.readFileSync('key.pem'),
            cert: fs.readFileSync('cert.pem')
        }
        await listen(httpsServer, httpsOptions)
        httpsClient = new HttpsClient('127.0.0.1', httpsServer.address.port)
    }
}

async function testTypes() {
    const options = {
        path: '/clients?a=hello&b=world',
        payload: DATA,
        header: { packetid: 1, packet: 'publish' },
        type: 'json'
    }
    let result = await httpClient.post(options).catch(err => {
        unitTest.fail(err)
    })
    const resultParsed = JSON.parse(result.payload)
    const payloadParsed = JSON.parse(resultParsed.payload)
    unitTest.assertDeepEqual(payloadParsed, options.payload, 'types/post/payload')

}

// ich moechte gerne https benutzen
// Success, if http httpServer is started too
(async () => {
    await prepare()

    const options = {
        path: '/clients?a=hello&b=world',
        payload: DATA,
        header: { packetid: 1, packet: 'publish' },
        type: 'json'
    }
    for (const method of methods) {
        options.method = method
        console.log('Testing http, method: %s', method)
        let result = await httpClient.send(options.path, options.method, options.payload, options.header).catch(err => {
            unitTest.fail(err)
        })
        verify(result, method)

        result = await httpClient.sendv2(options).catch(err => {
            unitTest.fail(err)
        })
        verify(result, method)

        if (TEST_HTTPS) {
            result = await httpsClient.send(options.path, options.method, options.payload, options.header).catch(err => {
                unitTest.fail(err)
            })
            verify(result, method)
        }
    }
    await testTypes()
    try {
        console.log('test timeout, please wait... Error ECONNREFUSED expected')
        await testTimeout()
    } catch (error) {
        console.log(error)
        unitTest.success('timeout')
    }
    if (TEST_HTTPS) {
        unitTest.showResult(92)
    } else {
        unitTest.showResult(62)
    }
    process.exit(0)
})()

shutdown(async () => {
    await httpClient.close()
    await httpServer.close()
    if (TEST_HTTPS) {
        await httpsClient.close()
        await httpsServer.close()
    }
    process.exit(0)
})
