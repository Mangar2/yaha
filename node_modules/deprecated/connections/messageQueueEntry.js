/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 */

'use strict'

const Message = require('@mangar2/message')

/**
 * @private
 * @description
 * Creates a new message queue entry storing all information to send a message including receiver
 * @param {Object} param parameter object
 * @param {number} [param.qos=0] quality of service (0, 1 or 2)
 * @param {boolean} [param.retain=false] true, if the message is triggered by a retain message
 * @param {Message} [param.payload={}] payload of the entry
 * @param {number} param.packetid id of the transmit packet
 * @param {string} param.clientId id of the client
 * @param {string} param.host host name or ip address of the client
 * @param {number} param.port port number of the client
 * @param {string} [param.version='1.0'] version number of the client interface (x.y)
 * @param {string} param.token client receive token
 */
class MessageQueueEntry {
    constructor (param = {}) {
        // Quality of service to transmit the payload
        this.qos = param.qos || 0
        this.retain = param.retain || false
        // Any payload
        this.payload = param.payload || {}
        // Unique packetid to identify the entry (optional)
        this.packetid = param.packetid
        // Timestamp the payload was transmitted
        this.transmitTimestamp = 0
        // Status of the entry
        this.status = 'new'
        // Amount of retries to transmit the playload
        this.retryCount = 0

        this.clientId = param.clientId
        this.host = param.host
        this.port = param.port
        this.version = param.version || '1.0'
        this.token = param.token
    }

    /**
     * Payload of the message
     * @type {Message|Object}
     */
    get payload () { return this._payload }
    set payload (payload) { this._payload = payload }

    /**
     * Id of the transfer packet
     * @type {number}
     */
    get packetid () { return this._packetid }
    set packetid (packetid) { this._packetid = packetid }

    /**
     * Mqtt quality of service, accepts string, default 0 (possible values: 0,1 or 2)
     * @type {0|1|2}
     */
    get qos () { return this._qos }
    set qos (qos) {
        this._qos = Number(qos)
        if (this._qos !== 1 && this._qos !== 2) {
            this._qos = 0
        }
    }

    /**
     *  1 signals that it is a duplicate (has been send before), accepts also
     *  true/false or '1'/'0' instead of 1/0
     * @type {number}
     */
    get dup () { return this.retryCount > 1 ? 1 : 0 }
    set dup (dup) {
        this._dup = dup === true || dup === 'true' || dup === 1 || dup === '1' ? 1 : 0
    }

    /**
     *  1 signals that a message is send due to a retain subscription
     * @type {0|1}
     */
    get retain () { return this._retain }
    set retain (retain) { this._retain = retain }

    /**
     * Id of the client
     * @type {string}
     */
    get clientId () { return this._clientId }
    set clientId (clientId) { this._clientId = clientId }

    /**
     * Status of the entry {new, duplicate, pubrel}
     * @type {string}
     */
    get status () { return this._status }
    set status (status) { this._status = status }

    /**
     * Version of the interface to use 'major.minor'
     * @type {string}
     */
    get version () { return this._version }
    set version (version) { this._version = version }

    /**
     * Timestamp of the last message transmit
     * @type {number}
     */
    get transmitTimestamp () { return this._transmitTimestamp }
    set transmitTimestamp (transmitTimestamp) { this._transmitTimestamp = transmitTimestamp }

    /**
     * Amount of retries to send the package
     * @type {number}
     */
    get retryCount () { return this._retryCount }
    set retryCount (retryCount) { this._retryCount = retryCount }

    /**
     * The client receive token
     * @type {string}
     */
    get token () { return this._token }
    set token (token) { this._token = token }

    /**
     * Host name of the client
     * @type {string}
     */
    get host () { return this._host }
    set host (host) { this._host = host }

    /**
     * Port number of the client
     * @type {number}
     */
    get port () { return this._port }
    set port (port) { this._port = port }

    /**
     * @private
     * @description
     * Creates a message object from a java script object
     * @param {Object} payload payload
     * @param {string} payload.topic topic of the message
     * @param {(number|string)} payload.value value of the message
     * @param {{timestamp: number, message: string}[]} payload.reason array of reasons why the message occured
     * @returns {Message} payload as Message object
     */
    _createMessage (payload) {
        let result
        try {
            result = new Message(payload.topic, payload.value, payload.reason)
        } catch (err) {
            result = payload
        }
        return result
    }

    /**
     * Restore the object by setting all properties (usually from a file)
     * @param {Object} properties object with all needed properties of this class.
     */
    restoreFromObject (properties) {
        for (const property in this) {
            this[property] = properties[property]
        }
        this.payload = this._createMessage(this.payload)
    }

    /**
     * Sets infos of the client
     * @param {string} clientId id of the client
     * @param {string} host host name of the client
     * @param {number} port port number of the client
     * @param {string} version client interface version
     * @param {string} token token clients may check receiving published messages
     */
    setClientInfo (clientId, host, port, version, token) {
        this.clientId = clientId
        this.host = host
        this.port = port
        this.version = version
        this.token = token
    }

    /**
     * Sets the status to pubrel
     */
    setStatusToPubrel () {
        this.status = 'pubrel'
        this.retryCount = 0
    }

    /**
     * increases the retry counter and stores the actual timestamp
     */
    setTransmissionTimestamp () {
        const now = (new Date()).getTime()
        this._transmitTimestamp = now
        this.retryCount++
    }

    /**
     * Checks, if the status is pubrel
     * @returns {boolean}
     */
    isStatusPubrel () {
        return this.status === 'pubrel'
    }

    /**
     * Link to send the message to (/publish or /pubrel)
     * @readonly
     * @type {string}
     */
    get link () {
        if (this.status === 'pubrel') {
            return '/pubrel'
        } else {
            return '/publish'
        }
    }
}

module.exports = MessageQueueEntry
