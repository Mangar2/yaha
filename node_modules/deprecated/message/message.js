/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview
 * This is the basic class holding MQTT message information
 * The yaha home automation is based on messages. Nothing happens without a message.
 * The message runs from creator to broker and then to the receiver.
 * On every step, a reason will added to the mesage including a timestamp to get a full trace.
 */

'use strict'

const { types } = require('@mangar2/utils')
const CheckInput = require('@mangar2/checkinput')

// Define a schema for message objects with a required `topic` property and an array of `reasons`
const checkMessage = new CheckInput({
    type: 'object',
    properties: {
        topic: { type: 'string' },
        value: { type: [ 'string', 'number' ]},
        reason: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    message: { type: 'string' },
                    timestamp: { type: 'string' }
                },
                required: ['message']
            }
        },
        qos: { type: 'integer', mininteger: 0, maxinteger: 2}
    },
    required: ['topic', 'value']
})

/**
 * @typedef {Object} ReasonEntry
 * @property {string} timestamp - Timestamp of the event in ISO format
 * @property {string} message - Event message
 */

/**
 * @typedef {ReasonEntry[]} Reason - An array of `ReasonEntry` objects
 */

/**
 * @description
 * Creates a message object that can be sent over MQTT
 * @param {string} topic - Topic string to publish to
 * @param {(string|number)} [value=''] - Value to set topic to
 * @param {string|Reason} [reason=null] - Explaining why the topic will be set to value
 * @param {0,1,2} [qos=1] - quality of service level
 * @param {boolean} [retain=false] - wether the message shall be retained or not
 * @param {Date} [now= new Date()] - Current time
 * @example
 * const message = new Message('this/is/a/topic', 'a value', 'a reason')
 */
class Message {
    constructor (topic, value = '', reason = null, qos = 1, retain = false, now = new Date()) {
        this.topic = topic
        this.value = value
        this.qos = qos
        this.retain = retain
        if (reason !== undefined && reason !== null) {
            if (types.isArray(reason)) {
                this.reason = [...reason]
            } else if (types.isObject(reason)) {
                this.reason = [reason]
            } else {
                this.addReason(reason, now)
            }
        }
        Message.validate(this)
    }

    /**
     * Sets the value of the message
     * @type {string|number}
     */
    set value (value) { this._value = value }
    get value () { return this._value }

    /**
     * Returns true if the value is "on" (1, 'on', 'true', true), false otherwise
     * @type {boolean}
     */
    isOn () {
        return (this._value === 'on' || this._value === 'ON' || this._value === 'true' || this._value === true || this._value === 1)
    }

    /**
     * The quality of service (0, 1 or 2) that the message should be delivered with
     * @type {integer}
     */
    set qos (qos) { this._qos = qos }
    get qos () { return this._qos }

    /**
     * Whether the message shall be retained or not
     * @type {boolean}
     */
    set retain (retain) { this._retain = retain }
    get retain () { return this._retain }

    /**
     * Adds a new reason object to `this.reason`
     * @param {string} reason - Explaining why the topic will be set to value
     * @param {Date|undefined} now - Current time. Defaults to the current date if undefined.
     */
    addReason (reason, now = new Date()) {
        if (!Array.isArray(this.reason)) {
            this.reason = []
        }
        this.reason.push({
            message: reason,
            timestamp: now.toISOString()
        })
    }

    /**
     * Gets the latest date of the message by browsing the reasons
     * @returns {Date | undefined}
     */
    getDateOfNewestChange () {
        var time = undefined
        if (this.reason !== undefined) {
            for (const element of this.reason) {
                const timestamp = element.timestamp
                if (timestamp !== undefined) {
                    time = new Date(timestamp)
                    break
                }
            }
        }
        return time
    }

    /**
     * Validates that the message object matches the defined schema
     * @param {Object} object - Object to validate or `this`
     * @throws {error} - Throws an exception if the validation fails
     */
    static validate (object) {
        if (checkMessage.validate(object) !== true) {
            throw Error(JSON.stringify(checkMessage.messages, null, 2))
        }
    }

    /**
     * Ensures that the JSON format is well formatted (value instead of _value)
     */
    toJSON () {
        return {
            topic: this.topic,
            value: this._value,
            reason: this.reason,
            qos: this._qos,
            retain: this._retain
        }
    }
}

module.exports = Message
