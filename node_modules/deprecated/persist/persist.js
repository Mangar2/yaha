/**
 * @license
 * This software is licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 3. It is furnished
 * "as is", without any support, and with no warranty, express or implied, as to its usefulness for
 * any purpose.
 *
 * @author Volker Böhm
 * @copyright Copyright (c) 2020 Volker Böhm
 * @overview persists JSON objects to a file. Keeps several files and loads older files if the latest is
 * broken
 */

'use strict'

const fs = require('fs')
const assert = require('assert')
const { errorLog } = require('@mangar2/utils')

const ONE_SECOND_IN_MILLISECONDS = 1000

/**
 * Creates a new persistence support class.
 * @class
 * @param {Object} configuration - Configuration options.
 * @param {number|string} [configuration.keepFiles=5] - Amount of file versions to keep (including the recently written file).
 * @example
 * const persist = new Persist({ keepFiles: 5 });
 * persist.saveObjectToFile('.', 'helloworld.json', { message: 'hello world' });
 * const dataRead = persist.readData('.', 'helloworld.json');
 * // prints 'hello world'
 * console.log(dataRead.message);
 */
class Persist {
    constructor (configuration = {}) {
        this.keepFiles = Number(configuration.keepFiles) || 5
        this.writeTimestamp = Date.now()
    }

    /**
     * @private
     * @description
     * Checks, if we are currently writing a file
     */
    isWritingFile () {
        return this.writeTimestamp === undefined
    }

    /**
     * @private
     * @description
     * Checks, if the last write timestamp is longer ago than a privided amount of seconds.
     * @param {number} timeoutInSeconds if the file is older than ...
     * @returns {boolean} true, if the file is outdated
     */
    fileIsOutdated (timeoutInSeconds) {
        let fileIsOutdated = false
        if (!this.isWritingFile()) {
            fileIsOutdated = (Date.now() - this.writeTimestamp) > timeoutInSeconds * ONE_SECOND_IN_MILLISECONDS
        }
        return fileIsOutdated
    }

    /**
     * @private
     * @description
     * Gets the local time in ISO string format
     * @returns {string} local time in ISO string format
     */
    static getLocalTimeAsISOString () {
        const tzoffsetInMilliseconds = (new Date()).getTimezoneOffset() * 60 * ONE_SECOND_IN_MILLISECONDS
        const localTime = (new Date(Date.now() - tzoffsetInMilliseconds))
        const localISOTime = localTime.toISOString().slice(0, -1)
        return localISOTime
    }

    /**
     * @private
     * @description
     * Deletes a file at the specified path
     * @param {string} filePath The file path to delete
     * @returns {Promise<void>} A Promise that resolves with no value when the file is successfully deleted, and rejects with an error if an error occurs.
     */
    static async deleteFile (filePath) {
        return new Promise((resolve, reject) => {
            fs.unlink(filePath, err => {
                if (err) {
                    reject(err)
                } else {
                    resolve()
                }
            })
        })
    }

    /**
     * @private
     * @description
     * Writes data to a file.
     * @param {string} fileAndPathName The name of the file to be written (including the path).
     * @param {string} data The data to be saved.
     * @returns {Promise} A promise that resolves when the data has been successfully written, or rejects with an error if the write operation failed.
     */ 
    static async writeFile (fileAndPathName, data) {
        return new Promise((resolve, reject) => {
            fs.writeFile(fileAndPathName, data, (err) => {
                if (err) {
                    reject(err)
                } else {
                    resolve()
                }
            })
        })
    }

    /**
     * @private
     * @description
     * Reads a directory and sorts it
     * @param {string} directory - The directory to read and sort files.
     * @returns {Promise<string[]>} - A Promise that resolves to a sorted array of filenames.
     */
    static async readDir (directory) {
        return new Promise((resolve, reject) => {
            fs.readdir(directory, (err, files) => {
                if (err) {
                    reject(err)
                } else {
                    files.sort()
                    resolve(files)
                }
            })
        })
    }

    /**
     * @private
     * @description
     * Generates a regular expression to check if a filename matches a specific format.
     *
     * The generated regular expression matches filenames that start with the given `filenameStart`
     * followed by a date string in the format YYYY-MM-DD. 
     *
     * @param {string} filenameStart The basis filename to match.
     * @returns {RegExp} The generated regular expression.
     */
    static genFileMatch (filenameStart) {
        return new RegExp('^' + filenameStart + '\\d{4}-\\d{2}-\\d{2}')
    }

    /**
     * Filters an array of file names based on whether the file name matches a specific format.
     *
     * The file name format is generated by `genFileMatch()`, which matches filenames that start with
     * the given `filenameStart` followed by a date string in the format YYYY-MM-DD.
     *
     * @param {Array} files - array of file names
     * @param {string} filenameStart - string that should be at the beginning of the file name
     * @returns {Array} - array of file names that match the generated file name format
     */
    static filterFiles(files, filenameStart) {
        const fileMatch = Persist.genFileMatch(filenameStart)
        const filteredFiles = files.filter((filename) => filename.match(fileMatch))
        return filteredFiles
    }

    /**
     * @private
     * @description
     * Deletes old files from the data directory
     * @param {string} directory directory to delete file
     * @param {string} filenameStart basis filename of the file.
     * @param {number} keepFiles amount of files to keep
     */
    static async deleteOldFiles (directory, filenameStart, keepFiles) {
        const files = await Persist.readDir(directory)
        const filteredFiles = Persist.filterFiles(files, filenameStart)
        const filesToDelete = keepFiles > 0 ? filteredFiles.slice(0, -keepFiles): filteredFiles

        for (const filename of filesToDelete) {
            await Persist.deleteFile(`${directory}/${filename}`)
        }
    }

    /**
     * Stringifies a JSON object and writes it to a file. The filename will include a timestamp.
     * This method logs errors to the console instead of throwing them.
     * @param {string} directory - The directory in which to save the file.
     * @param {string} filenameStart - The base filename for the file.
     * @param {Object} objectToSave - The JSON object to save.
     * @returns {undefined}
     */
    async saveObjectToFile (directory, filenameStart, objectToSave) {
        assert(typeof (filenameStart) === 'string', 'saveObjectToFile without filename')
        assert(typeof (directory) === 'string', 'saveObjectToFile without directory')
        assert(typeof (objectToSave) !== 'undefined', 'object to save is undefined')

        let timestamp = Persist.getLocalTimeAsISOString().replace(/:/g, '')
        const filePath = `${directory}/${filenameStart}${timestamp}.json`

        try {
            if (!this.isWritingFile()) {
                this.writeTimestamp = undefined
                const dataString = JSON.stringify(objectToSave)
                await Persist.writeFile(filePath, dataString)
                await Persist.deleteOldFiles(directory, filenameStart, this.keepFiles)
                this.writeTimestamp = Date.now()
            }
        } catch (err) {
            errorLog(err)
            this.writeTimestamp = Date.now()
        }
    }

    /**
     * @private
     * @description
     * Reads the newest file from an array of files, beginning with the last filename in the array.
     * It stops when it successfully reads a file.
     * @param {string} directory - Directory to search for files.
     * @param {string} filenameStart - Basis filename of the file.
     * @param {Array} files - Array of filenames in the current directory.
     * @returns {Object} - Read data as an object created with JSON.parse.
     */
    static readNewestFile (directory, filenameStart, files) {
        const fileMatch = Persist.genFileMatch(filenameStart)
        let result
        for (const filename of files.reverse()) {
            const filePath = `${directory}/${filename}`
            if (filename.match(fileMatch)) {
                try {
                    const contents = fs.readFileSync(filePath)

                    if (contents !== undefined) {
                        result = JSON.parse(contents)
                        break
                    }
                } catch (err) {
                    errorLog(err)
                }
            }
        }
        return result
    }

    /**
     * Reads the latest data from a file in the given directory that matches the specified filename basis.
     *
     * @param {string} directory - The directory to search for the file in.
     * @param {string} filenameStart - The base name of the file to search for.
     * @returns {Object|undefined} - The object read from the file, or undefined if an error occurred.
     */
    readData (directory, filenameStart) {
        let data
        try {
            const files = fs.readdirSync(directory + '/')
            files.sort()
            data = Persist.readNewestFile(directory, filenameStart, files)
        } catch (err) {
            data = undefined
            errorLog(err)
        }
        return data
    }
}

module.exports = Persist
